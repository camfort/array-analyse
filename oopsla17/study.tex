%\setlength{\tabcolsep}{8pt}

\noindent
We start with the following hypotheses about array programming idioms
in scientific code, formed from our observations and conversations
with scientists:
%
\begin{enumerate}[leftmargin=2em]
\item Loops over arrays mainly read from arrays with a static pattern
based on constant offsets from (base or dervied) induction variables;

\item Most loop-array computations of the previous form read
from arrays with a \emph{contiguous} pattern, \eg{}:
%
\begin{minted}{fortran}
  b(n) = (a(i) + a(i+1)) / 2.0
\end{minted}
%
\item Most loop-array computations of the previous form read
from arrays with a pattern that includes the immediate
neighbours (offsets of 1 from the induction variables);

\item Many array computations are \emph{stencil computations}: an
  assignment whose right-hand side comprises array subscripts with
  neighbourhood indices and whose left-hand side is an
  neighbourhood-indexed array subscript (\eg{}, the classic five-point
  stencil);

\item Many array computations read from each particular index just
once. The significance of this hypothesis is that, if true, it would
be useful to provide a specification of this so accidental repetition
of subscripts in complex code can be detected.
\end{enumerate}
%
From these hypotheses, we conjecture that the above programming idioms
can be specified declaratively via a small
set of combinators, capturing data access patterns based on
overlapping (hyper)rectangles. We performed a large scale source-code
analysis to validate these hypotheses and guide the design of our
language. These results are also of wider value to others, such as
designers of array/stencil DSLs or autotuners.

\subsection{Methodology}
%
\noindent
We constructed a corpus of \numPackages{} scientific computing
packages written in Fortran ranging in size and scope: The Unified
Model (UM)~\cite{um}, E3MG~\cite{RePEc:aen:journl:2006se-a12},
BLAS~\cite{blas}, Hybrid4~\cite{GBC:GBC635},
GEOS-Chem~\cite{geos-chem}, Navier (based on
\cite{griebel1997numerical}), Computational Physics 2 (CP2)
~\cite{nicholas2006computational}, ARPACK-NG~\cite{arpackng}, and
SPECFEM3D~\cite{specfem3d}. \dnote{Include the rest} This covers
approximately 1.4 million lines of physical Fortran code (2.4 million
including comments and white space).  Appendix~\ref{app:corpus}
provides further detail on these packages and their sizes, with UM and
GEOS-Chem the largest at $\approx$630kloc and $\approx$450kloc respectively. We used
Wheeler's \emph{SLOCCount} to get a count of the physical source lines
(excluding comments and blank lines)~\cite{wheeler2001sloccount}.

Half the packages come from active research teams who are our
project partners (\ie{}, they were not selected carefully to
fit our hypotheses). BLAS was selected as it is a common numerical library;
similarly CP2 was selected as it gives standard numerical
analysis algorithms from a popular computational physics textbook.
The smallest project Navier ($\approx$500loc) is based on a standard textbook on
computational fluid dynamics.

We built a code analysis tool based on CamFort, an open-source Fortran
analyser~\cite{camfort}. Fortran source files are parsed to an AST and
 standard control-flow and data-flow analyses are computed,
including of key importance for us: induction variable identification
and reaching definitions. The resulting AST is traversed top-down and
assignment statements inside loops are analysed and classified.

\paragraph{Classifications}

We focus on assignment statements in loops where the right-hand side
expression reads from one or more arrays.  Left-hand sides and
right-hand sides are classified in the following way:

\begin{tabular}{l|l|l|l}
  Shorthand & Classification (of subscripts) & Applies to & Example \\ \hline
 (\textsf{vars}) & Variables & LHS & \fortran{x = ...}
  \\
 (\textsf{IVs}) & Induction variables & LHS & \fortran{a(i, j)} \\
 (\textsf{neigh}) & Neighbourhood offsets (of the form
                                                  $i \pm c$) & LHS/RHS
                                                               & \fortran{a(i, j-1)} \\
 (\textsf{neigh+c}) & Neighbourhood offsets and constants & LHS/RHS &
                                                            \fortran{b(i, 0, j+1)} \\
 (\textsf{aff}) & Affine offsets (of the form $a * i \pm b$) & LHS/RHS &
                                     \fortran{a(2*i+1,j)} \\
 (\textsf{aff+c}) & Affine offsets and constants & LHS/RHS & \fortran{a(i+1, 0,
                                                   3*j+2)} \\
 (\textsf{other}) & Subscript expression not included above & LHS/RHS &
\fortran{x(f(i))}, \fortran{a(i*i)}
\end{tabular} \\[1em]

\noindent
Note \textsf{vars} and \textsf{IVs} classifications apply only to
left-hand sides.
The classification is computed from all information that flows into an
assignment, for example, the following decomposes a one-dimensional
three-point pattern across multiple intermediate assignments:
%%
\begin{minted}{fortran}
do i = 1, n
  x = a(i)
  y = a(i+1)
  b(i) = (a(i-1) + x + y)/3.0
end do
\end{minted}
%%x
Our analysis recognises this as one array computation (rather than three), starting at
line 4, and reading from subscripts \fortran{a(i)}, \fortran{a(i+1)},
\fortran{a(i-1)}. We thus traverse the body of a loop in reverse,
using reaching-definitions to calculate of the array reads that flow
to a particular assignment. Since \fortran{x} and \fortran{y} flow to
the line 4, line 2 and line 3 are not classified, though multiple
assignments can flow to multiple classified statements.

We further sub-classify sets of array subscripts
on the right-hand side based on their spatial properties: \\

\begin{tabular}{l||l|p{0.28\linewidth}|l}
  Property   & Shorthand & Classifications (of RHS pattern) & Example \\ \hline
%%%%%%
\multirow{2}{*}{Contiguity} & (\textsf{contig}) & Contiguous  &
                                                                \fortran{a(i) + a(i+1) + a(i+2)} \\
  & (\textsf{disjoint}) & Non-contiguous & \fortran{a(i) + a(i+2)} \\ \hline
%%%%%%
%\multirow{2}{*}{Shape} & (\textsf{rect}) & (Hyper)rectangle &
% \fortran{a(i,j) + a(i+1,j) + a(i,j+1) + a(i+1,j+1)} \\
%           & (\textsf{sumRect}) & Composed (hyper)rectangles &
%  \fortran{a(i,j) + a(i,j-1) + a(i-1,j) + a(i+1,j) + a(i,j+1)} \\ \hline
%%%%%%
  \multirow{2}{*}{Reuse} & (\textsf{readonce}) & Unique subscripts
                                         & \eg{} \fortran{b(i) = a(i) + a(i+1)} \\
  & (\textsf{mult}) & Repeated subscripts &
\eg{}  \fortran{b(i) = a(i)  + a(i)}
\end{tabular} \\[1em]

\noindent
To assess the hypothesis that
arrays are mostly read in a pattern that includes the immediate neighbours
to the ``origin'', we categorised the position of subscript patterns for each
right-hand side, in each dimension: \\

\begin{tabular}{l||l|p{0.33\linewidth}|l}
  Property   & Shorthand & Classification (indices per
                           dimension) & Example \\ \hline
%%%%%%
  \multirow{2}{*}{Positioning} & (\textsf{origin}) & Includes origin
& \fortran{a(i)} or \fortran{a(i+1, j)} (in $2^{\textit{nd}}$
  dimension) \\
             & (\textsf{straddle}) & Within distance 1 of origin &
\fortran{a(i+1), a(i-1)} \\
             & (\textsf{away}) & Away from the origin
                                          & \fortran{a(i+2), a(i+3)}
\end{tabular} \\[1em]

\noindent
Finally, we categorise the relationship between the left-hand side
and right-hand side, in terms of the use of induction variables.
The two sides are \emph{consistent} if the same induction variables
appear in each side, used for the same dimension. This is
weakened to a \emph{permutation} if the roles of the induction
variables changes. This is weakened further if the left-hand side
induction variables are either
a subset or superset of the induction variables on the right-hand
side. Otherwise, the two sides are seen as inconsistent:

\begin{tabular}{l|l|l}
  (\textsf{const}) & Consistent & \fortran{a(i, j) = b(i, j) +
                                  b(i+1,j+1)} \\
  (\textsf{perm}) & Permutation & \fortran{a(i, j) = c(j, i)} or \fortran{a(i,
                                                               0) =
                                 b(0, i)} \\
  (\textsf{LHSsub}) & LHS subset & \fortran{a(i) = b(i, j) + b(i, j-1)}
  \\
  (\textsf{LHSsup}) & LHS superset & \fortran{a(i, j) = b(i)} \\
  (\textsf{inconst}) & Inconsistent & \fortran{a(i) = b(j)}
\end{tabular} \\[1em]
%


%\begin{itemize}
% (Vars, ...)
%\item An assignment to a variable, with an RHS comprising some array
%  computation, tends to correspond to a reduction (e.g., calculating
%the max value in an array).
%\end{itemize}

\subsection{Results}

\noindent
We revist each hypothesis and show the related data and conclusions.
%
\begin{enumerate}
\item Loops over arrays mainly read from arrays with a static pattern
based on constant offsets from (base or dervied) induction variables;
\end{enumerate}
%
We identified $108,773$ instances of assignments within loops in
which an array subscript flows to the right-hand side. We refer
to each one of these as an \emph{array computation}.
We performed the classification described above
and grouped the data by the right-hand side classification only:
%%
\begin{center}
\begin{tabular}{l|S[table-format=4]@{\extracolsep{5pt}}S[table-format=2.2]c}
\textbf{RHS classification} & \textbf{Number} & \% &
\textit{grouping 1} \\ \hline
Affine                          & 34        & 0.03\%
& \multirow{3}{*}{81.43\%} \\ \cline{1-3}
Neighbourhood                   & 65334     & 60.06 \%  \\ \cline{1-3}
Neighbourhood + constants       & 23209     & 21.34\%  \\ \hline
Other                           & 20196     & 18.57 \%  \\ \hline \hline
\textbf{Total}                  & 108773    &  \\
\end{tabular}
\end{center}
%
\noindent
Since, affine and neighbour patterns are static, we
group them (\textit{grouping 1}) to see that $81.43\%$ of the array
computations (88,577) have a static pattern that are either constants or
constant offsets of base/derived induction variables, confirming
\emph{hypothesis 1}. Note that affine (derived induction variables)
are rare. Overwhelmingly, the main category is neighbourhood
offsets (possibly mixed with constants in some
dimensions). The ``affine + constants'' class is
not represented at all.
\mnote{(1) State that constant here includes variables that are constant with
respect to the current loop scope.}
\mnote{(2) Mention what sort of things are
included in other.}
\mnote{(3) Add a remark about lack of affine indices to be
perhaps programmers relying on compiler more regarding optimisations than hand
optimising. We can later use this to justify our inability to handle affine
indices.}
%
\begin{enumerate}[resume]
\item Most loop-array computations of the previous form read
from arrays with a \emph{contiguous} pattern, \eg{}:
%
\begin{minted}{fortran}
do i = 1, n
  b(n) = (a(i) + a(i+1)) / 2.0
\end{minted}
%
\item Most loop-array computations of the previous form read
from arrays with a pattern that includes the immediate
neighbours (offsets of 1 from the induction variables);
\end{enumerate}
%
We grouped the data based on subclassifications of \emph{grouping 1}
in terms of contiguity and positioning.
%Focussing on grouping 1.
\begin{center}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]lS[table-format=4]S[table-format=2.2]}
\textbf{RHS classification} & \textbf{Number} & \% {(of whole)}
&\textbf{Position} & \textbf{Number} & \% {(of whole)} \\ \hline
Affine, contiguous
& 31 & 0.03\% \\ \hline
%\multirow{3}{*}{Affine, contiguous}
% & %\multirow{3}{*}{31}
% & %\multirow{3}{*}{0.03\%}
% & \textsf{away} & 4 & 0.00\% \\
%& 31 & 0.03\% & \textsf{origin} & 15 & 0.01\% \\
%&&& \textsf{straddle} & 12 & 0.01\% \\ \hline
Affine, non-contiguous
 & 3
 & 0.00\% & \\ \hline
\multirow{3}{*}{Neighbour, contiguous}
 & %\multirow{3}{*}{83689}
 & %\multirow{3}{*}{83.08\%}
 & \textsf{away} & 152 & 0.14\% \\
& 83689 & 76.94\% & \textsf{origin} & 81309 & 74.75\% \\
&&& \textsf{straddle} & 2228 & 2.05\% \\ \hline
Neighbour, non-contiguous
 & 4854
 & 4.46\% \\ \hline
Other & 20196 & 18.57\%  \\
 \hline \hline
\textbf{Total}  & 88577    &  \\
\end{tabular}
\end{center}
%%
Thus, $76.94\%$ of array computations have only contiguous neighbour
indices (which may include constants in some indices) in a contiguous
pattern on the right hand side, with $76.80\%$ either at the origin
($74.75\%$) or offset by a distance of 1 from the origin
($2.05\%$). This confirms both hypotheses 2 and 3. Only 152 instances
of index patterns not immediately next to or over the origin were
found.  There is a non trivial amount of non-contiguous arrays access,
but it is a much smaller proportion of the whole.

\begin{enumerate}[resume]
\item Many array computations are \emph{stencil computations}:
an assignment whose
 right-hand side comprises array subscripts with neighbourhood indices
and whose left-hand side is an neighbourhood-indexed array subscript
(\eg{}, the classic five-point stencil);
\end{enumerate}
%
We subclassified the data based on the right-hand side
and left-hand side categories
being either a variable, or induction-variable indexed,
neighbour-indexed or affined-indexed array. We additionally
included an orthogonal classification of whether
left-hand and right-hand sides are consistent (have a common subset
of induction variables) or not.
%
\begin{center}
\begin{tabular}{ll|S[table-format=4]S[table-format=2.2]S[table-format=4]S[table-format=2.2]c}
\multicolumn{2}{l|}{\textbf{LHS and RHS classification}}
& \textbf{\# inconsistent}
& \% {(whole)}
& \textbf{\# consistent}
& \% {(whole)}
& \textit{stencils} \\ \hline
%
LHS Vars & RHS neigh & 0 & 0.00\% & 4591      & 4.22\%
 & \multirow{7}{*}{66.01\%} \\\cline{1-6}
%
%
%
LHS IVs & RHS neigh   &  4560      & 4.19\%  & 50861     & 46.76\% \\\cline{1-6}
%
%
LHS neigh & RHS neigh & 2358      & 2.17\% & 16336     & 15.02\%   \\\cline{1-6}
%
LHS Vars & RHS affines & 0 & 0.00\%  & 4         & 0.00\% \\\cline{1-6}
%
LHS IVs, & RHS affines & 7 & 0.01\% & 0 & 0.00\%  \\\cline{1-6}
%
LHS affine & RHS affines & 0 & 0.00\% &  6         & 0.01\% \\\hline
%
LHS neigh & RHS affines & 8         & 0.01\% & 0 & 0.00\%  \\\hline
%%
LHS affine & RHS neigh  & 23        & 0.02\% & 0 & 0.00\% \\\hline
%
other       &                      & 30019     & 27.60\%  & &  \\\hline%\hline
%Total        &                      & 108773    &
%  LHS var, & RHS affine             & 4         & 0.00\%
% & \multirow{7}{*}{72.37\%} \\\cline{1-3}
%  LHS var, & RHS neighbour          & 4591      & 4.22\%  \\\cline{1-3}
%  LHS IVs, &RHS affine             & 7         & 0.01\%  \\\cline{1-3}
%  LHS IVs, &RHS neighbour          & 55421     & 50.95\% \\\cline{1-3}
%  LHS neighbour, &RHS neighbour    & 18694     & 17.19\% \\\cline{1-3}
%  LHS affine, &RHS affine          & 6         & 0.01\%  \\\hline
%  LHS affine, &RHS neighbour       & 23        & 0.02\%  \\\hline
%  LHS neighbour, &RHS affine       & 8         & 0.01\%  \\\hline
%  other   & other                   & 30019     & 27.60\%  %\\\hline\hline
%  Total                           & 108773    &  \\
\end{tabular}
\end{center}
%
The most common category has an l.h.s array subscript
indexed by induction variables, and a right-hand side comprising
neighbourhood offsets. Next most common is to have neighbourhood
offsets on the left-hand and right-hand sides. Notably
there are two categories always seen as inconsistent:
``LHS affine, RHS neighbour'' and ``LHS neighbour, RHS affine''
since they comprise different indexing schemes
on each side of the assignment, e.g. $a(i + 1) = b(2*i + 1)$. These
appear very rarely. Thus, we find that $66.01\%$ of array computations
have a static pattern on the left and right-hand side that is either
affine or a constant translation. Thus, the data support ours
hypothesis that stencis are common. Based on this grouping, we
considered the two subclassifications of different kinds of
left-right-hand side relationship and contiguity:
%%
\begin{center}
\begin{minipage}{0.48\linewidth}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]}
\textbf{Contiguity} & \textbf{Number} & \% {(whole)} \\\hline
Contiguous stencil         & 68246     & 62.74\%  \\\hline
Non-contiguous stencil     & 3552      & 3.27\%  \\\hline
other                      & 36975     & 33.99\% \\\hline
%\textbf{Total}             & 108773    &  \\
\end{tabular}
\vspace{2.4em}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]S[table-format=4]S[table-format=2.2]}
\textbf{Consistency} & \textbf{Number} & \% & \textbf{relativised \#} & \% \\\hline
Direct                            & 47448     & 43.62\% & 636       & 0.58\%  \\\hline
LHSsubset                         & 9812      & 9.02\% & 65        & 0.06\%  \\\hline
LHSsuperset                       & 10110     & 9.29\%  & 84        & 0.08\%  \\\hline
Permutation                       & 3604      & 3.31\%  & 39        & 0.04\%  \\\hline
other                             & 36975     & 33.99\% \\\hline
\end{tabular}
\end{minipage}
\end{center}
%%
Most stencils are contiguous, but there is a non trivial
amount of non-contiguity. Most stencils have matching induction
variables on the left and right-hand sides but again there
are non-trivial amounts of other kinds of relationship.
%%
\begin{enumerate}[resume]
\item Many array computations read from each particular index just
  once.
\end{enumerate}
%
We classified right-hand sides which are neighbourhood offsets (or
affine) and subclassified this by whether array subscripts were
unique or repeated:

\begin{center}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]S[table-format=4]}
\textbf{RHS form and reuse} & \textbf{Number} & \% \\ \hline
RHS neighbour/affine unique indices      & 78349     & 72.03\%  \\\hline
RHS neighbour/affine repeated indices   & 10228     & 9.40\%  \\\hline
other                             & 20196     & 18.57\%  \\\hline\hline
Total                             & 108773    &
\end{tabular}
\end{center}
%
Thus, hypothesis 5 is confirmed, the majority of array computations
have access patterns with linear usage of array subscripts.