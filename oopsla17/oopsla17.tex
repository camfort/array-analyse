\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\usepackage{hyperref}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{syntax}
\usepackage{indentfirst}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{minted}
\usepackage{etoolbox}

\usepackage{stencilmacros}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=w),
  xleftmargin=3\parindent,
  numbersep=1em
}

\usemintedstyle{vs}

\setlength{\grammarindent}{3em} % increase separation between LHS/RHS

\newcommand{\inbar}{\ \ \textbar\ \ }

% For evluation and empirical study
% Defines the commands (headers)
\input{resultsCmds}
% renews the commands with actual data
% \input{results}

% Essential declarations
\theoremstyle{definition}
\newtheorem{defn}{Definition}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{case}{Case}

\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}



\title{Verifying Spatial Properties of Array Computations}

\author{Dominic Orchard}
\affiliation{
  \department{School of Computing}
  \institution{University of Kent}
}
\email{d.a.orchard@kent.ac.uk}


\author{Mistral Contrastin}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Mistral.Contrastin@cl.cam.ac.uk}

\author{Matthew Danish}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Matthew.Danish@cl.cam.ac.uk}


\author{Andrew Rice}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Andrew.Rice@cl.cam.ac.uk}


\begin{abstract}
  Arrays computations are the workhorse of numerical modelling and
  computational science. However, low-level manipulation of array
  indices is a source of program error.  Many practitioners are aware
  of the need to ensure program correctness, yet very few of the
  techniques from the programming research community are applied by
  scientists. We aim to change that by providing targetted lightweight
  verification techniques for scientific code.  We focus on the all
  too common mistake of array offset errors as a generalisation of
  off-by-one errors.  Firstly, we report on a code analysis study on
  twelve real-world computational science code base, identifying
  common idioms of array usage and their spatial properties. This
  provides much needed data on array programming idioms common in
  scientific code.  From this data, we designed a lightweight
  declarative specification language capturing the majority of array
  access patterns via a small set of combinators. We detail a semantic
  model, and the design and implementation of a verification tool for
  our specification language, which both checks and infers
  specifications.  We evaluate our tool on our corpus of scientific
  code and give verification case studies of bug fixes that are
  detected by our approach. We found roughly 60,000 targets for
  specification across roughly 1.2 million lines of code, showing the
  vast majority of array computations read from arrays in a pattern with
  a simple, regular, static shape.
\end{abstract}
  
%  We focus on one error-prone aspect of numerical code: the 
%  data access pattern of arrays. 

\begin{document}
\maketitle

\section{Introduction}

\paragraph{Context of this research}

There is an increasing awareness of the need for program verification
techniques in
science~\cite{post2005computational,oberkampf2010verification,orchard2014computational}.
Whilst there are various kinds of automated and semi-automated
verification tools available, they see little use in science. This is
partly due to a lack of training and a lack of awareness. But its also
due to a lack of targetting. This paper is part of a line of research
to provide lightweight verification tools targetting
programming patterns common in computational science code, 
that are easy to use by scientists, and that integrate with common
practises and workflows.


\subsection{Terminology and notation}

\begin{definition}[Induction variables]
  An integer variable is a \emph{base induction variable} if it is the control
  variable of a ``\texttt{for}'' loop, incremented by $1$ per iteration. A variable
  is interpreted as an induction variable only within the scope of the loop
  body. Throughout, $i, j, k$ range over induction variables.

  A \emph{derived induction variable} is an expression of the form $a
  i + b$, \ie{}, an affine expression on an induction variable $i$.
\end{definition}

\begin{definition}[Array subscripts and indices]
  An \emph{array subscript}, denoted $a(\bar{e})$, is an expression
  which reads from an array $a$ at an \emph{index} specified by a
  comma-separated sequence of integer expressions denoted $\bar{e}$ or
  in expanded form as $(e_1, \ldots, e_n)$. An index $e_i$ is called
  \emph{relative} if the expression involves an induction variable.
  An \emph{absolute index} is a integer expression which is constant
  relative to the enclosing loop.
\end{definition}

\begin{definition}[Neighbourhood index]
\label{def:neighbour}
  For an array subscript $a(\bar{e})$ an index $e \in \bar{e}$ is a
  \emph{neighbourhood index} if $e$ is of the form $e \equiv i$, $e \equiv i +
  c$, or $e \equiv i - c$, where $c$ is an integer constant. That is, a
  neighbourhood index is a constant translation of an induction variable. (The
  relation $\equiv$ identifies terms up-to commutativity of $+$ and the inverse
  relationship of $+$ and $-$ \eg{}, $(-b) + i \equiv i - b$).
\end{definition}

\section{An Empirical Study of Array Computations in Scientific Fortran code}



\begin{enumerate}
\item Stencils are ubiquitious;
\item Most stencils read their data from source arrays with a static pattern
base on constant offsets from the mid-point;
\item Most stencils read their data from contiguous \emph{regions} in an array;
\item Most stencils read each index at most once.
\end{enumerate}

\subsection{Study}
%
\noindent
We put together a corpus of around 1 million lines of Fortran code from a
\numPackages{} scientific computing packages ranging in size and scope: The Unified Model (UM)~\cite{um},
E3MG~\cite{RePEc:aen:journl:2006se-a12}, BLAS~\cite{blas},
Hybrid4~\cite{GBC:GBC635}, GEOS-Chem~\cite{geos-chem}, Navier (based
on \cite{griebel1997numerical}), Computational Physics
2~\cite{nicholas2006computational},
ARPACK-NG~\cite{arpackng}, and
SPECFEM3D~\cite{specfem3d}. Appendix~\ref{app:corpus} provides
further detail on these packages.

\begin{itemize}
% (Vars, ...)
\item An assignment to a variable, with an RHS comprising some array
  computation, tends to correspond to a reduction (e.g., calculating
the max value in an array).

\end{itemize}

\section{A Specification Language for Shape}

\begin{figure}[t]
\begin{align*}
\def\arraystretch{1}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{$\mathbb{N}_{>0}$}
\newcommand{\depthRange}{$\mathbb{N}_{>0}$}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec} \;
                        \texttt{::} \; v \\
\nonterm{regionDec} ::= &  \texttt{region} \; \texttt{::} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\[0.4em]
%\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}
%\\[1em]
\nonterm{spec} ::= & [\nonterm{mult},] \; [\nonterm{approx},] \; \nonterm{region} \\
\nonterm{mult} ::= & \term{readOnce} \\
\nonterm{approx} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \nonterm{rvar} \; \mid \;
                       \stencil{p}{\dimTy}{}{} \; \\
& {\qquad\; \mid \; \stencil{f}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{b}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{c}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \nonterm{region} \, \term{+}
  \, \nonterm{region} \; \mid \; \nonterm{region} \; \term{*} \; \nonterm{region}} \\[0.25em]
%\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{rvar}}
%\\[0.5em]
%\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \}) [, \texttt{mutual}]
%  \\[0.5em]
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+\\[-1em]
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\end{figure}

\subsection{Specification syntax}
\label{subsec:syntax}

\Cref{fig:syntax} gives the syntax of stencil specifications, which is
detailed below. The entry point is the \nonterm{specification} production which
splits into either a \emph{region declaration} or a \emph{specification
declaration}.
Regions comprise \emph{region constants} which are
combined via region operators \term{+} and \term{*}.

Region constants specify a finite interval in a 
single dimension relative to the origin and are either \term{pointed},
\term{forward}, \term{backward}, or \term{centered}. The region names are
inspired by numerical analysis terminology, \eg{} the standard explicit method for
approximating PDEs is known as the \emph{Forward Time, Centered Space} (FTCS)
scheme~\citep{dawson1991finite}.

Each region
constant has a dimension identifier $d$ given as a positive natural number.
Each constant except \term{pointed} has a depth
parameter $n$ given as a positive natural number; \term{pointed}
regions implicitly have a depth of $0$.

A \term{forward} region of depth $n$ specifies a contiguous
region in dimension $d$ starting at the origin. This corresponds
to specifying neighbourhood indices in dimension $d$ ranging from $i$ to $i + n$
for some induction variable $i$. Similarly, a
\term{backward} region of depth $n$ corresponds to contiguous indices
from $i$ to $i - n$ and \term{centered}
of depth $n$ from $i - n$ to $i + n$. A \term{pointed}
stencil specifies a neighbour index $i$. For example, the
following shows four specifications with four consistent stencil
kernels reading from arrays \term{a}, \term{b}, \term{c} and \term{d}:
%%
\begin{minted}{fortran}
!= stencil forward(depth=2, dim=1) :: a
e(i, 0) = a(i, 0) + a(i+1, 0) + a(i+2, 0)

!= stencil backward(depth=2, dim=1) :: b
e(i, j) = b(i, j) + b(i-1, j) + b(i-2, j)

!= stencil centered(depth=1, dim=1) :: c
e(i, j) = (c(j-1) + c(j) + c(j+1))/3.0

!= stencil pointed(dim=3) :: d
e(i, j) = d(0, 0, i)
\end{minted}
%%
Not every dimension needs to be specified, \eg{},
specifications on lines $1$, $4$, and $10$ leave some dimensions unspecified.
The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointed} which marks absence
of the origin.  For example, the following is a
\term{nonpointed} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointed) :: a
b(i) = a(i-1) + 10*a(i-2)
\end{minted}
%
Not every dimension needs to be specified, \eg{},
specifications on lines $1$, $3$, and $7$ leave some dimensions
unspecified which leaves indices in these dimensions unconstrained.

The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointed} which marks absence
of the origin.  For example, the following is a
\term{nonpointed} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointed) :: a
b(i) = a(i-1) + 10*a(i-2)
\end{minted}

\paragraph{Combining regions}

The region operators \term{+} and \term{*} respectively combine
regions by union and intersection. The intersection of two regions
$r \term{*} s$ means that any indices in the specified code must be
consistent with both $r$ and $s$ simultaneously.
 Dually, for the union of two regions
 $r \term{+} s$ means that indices in the specified code must be
 in consistent with one of $r$ or $s$, or both.
For example, the following \emph{nine-point stencil}
has a specification given by the product of two \texttt{centered}
regions in each dimension:
%%
\begin{minted}[breakindent=2.9em]{fortran}
x = a(i, j)   + a(i-1, j)   + a(i+1, j)
y = a(i, j-1) + a(i-1, j-1) + a(i+1, j-1)
z = a(i, j+1) + a(i-1, j+1) + a(i+1, j+1)
!= stencil centered(depth=1, dim=1) * centered(depth=1, dim=2) :: a
b(i, j) = (x + y + z) / 9.0
\end{minted}
%
%This pattern is common in image convolution applications.
The specification ranges over the
values that flow to the array subscript on the left-hand side,
and so ranges over the intermediate assignments to \term{x},
\term{y}, and \term{z}. Each index in the code is consistent
with both specifications simultaneously, \eg{}, \texttt{a(i-1, j+1)}
is within the centered region in dimension $1$ and the centered region
in dimension $2$.

The union of two regions $r \term{+} s$ means that any indices
in the specified code must be consistent with either of $r$ or $s$.
For example, the following gives the specification of a five-point
stencil which is the sum of two compound \texttt{pointed} and
\texttt{centered} regions in each dimension:
%
\begin{minted}{fortran}
!= stencil centered(depth=1, dim=1)*pointed(dim=2) + centered(depth=1, dim=2)*pointed(dim=1) :: a
b(i,j) = -4*a(i,j) + a(i-1,j) + a(i+1,j) + a(i,j-1) + a(i,j+1)
\end{minted}
%%
Here the left-hand side of \texttt{+} says that when the second dimension
(induction variable $j$) is fixed at the origin, the first dimension
(induction variable $i$) accesses the immediate vicinity of the origin
(to depth of one). The right hand side of \texttt{+} is similar but the dimensions are reversed.
This reflects the symmetry under rotation of the five-point stencil.

\paragraph{Region declarations and variables}

Region specifications can be assigned to region variables via
region declarations. For example, the shape of a
``\emph{Roberts cross}'' edge-detection convolution~\cite{davis1975survey}
can be stated:
%%
\begin{minted}{fortran}
!= region :: r1 = forward(depth=1, dim=1)
!= region :: r2 = forward(depth=1, dim=2)
!= region :: robertsCross = r1*r2
!= stencil robertsCross :: a
\end{minted}
This is useful for common patterns, such as the five-point
pattern, as the regions can be defined once and reused.
%%
\paragraph{Modifiers}
%%
Region specifications can be modified
by \emph{approximation} and \emph{multiplicity} information
(in \textit{spec} in \Cref{fig:syntax}).
The \texttt{readOnce} modifier enforces that no index appears more
than once (that is, its multiplicity is one). For example, all of
the previous examples could have \texttt{readOnce} added:
%
\begin{minted}{fortran}
!= stencil readOnce, backward(depth=2, dim=1) :: a
b(i+1) = a(i) + a(i-1) + a(i-2)
\end{minted}
%
This specification would be invalid if any of the
array subscripts were repeated. This modifier provides a way to
rule out any accidental repetition of array subscripts.
The notion is similar to that of linear types~\cite{wadler1990linear}, where a value must be used
exactly once. We opt for the more informative and easily understood name
\texttt{readOnce}. This modifier is optional, so it need not
be present even if the stencil is linear.

In some cases, it is useful to give a lower and/or upper bound for a
stencil. This can be done using either the \term{atMost} or
\term{atLeast} modifiers. This is particularly useful in situations
where there is a non-contiguous stencil pattern, which cannot be expressed
precisely in our syntax. For example:
%
\begin{minted}{fortran}
!= stencil atLeast, pointed(dim=1)         :: a
!= stencil atMost, forward(depth=4, dim=1) :: a
b(i) = a(i) + a(i+4)
\end{minted}

\subsection{Semantic model}
\label{sec:semantics}

\noindent
We define a simple set-theoretic denotational model of the semantics
of our specification language. This has a number of purposes:
(1) it serves to explain the meaning of our specifications
(2) it is used in the inference and checking algorithms
(\Cref{sec:analysis}); (3) justifies an equational theory for
specifications in the next section; and (4) can be used to guide
correct implementations.

As an initial informal intuition, consider the following simple
stencil computation.
%
\begin{minted}{fortran}
do i = 1, n
  b(i) = a(i,0) + a(i+1,0)
end do
\end{minted}
%
This is modelled by a vector of integer sets: $\langle{\{0, 1\},
  \mathbb{Z}\}}\rangle$ describing that in the first dimension
the array is read from at offsets of $0$ and $1$ from an induction
variable, and in the second dimension the array reads are
unconstrained. \dnote{Don't like this explanation.}

we model neighbourhood array subscripts
in the context of a loop by vectors of sets 

The model domain is over vectors of sets 
which we call \emph{index schemes}.

\begin{defn}[Extended integers]
  We define the set \zinf{} as
  $\mathbb{Z}$ extended with $\infty$ and $-\infty$. For any $a$ in
  \zinf{}, we have $-\infty \leq a \leq \infty$. The resulting set is
  a total order with top and bottom elements by $-\infty$ and
  $\infty$.
\end{defn}

\begin{defn}[Index scheme]
  An \emph{index scheme} is a vector of extended integer sets,
  that is, an index scheme of size $n$ is a value
  $\mathcal{P}(\zinf)^{n}$.
\end{defn}

\begin{defn}
The function $\textit{schematic}_I$ parameterised by
a set of induction variables $I$, which maps
from an array subscript into a $n$-dimensional (closed) interval:
%
\begin{align*}
\textit{schematic}_I(\bar{e}) & =
\prod_{i \in |\bar{e}|} \textit{interval}(e_i)
\qquad
\textit{interval}_I(e) = \begin{cases}
[c, c] & e = i \pm c \, \wedge \, i \in I \\
[-\infty, \infty] & FV(e) \cap I = \emptyset
\end{cases}
\end{align*}
Note that \textit{inveral} may be undefined (it is a partial function)
in which case \textit{schematic} is undefined if any of its
components are undefined.
\end{defn}



  


\section{Analysis, Checking, and Inference}

\section{Evaluation}

\bibliography{references}

\appendix
% http://2017.splashcon.org/track/splash-2017-OOPSLA#Instructions-for-Authors
% "There is no page limit for bibliographic references and appendices,
% and, therefore, for the overall submission."
\input{appendix}

\end{document}
