\documentclass[9pt,preprint]{sigplanconf}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{graphics}
\usepackage{fancyvrb}
\usepackage{subfigure}
\usepackage{amsthm}
\usepackage{multirow}
\usepackage{minted}
\usepackage{breqn}
\usepackage{enumitem}
%\usepackage{subcaption}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{tikz}
\usepackage{xypic}

\usetikzlibrary{calc}

%% http://tex.stackexchange.com/questions/55068/is-there-a-tikz-equivalent-to-the-pstricks-ncbar-command
\tikzset{
    ncbar angle/.initial=90,
    ncbar/.style={
        to path=(\tikztostart)
        -- ($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)
        -- ($(\tikztotarget)!($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztostart)$)
        -- (\tikztotarget)
    },
    ncbar/.default=0.5cm,
}

\tikzset{round left paren/.style={ncbar=0.4cm,out=110,in=-110}}
\tikzset{round right paren/.style={ncbar=0.4cm,out=70,in=-70}}


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=),
  xleftmargin=\parindent
}

\usemintedstyle{vs}

\definecolor{darkblue}{rgb}{0.0,0.0,0.5}
\definecolor{darkgreen}{rgb}{0.0,0.4,0.0}
\definecolor{darkdarkgreen}{rgb}{0.0,0.35,0.0}

\usepackage{hyperref}
\hypersetup{
    unicode=false,          % non-Latin characters in Acrobat's bookmarks
    pdftoolbar=true,        % show Acrobat toolbar?
    pdfmenubar=true,        % show Acrobat menu?
    pdffitwindow=false,      % page fit to window when opened
    pdftitle={},    % title
    pdfauthor={}
    pdfsubject={},   % subject of the document
    pdfnewwindow=true,      % links in new window
    pdfkeywords={keywords}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=darkblue,          % color of internal links
    citecolor=darkblue,        % color of links to bibliography
    filecolor=green,      % color of file links
    urlcolor=blue,          % color of external links
}


\CustomVerbatimEnvironment{SpecVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98,numbersep=0.9em}
\CustomVerbatimEnvironment{ExmVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,
xrightmargin=0.2cm,baselinestretch=0.98,numbers=left,numbersep=0.9em,commandchars=\\\{\}}
\CustomVerbatimEnvironment{IVerbatim}{Verbatim}{fontsize=\relsize{-1},xleftmargin=0.5cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98,numbersep=0.9em}


\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\definecolor{darkorange}{rgb}{0.5,0.2,0.0}
\definecolor{marco}{rgb}{0.0,0.3,0.5}
\definecolor{gray}{rgb}{0.2,0.2,0.2}

\newcommand\mdef{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

\newcommand{\bn}{\mathbb{N}}

\newcommand{\todo}[1]{\textcolor{blue}{Dom: #1}}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}

\newcounter{block}

\newtheorem{lemma}[block]{Lemma}
\newtheorem{proposition}[block]{Proposition}
%\newtheorem{definition}[block]{Definisssstion}

\theoremstyle{definition}

\newtheorem{theorem}[block]{Theorem}
\newtheorem{remark}[block]{Remark}
\newtheorem{example}[block]{Example}
\newtheorem{definition}[block]{Definition}

% Writing macros
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\newcommand{\dimId}{\texttt{dim}}

% Semantics related
\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

% Syntax macros
\newcommand{\nonterm}[1]{\textit{#1}}
\newcommand{\term}[1]{\texttt{#1}}

\newcommand{\stenRefl}[1]{\term{reflexive} \, (\term{dim=}#1)}
\newcommand{\stenFwd}[3]{\term{forward} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\stenBwd}[3]{\term{backward} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\stenCen}[3]{\term{centered} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\irrefl}{\texttt{irreflexive}}

\newcommand{\stenReflS}[1]{\term{refl} \, (\term{dim=}#1)}
\newcommand{\stenFwdS}[2]{\term{fwd} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\stenBwdS}[2]{\term{bwd} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\stenCenS}[2]{\term{cen} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\irreflS}{\texttt{irrefl}}

\newcommand{\stenFwdSR}[3]{\term{fwd} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenBwdSR}[3]{\term{bwd} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenCenSR}[3]{\term{cen} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenReflSR}[1]{\term{refl} (\term{dim=}#1)}

% SYNTAX OPERATIONS AND PREDICATES
\newcommand{\neigh}{\textsf{neigh}}
\newcommand{\arrayTy}{\textsf{array}}
\newcommand{\rhsExp}{\textsf{rhsExp}}
\newcommand{\var}{\textsf{var}}

%% VECTOR NOTATIONS
\newcommand{\vect}[1]{\textbf{#1}}

\newcommand{\vtwohs}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{cc}#1 \, & \, #2\end{array}\right]\!}

\newcommand{\vtwoh}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{cc}#1 \; & \; #2\end{array}\right]}

\newcommand{\vthreeh}[3]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{ccc}#1 \; & \; #2 \; & \; #3\end{array}\right]}
\newcommand{\vtwo}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}#1\\#2\end{array}\right]}
\newcommand{\vthree}[3]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}$#1$\\$#2$\\$#3$\end{array}\right]}
\newcommand{\stwo}[4]
%{\vtwo{#1}{#2}\!\vtwo{#3}{#4}}
{\setlength{\arraycolsep}{0.1em}
\left[\begin{array}{rr}$#1$ & $#3$\\$#2$ & $#4$\end{array}\right]}

\newcommand{\singleEntry}[2]{\textbf{J}_{#2}^{#1}}
\newcommand{\zeroEntry}[2]{\textbf{K}_{#2}^{#1}}

%% OPERATIONS ON SPANS and VECTORS
\newcommand{\containedin}{\sqsubseteq}

%% MODEL
\newcommand{\effdims}[2]{\mathit{constr}(#1)_{#2}}

\newcommand{\trule}[1]{{\footnotesize{#1}}}

\include{results}

\title{Verification of Stencil Computations with Spatial
  Specifications}
%\authorinfo{}{}{}
\authorinfo{Dominic Orchard \and Mistral Contrastin
\and Matthew Danish \and Andrew Rice}{University of Cambridge}{}

\begin{document}
\maketitle

\begin{abstract}
  Verifying the correctness of numerical computations relies on first
  giving a specification of their behaviour. In many cases, a
  numerical computation is derived from an underlying mathematical
  model, but this is often infeasible as a specification since it
  is highly decoupled from the implementation. In this paper, we consider a 
  lightweight specification technique between low-level and
  high-level specifications for numerical code. We
  target \emph{stencil computations}---a common idiom in numerical
  code, but one which is error-prone due to fine-grained indexing
  errors. We show that in practice, stencil computations tend
  to have a regular shape which is amenable to static analysis and
  simple specification. We describe an abstract spatial specification
  language for stencil computations that can be embedded as
  annotations in source code, along with inference, checking, and
  specification synthesis. We evaluate our
  language against a corpus of numerical Fortran code, and show that
  the vast majority of stencil computations indeed have a simple,
  regular, static shape. Around 10\% of the stencils found evoke a
  programming pattern for which indexing errors are plausible. 
  We simulate relevant programming errors in two stencil examples, 
  and show that we are able to detect the vast majority of potential
  errors. This paper details our stencil specification language, a
  denotational model, inference,
  checking, and synthesis procedures, our implementation, and
  our evaluation studies.
\end{abstract}


\keywords{program verification, specification, stencils}

\bibliographystyle{abbrvnat}

\section{Introduction}

\emph{Stencils} are a ubiquitous programming pattern, common in
scientific and numerical computing applications. Informally, a stencil
computation outputs an array, where the value at each index $i$ of
this array is calculated from a \emph{neighbourhood} of values around $i$ in
some input array(s), \eg{}, the Game of Life, convolutions in image
processing, approximations to differential equations. For example, the
following computes the one-dimensional discrete Laplace
transform (an approximation to a derivative) in Fortran:
%
\begin{minted}{fortran}
do iter = 0, itermax
   do i = 1, (n-1)
      b(i) = a(i-1) - 2*a(i) + a(i+1)
   end do
   a = b
end do
\end{minted}
%
Line 3 is the core of the stencil computation, calculating
values at \texttt{b(i)} from a neighbourhood of elements about
\texttt{a(i)}. Line 5 swaps
\texttt{a} and \texttt{b} between iterations, where \texttt{b} becomes the
input for the next iteration. %In Fortran, parentheses \texttt{( )} are used
%for array subscripts rather than the more familiar bracket syntax \texttt{[ ]}.
%
%This stencil computation exhibits statically decideable
%spatial and temporal relationships between $\texttt{a}$ and
%$\texttt{b}$.
The shape of the data access pattern on line 3 determines other aspects of the
program and its efficient implementation: how much ``boundary'' is
needed for the array, the most cache-efficient layout in memory,
and the partitioning shape for parallel implementations.

In this example, the access pattern is simple, static, and easily
understood. More complex stencil computations
are much more prone to error from simple lexical mistakes. For example,
Figure~\ref{ref:navier-stokes-fragment} shows three lines from a
Navier-Stokes fluid simulator in which two arrays are read with
different data access patterns, across two dimensions. The interaction
is much harder to understand, with the potential for the developer to
introduce an error via simple textual mistakes, for
example writing $\texttt{(i-1,j)}$ instead of $\texttt{(i+1,j)}$.

In practice, most stencil computations have a regular shape that can
be described simply and abstractly with a small set of coarse-grained
spatial descriptions. We introduce a simple specification language of
such descriptions, abstracting over the fine-grained detail of stencil
access patterns. For the Laplace example, our
inference procedure provides the following specification to line 3:
%
\begin{minted}[linenos=false]{fortran}
!=  stencil centered(depth=1, dim=1) :: a
\end{minted}
%
This describes that \texttt{a} is accessed with a
symmetrical pattern (``centered'') to a depth of one in each
direction in its first (and only) dimension.
%The second line explains
%the temporal relationship between \texttt{b} and \texttt{a}: that
%previous time step for \texttt{b} is actually provided by \texttt{a},
%and vice versa. This is explained as a mutual dependence between
%\texttt{a} and \texttt{b}.
The inferred specification for the Navier-Stokes example is shown 
in Fig.~\ref{ref:navier-stokes-fragment}(b). The
specification requires that, over the whole fragment, \texttt{u} is
accessed with a centered pattern to depth of 1 in both dimensions
(this is known as the \emph{five-point stencil}) and \texttt{v}
is accessed in a neighbourhood bounded by forward to depth of $1$ in
the first dimension and backward to a depth of $1$ in the second
dimension. Fig.~\ref{ref:navier-stokes-fragment}(c) illustrates
the specification pictorially.

In this paper, we make the following contributions:
%
\begin{itemize}[leftmargin=0.8em]
\item we introduce a specification language for stencils 
  that captures many common forms of data access pattern
  (Section~\ref{sec:lang}); 

\item we detail inference, checking, and specification synthesis 
algorithms for our language (Section~\ref{sec:analysis}), derived from
a denotational model for the language (Section~\ref{sec:semantics});

\item we provide an implementation of our approach as an extension to
  CamFort, an open-source program analysis tool for Fortran;
  
\item we report on a quantitative study of
  stencil computations on a corpus of numerical Fortran programs
  (ranging from small to large),  totalling one million lines of code. Our tool identifies and
  synthesises specifications for 35,000 stencil computations in the
  corpus. Approximately 10\% of the stencils we found are non-trivial,
  corresponding to code which is a possible source of errors;

\item we give a detailed verification case study of two
  particular stencil computation, simulating programming errors.
  Our approach is able to detect the vast majority of possible
  indexing errors.
\end{itemize}
%

\begin{figure}[t]
\begin{minted}[firstnumber=20,xleftmargin=2em]{fortran}
du2dx = ((u(i,j)+u(i+1,j))*(u(i,j)+u(i+1,j))+   &
  gamma*abs(u(i,j)+u(i+1,j))*(u(i,j)-u(i+1,j))- &
  (u(i-1,j)+u(i,j))*(u(i-1,j)+u(i,j))-          &
  gamma*abs(u(i-1,j)+u(i,j))*(u(i-1,j)-u(i,j))) &
  /(4.0*delx)

duvdy = ((v(i,j)+v(i+1,j))*(u(i,j)+u(i,j+1))+   &
  gamma*abs(v(i,j)+v(i+1,j))*(u(i,j)-u(i,j+1))- &
  (v(i,j-1)+v(i+1,j-1))*(u(i,j-1)+u(i,j))-      &
  gamma*abs(v(i,j-1)+v(i+1,j-1))*(u(i,j-1)-     & 
  u(i,j))) / (4.0*dely)

laplu = (u(i+1,j)-2.0*u(i,j)+u(i-1,j))/delx/delx+ &
  (u(i,j+1)-2.0*u(i,j)+u(i,j-1))/dely/dely
\end{minted}
(a) Excerpt of a Navier-Stokes fluid simulator
(based on~\citet{griebel1997numerical}) showing highly-detailed stencil computation.
\vspace{0.5em}
\hrule
%
\begin{minted}[linenos=false,xleftmargin=1em]{fortran}
!= stencil centered(depth=1,dim=1)*reflexive(dim=2) + centered(depth=1,dim=2)*reflexive(dim=1) :: u

!= stencil forward(depth=1,dim=1) * backward(depth=1,dim=2) :: v
\end{minted}
(b) Inferred and synthesised specification for (a) by CamFort.
\vspace{0.5em}
\hrule
%
\begin{center}
\begin{tikzpicture}[scale=0.85]
\node at (1.25,1.22) {i, j};
\draw (1,1) rectangle (1.5,1.5);
\draw (1.5,1) rectangle (2,1.5);
\draw (1,0.5) rectangle (1.5,1);
\draw (0.5,1) rectangle (1,1.5);
\draw (1,1.5) rectangle (1.5,2);
%
\node at (4.25,1.22) {i, j};
\draw (4,1) rectangle (4.5,1.5);
\draw (4.5,1) rectangle (5,1.5);
\draw (4.5,1.5) rectangle (5,2);
\draw (4,1.5) rectangle (4.5,2);
\end{tikzpicture}
\end{center}
\vspace{-0.5em}
(c) Pictorial representation of the two stencil specifications.
The horizontal dimension is \texttt{dim=1} and the vertical is \texttt{dim=2}.
\caption{Fragment of a Navier-Stokes fluid simulator and its
  specification in our language.}
\label{ref:navier-stokes-fragment}
\vspace{-0.8em}
\end{figure}

%This paper considers the technical aspects of the language,
%its semantics, inference, checking, and synthesis procedures.
%We also evaluate our implementation on real scientific code 
%used actively in research, ranging from small ($\sim$700loc) to large
%($\sim$600kloc). 
 %Our case studies include the Unified Weather 
%model used by the UK Met Office~\cite{um-website} ($\approx{}600\textit{kloc}$) and other
%research-based numerical models, ranging from small to large. 

\section{Stencil specification language}
\label{sec:lang}

Our specification language is based on the hypothesis
that most forms of array access in numerical code have
a fixed, statically-determined access pattern. For example, the
\emph{five-point stencil} on a two-dimensional array reads from array
indices $(i, j)$, $(i-1, j)$, $(i+1, j)$, $(i, j-1)$, and $(i, j+1)$
for all $i, j$ within the inner boundary of the array (to avoid
out-of-bounds access at the edges). We revisit this hypothesis
in Section~\ref{sec:evaluation} with the inference of
such regular stencil patterns on our corpus of numerical programs. 

Section~\ref{sec:syntax} outlines the syntax.
 Section~\ref{sec:eqs} provides an equational
theory for specifications and a notion of
sub-specification.  Section~\ref{sec:semantics}
gives a semantic model via a set-based interpretation, for which the
equality and sub-specification relation are proven sound.

\paragraph{Notation and convention}
%\label{sec:notation}

\renewcommand*{\arraystretch}{0.8}
For the target language, $e$ ranges over expressions (may be impure) and $v$
over its (imperative) variables. %By
%``variable'', we mean in the imperative sense (named binders to memory cells).

\begin{definition}[Base induction variable]
  A integer variable \textit{v} is a \emph{base induction
    variable} if it is the control variable of a ``for''
  loop,\footnote{Or equivalent, \eg{}, \texttt{do} in Fortran, for our implementation.} incremented by $1$ per
iteration. The variable is marked as an induction variable
only within the body of the loop. Since we ignore non-base
(derived) induction variables, we simply say \emph{induction
  variable}. Induction variables are ranged over by $i$, $j$, $k$ throughout. 
\end{definition}

\begin{definition}[Array subscript and index]
  An \emph{array subscript} is an expression that indexes an array, which we denote
  by $v(\bar{e})$ for the source language where $\bar{e}$ is shorthand
  for a syntactic list of indexing expressions. A \emph{relative
    index} is a list $\bar{e}$ where each $e \in \bar{e}$ is defined
  in terms of base induction variables.
\end{definition}

\begin{definition}[Neighbourhood index]
  For an array subscript $v(\bar{e})$, we say that $e \in \bar{e}$
  is a \emph{neighbourhood index} if it is of the form
  $e \equiv i$, $e \equiv i + a$ or $e \equiv i - a$ where $a$ is an
  integer constant. That is, a neighbourhood index is a
  relative index defined as constant translations of base induction
  variables. (The relation $\equiv$ here identifies terms up-to commutativity
  of $+$ and the inverse relation of $+$ and $-$ \eg{},
  $(-b) + i \equiv i - b$).  We classify neighbourhood indices 
  by the predicate $\neigh_I$ where $I$ is a set of induction
  variables. We omit $I$ when clear from the context.
\label{def:neighbour}
\end{definition}

\subsection{Specification syntax}
\label{sec:syntax}

Figure~\ref{fig:syntax} gives the syntax of stencil specifications,
which we introduce in stages below.  The top-level is given by the
\nonterm{specification} production which splits into either a
\nonterm{regionDec} (region declaration) or a \nonterm{specDec}
(specification declaration). Specification declarations associate
(via the operator $\texttt{::}$) a specification to one or more program variables
$\bar{v}$, describing how the array variables $\bar{v}$ are accessed.
%Specification declarations are either \nonterm{spatial} or
%\nonterm{temporal} specifications and describe, for spatial
%specifications,
%Specifications declarations describe
%how an array variable $v$ is read
%, and for temporal
%specifications what variables are used to define the array variable $v$.
%%

%\subsubsection{Spatial specification syntax}

\emph{Regions} are the central building blocks of spatial
specifications. Regions can either be declared alone with a
\nonterm{regionDec}, assigning a region specification \nonterm{region} to
a region variable \nonterm{rvar} or given directly within a
\nonterm{spatial} specification.

\paragraph{Region constants}

Regions have as terminals the \emph{region constants}, denoted by
\term{reflexive}, \term{forward}, \term{backward}, or \term{centered}. Each
region constant except \term{reflexive} is given a depth parameter $n$ (natural
number greater than 0). Every region constant receives a dimension identifier $d$ (also a
natural number greater than 0). Region constants specify that an array is read
from by a collection of indices which in the $d^{th}$ dimension are
neighbourhood indices ranging from $i + 0$ up to $i \pm n$ inclusively,
\eg{}, the following is a valid stencil, reading from \term{a} and writing to
\term{b}:
%%
\begin{minted}{fortran}
!= stencil forward(depth=2, dim=1) :: a
b(i, 0) = a(i, 0) + a(i+1, 0) + a(i+2, 0)
\end{minted}
%%
where \texttt{i} is an induction variable.  The specification
is associated to the array variable \texttt{a}. Note that the second
dimension is constant.

The \term{forward},
\term{backward}, and \term{centered} regions can all receive an
additional optional attribute \term{irreflexive} which marks
that the region does not include the origin (offset 0).
For example, the following is a \term{backward} stencil, which is similar
to \term{forward} but has negative neighbourhood indices, and which
is irreflexive:
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, irreflexive) :: a
b(i) = a(i-1) + a(i-2)
\end{minted}
%
The \term{irreflexive} attribute cannot be used on \term{reflexive}
regions.

A \texttt{centered} stencil is a combination of \texttt{forward}
and \texttt{backward} stencils to the same depth, \eg{},
%%
\begin{minted}{fortran}
!= stencil centered(depth=1, dim=1) :: a
b(i) = ( a(i) + a(i-1) + a(i+1) ) / 3.0
\end{minted}

\begin{figure}[t]
\vspace{-0.5em}
\begin{align*}
\def\arraystretch{1.2}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{\mathbb{N}_{>0}}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec} \;
                        \texttt{::} \; v \\
\nonterm{regionDec} ::= &  \texttt{region} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\[0.4em]
%\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}
%\\[1em]
\nonterm{spec} ::= & [\nonterm{approx},] \; [\nonterm{mult},] \; \nonterm{region} \\
\nonterm{mult} ::= & \term{readOnce} \\
\nonterm{approx} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \nonterm{rvar} \; \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \stenRefl{\dimTy}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \;\stenFwd{\mathbb{N}_{>0}}{\dimTy}{\;[, \texttt{irreflexive}]}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \stenBwd{\mathbb{N}_{>0}}{\dimTy}{\;[, \texttt{irreflexive}]}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \stenCen{\mathbb{N}_{>0}}{\dimTy}{\;[, \texttt{irreflexive}]}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{region} \; \term{+}
  \; \nonterm{region} \; \mid \; \nonterm{region} \; \term{*} \; \nonterm{region}} \\[0.5em]
%\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{rvar}}  
%\\[0.5em]
%\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \}) [, \texttt{mutual}]
%  \\[0.5em]
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+\\[-0.5em]
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\vspace{-0.8em}
\end{figure}

\paragraph{Sum and product of regions}
%%
Region terms can be combined using the sum operator
\term{+} or the product operator \term{*}.

The product of two regions $r \texttt{*} r'$ specifies that an array
is read with neighbourhood indices drawn from the bounding box created
by the regions two regions $r$ and $r'$. For example, the following
code (defining a \emph{nine-point stencil}) has a specification given by the
product of two \texttt{centered} regions in each dimension:
%%
\begin{minted}[breakindent=2.9em]{fortran}
x = a(i, j)   + a(i-1, j)   + a(i+1, j)
y = a(i, j-1) + a(i-1, j-1) + a(i+1, j-1)
z = a(i, j+1) + a(i-1, j+1) + a(i+1, j+1)
!= stencil centered(depth=1, dim=1) * centered(depth=1, dim=2) :: a
b(i, j) = (x + y + z) / 9.0
\end{minted}
%%
This pattern is common in image convolution applicaitons (for example
for edge detection). The specification ranges over the
values that flow to the array subscript on the left-hand side,
and so ranges over the intermediate assignments to \term{x},
\term{y}, and \term{z}.

The region constructor \texttt{*} can also be interpreted as a
kind of conjunction on specifications since they constrain
indices to be within both regions simultaneously.

The sum of two regions $r \texttt{+} r'$ specifies that an array is
read using the neighbourhood indices described by either $r$ or
$r'$; it acts as a disjunction on specifications. For
example, the following gives the specification of a five-point
stencil which is the sum of two compound \texttt{reflexive} and
\texttt{centered} regions in each dimension:
%%
\begin{minted}{fortran}
!= stencil centered(depth=1, dim=1)*reflexive(dim=2) + centered(depth=1, dim=2)*reflexive(dim=1) :: a
b(i,j) = -4*a(i,j) + a(i-1,j) + a(i+1,j) &
                   + a(i,j-1) + a(i,j+1)
\end{minted}
%%
Here the left-hand side of \texttt{+} says that when the second dimension
(induction variable $j$) is fixed at the origin, the first dimension
(induction variable $i$) accesses the immediate vicinity of the origin
(to depth of one). The right hand side of \texttt{+} is similar but the dimensions are reversed.
This reflects the symmetry under rotation of the five-point stencil.

As another example, the following
implements and specifies the \emph{Roberts cross}
edge-detection convolution~\cite{davis1975survey}:
%%
\begin{minted}[breakindent=5.5em]{fortran}
do j=0, jmax-1
  do i=0, imax-1
    x = a(i,j)-a(i+1,j+1); y = a(i+1,j)-a(i,j+1)
    != stencil forward(depth=1,dim=1) * forward(depth=1,dim=2) :: a
    b(i,j) = sqrt(x*x+y*y)
  end do
end do
\end{minted}

\paragraph{Region declarations and variables}

Region specifications can be assigned to region variables via
a region declaration, which can be used later to form a spatial
specification. For example, the specification from the previous
 example can be restated as:
%%
\begin{minted}{fortran}
!= region r1 = forward(depth=1, dim=1)
!= region r2 = forward(depth=1, dim=2)
!= region robertsCross = r1*r2
!= stencil robertsCross :: a
\end{minted}
This is especially useful for common stencil patterns, such as Roberts cross,
as the region can be defined once and reused.
%%
\paragraph{Modifiers}
%%
Region specifications can be modified 
by \emph{approximation} and \emph{multiplicity} information 
(in the \textit{spec} rule of Fig.~\ref{fig:syntax}). 

The \texttt{readOnce} modifier enforces that no index appears more
than once (that is, its multiplicity is one). For example, in all of
the previous examples the \texttt{readOnce} modifier could be added,
\eg{}
%
\begin{minted}{fortran}
!= stencil readOnce, backward(depth=2, dim=1) :: a
b(i+1) = a(i) + a(i-1) + a(i-2)
\end{minted}
%
This specification would be invalid if any of the
array subscripts were repeated. This modifier provides a way to
rule out any accidental repetition of array subscripts.
The notion is similar to that of \emph{linearity} in linear type
systems~\cite{wadler1990linear}, where a value must be used
exactly once. We opt for the more informative and easily understood name
\texttt{readOnce}. This modifier is optional, so it need not
be present even if the stencil is linear.

%At the region level, \texttt{irreflexive} modifier qualifies base
%regions of \texttt{forward}, \texttt{backward}, and \texttt{centered}.
%It indicates that in the dimension of the region there is no neighbour index
%with $0$ offset, \eg{},
%
%\begin{minted}{fortran}
%!= stencil centered(depth=1, dim=1, irreflexive) :: a
%b(i) = a(i+1) + a(i-1)
%\end{minted}
%
%or with just a \texttt{forward} region an example would be:
%%
%\begin{minted}{fortran}
%!= stencil forward(depth=1, dim=1, irreflexive) :: a
%b(i) = a(i+1)
%\end{minted}

%\paragraph{Under and over-approximation}

In some cases, it is useful to give a lower and/or upper bound for a
stencil. This can be done using either the \term{atMost} or
\term{atLeast} modifiers. This is particularly useful in situations
where there is a non-contiguous stencil pattern, which cannot be expressed
precisely in our specification syntax. For example:
%%
\begin{minted}{fortran}
!= stencil atLeast, reflexive(dim=1)       :: a
!= stencil atMost, forward(depth=2, dim=1) :: a
b(i) = a(i) + a(i+2)
\end{minted}
%%
%\subsubsection{Temporal specifications}

\paragraph{Note on the design}

The names ``forward'', ``backward'' and ``centered''
are inspired by standard terminology in numerical analysis
for the shape of discretisation schemes. For example,
the standard \emph{explicit method} for approximating
PDEs is known as the \emph{Forward Time, Centered Space} (FTCS)
scheme~\cite{dawson1991finite}. For
the one-dimensional heat equation, an FTCS discretisation
provides code with the following stencil~\cite{recktenwald2004finite}:
%%
\begin{minted}{fortran}
do i=2, n-1
  u(i) = r*v(i-1) + r2*v(i) + r*v(i+1)
end do
\end{minted}
%%
where \texttt{r} and \texttt{r2} are constants.
A valid specification for this is:
%%
\begin{minted}{fortran}
!= stencil centered(depth=1, dim=1) :: v
\end{minted}
%%
Such a specification can be inferred, or can be inserted by a user
and checked against the code.

\subsection{Equational theory and sub-specifications}
\label{sec:eqs}

\begin{figure}
%\vspace{-0.2em}
\begin{align*}
\setlength{\arraycolsep}{0.05em}
\begin{array}{c}
%\framebox{$\textit{region} \equiv \textit{region}'$} \\[0.6em]
\begin{array}{rll}
(\textsc{F\, \texttt{+} \,F}) \;\; &
\stenFwdSR{n \, \textsf{max} \, m}{d}{r \vee s} \\
 \equiv \; & \stenFwdSR{n}{d}{r} \; \texttt{+} \; \stenFwdSR{m}{d}{s} \\[0.6em]
%
%
(\textsc{B\, \texttt{+} \,B}) \;\; &
\stenBwdSR{n \, \textsf{max} \, m}{d}{r \vee s} \\
 \equiv \; & \stenBwdSR{n}{d}{r} \; \texttt{+} \; \stenBwdSR{m}{d}{s} \\[0.6em]
%
%
(\textsc{C\, \texttt{+} \,C}) \;\; &
\stenCenSR{n \, \textsf{max} \, m}{d}{r \vee s} \\
\equiv \; & \stenCenSR{n}{d}{r} \; \texttt{+} \; \stenCenSR{m}{d}{s} \\[0.6em]
%
%
(\textsc{C\, \texttt{+} \,F}) \;\; & \stenCenSR{n}{d}{r \vee s} \\
\textit{$m \leq n$} \; \equiv \; & \stenCenSR{n}{d}{r} \; \texttt{+} \;
                      \stenFwdSR{m}{d}{s} \\[0.6em]
%
%
(\textsc{C\, \texttt{+} \,B}) \;\; &
\stenCenSR{n}{d}{r \vee s} \\
\textit{$m \leq n$} \; \equiv \; & \stenCenSR{n}{d}{r} \; \texttt{+} \;
                      \stenBwdSR{m}{d}{s} \\[0.6em]
%
%
(\textsc{B\, \texttt{+} \,F}) \;\; &
\stenCenSR{n}{d}{r \vee s} \\
\equiv \; & \stenFwdSR{n}{d}{r} \; \texttt{+} \; \stenBwdSR{n}{d}{s}
  \\[0.6em]
%
%
(\textsc{R\, \texttt{+} \,F}) \;\; &
\stenFwdS{n}{d} \\
\equiv \; & \stenReflSR{d} \; \texttt{+} \; \stenFwdSR{n}{d}{r} \\[0.6em]
%
%
(\textsc{R\, \texttt{+} \,B}) \;\; &
\stenBwdS{n}{d} \\
\equiv \; & \stenReflSR{d} \; \texttt{+} \; \stenBwdSR{n}{d}{r} \\[0.6em]
%
%
(\textsc{R\, \texttt{+} \,C}) \;\; &
\stenCenS{n}{d} \\
\equiv \; & \stenReflSR{d} \; \texttt{+} \; \stenCenSR{n}{d}{r} \\[0.6em]
%
%
(\textsc{irrefl}) \;\; & (R \, \term{*} \, S^\irreflS) \, \term{+} \,
                         (R^\irreflS \, \term{*} \, S) \;
\equiv \; R \, \term{*} \, S \\[0.4em]
%
%
(\texttt{+}\textsc{idem}) \;\; & S \; \texttt{+} \; S \; \equiv \; S \\[0.4em]
%
(\texttt{+}\textsc{comm}) \;\; & S \; \texttt{+} \; T \; \equiv \; T \;
                       \texttt{+} \; S \\[0.4em]
%
(\texttt{+}\textsc{assoc}) \;\; & R \; \texttt{+} \; (S \; \texttt{+} \; T) \; \equiv \; (R \;
                       \texttt{+} \; S) \; \texttt{+} \; T \\[0.4em]
(\texttt{*}\textsc{comm}) \;\; & S \; \texttt{*} \; T \; \equiv \; T \;
                       \texttt{*} \; S \\[0.4em]
%
(\texttt{*}\textsc{assoc}) \;\; & R \; \texttt{*} \; (S \; \texttt{*} \; T) \; \equiv \; (R \;
                       \texttt{*} \; S) \; \texttt{*} \; T \\[0.4em]
(\textsc{dist}) \;\; & R \; \texttt{*} \; (S \; \texttt{+} \; T) \; \equiv \; (R \;
                       \texttt{*} \; S) \; \texttt{+} \; (R
                       \; \texttt{*} \; T)
\end{array}
%
%\framebox{${\textit{specDec} :: \texttt{v}} \equiv
%{\textit{specDec'} :: \texttt{v}}$} \\[0.7em]
%\begin{array}{rl}
% MUTUAL
%(\textsc{mutual}) \; &
%\texttt{stencil} \; \texttt{dependency} (\texttt{v}), \texttt{mutual}
%  :: \texttt{w}
%\\
%\equiv \; & \texttt{stencil} \; \texttt{dependency} (\texttt{w}), \texttt{mutual} ::
%  \texttt{v} \\[0.5em]
%(\textsc{coalesce}) \; &
%\texttt{stencil} \; \texttt{dependency} (\bar{v})
%  :: \texttt{v} \\
%& ; \texttt{stencil} \; \texttt{dependency} (\bar{w})
%  :: \texttt{v}
%\\
%\equiv \; & \texttt{stencil} \; \texttt{dependency} (\bar{v}, \bar{w}) ::
%  \texttt{v} \\[0.5em]
%\end{array}
\end{array}
\end{align*}
\caption{Equations on specifications (\emph{regions})}
\vspace{-0.5em}
\label{fig:equations}
\end{figure}

Figure~\ref{fig:equations} lists the equational theory for
specifications given by the binary relation $\equiv$
on \emph{region} terms. The equations use abbreviations
\term{refl}, \term{fwd}, \term{bwd}, \term{cen}, and \irreflS{}
for \term{reflexive}, \term{forward}, \term{backward},
\term{centered}, and \irrefl{} respectively. Furthermore, the abbreviations include syntactic sugar
for quantifying over the absence or presence of the \irrefl{}
attribute on region constants as a boolean. For example,
\term{fwd} syntactic sugar is defined:
%%
\begin{align*}
\hspace{-0.25em}
& \stenFwdSR{n}{d}{r}
\; := \; \\[-0.4em]
& \qquad \begin{cases}
\stenFwd{n}{d}{, \irrefl} & \;\;\textit{if} \;\, \neg \, r \\[-0.1em]
\stenFwd{n}{d}{}  & \;\;\textit{if} \;\,  r
\end{cases} \\
\textit{or} \;\;
& \stenFwdS{n}{d} := \stenFwd{n}{d}{}
\end{align*}
%
and similarly for \term{bwd} and \term{cen}.

Stencil specifications in \textit{spec} are considered
equal when they have the same modifiers and $\equiv$ equates
their regions, \ie{}:
\begin{align*}
(\textit{region} \equiv \textit{region'}) 
 \Rightarrow \quad\;\; & \texttt{stencil} \; [\textit{approx},] \; [\textit{mult},] \;
\textit{region} \\[-0.4em]
\quad \equiv \; & \texttt{stencil} \; [\textit{approx},] \;
            [\textit{mult},] \; \textit{region}'
\end{align*}
%
The equations reveal a part of the semantics for our
specification language, which we briefly unpack.

\paragraph{Overlapping regions with +}
The first nine
equations (with labels of the form $\ldots \texttt{+} \ldots$)
explain the notion of \emph{region overlapping} with sum
\term{+}. In the first six, $r$ and $s$ range
over booleans denoting the absence (true) or presence (false)
of \irrefl{}. These are combined via disjunction. For example,
the rule $(\textsc{B} \, \term{+} \,
\textsc{F})$ explains that the sum of \term{backward}
and \term{forward} regions in the same dimension and the same
depth is equivalent to a \term{centered} region of that depth.
If the \term{forward} part is irreflexive ($r =
\textit{false}$) but \term{backward} is not ($s =
\textit{true}$) then their sum is equal to a \term{centered}
region with no \irreflS{} modifier by the disjunction ($r \vee s =
\textit{true}$), \ie{}:
%%
\begin{align*}
& \stenCenS{n}{d}  \\[-0.2em]
\equiv \;\; & \stenFwdSR{n}{d}{\irreflS} \; \texttt{+} \; \stenBwdS{n}{d}
\end{align*}
%%
That is, the \term{fwd} region is irreflexive describing code which is missing
a zero-offset neighbourhood index (\eg{}, missing $\texttt{a(i)}$), but the addition of
the \term{bwd} has no irreflexive attribute and thus provides the
missing zero offset index.

The equation (\textsc{irrefl}) provides an annihilation of
\irreflS{} using a further syntactic sugar.
We write $R^{\irreflS}$ to denote a region constant with an
irreflexive attribute, \eg{},
%%
\begin{align*}
\stenFwdS{n}{d}^{\irreflS}  := \,
\stenFwdSR{n}{d}{\irreflS}
\end{align*}
%%
The left-hand side of (\textsc{irrefl}) has a sum of
products of two regions $R$ and $S$, 
where in each component of the sum one of $R$
or $S$ has the irreflexive attribute. These cancel to give
just $R \, \term{*} \, S$.


\paragraph{Interaction between \term{+} and \term{*}}

The last six equations (from (\textsc{\term{+}idem}) inclusive), explain
the algebraic behaviour of \term{+} and \term{*}.  Together, we see
that \term{+} is an associative, commutative, idempotent binary
operator that distributes with \term{*}, which is associative and
commutative. This distribution of \term{*} over \term{+} is key as it
is used internally to give a normal form for stencil specifications
akin to Disjunctive Normal Form (DNF) (where \term{+} is taken as
``disjunction'' and \term{*} as the ``conjunction''). We revisit this
normalisation in Section~\ref{sec:inf-step4}.

The equational theory provides not only an axiomatic semantics
for the language, which the user can use to rewrite their
specification, but it is also used extensively in the inference
procedure (Section~\ref{subsec:inference}) to simplify specifications.

\begin{figure}[t]
\begin{align*}
\hspace{-0.5em}
\begin{array}{c}
%%
%% INEQUATIONS ON REGION
%% 
%\framebox{$\textit{region} <: \textit{region}'$} \\[0.85em]
%
%\dfrac{}{R <:^r R}\trule{\textsc{refl}} \qquad \dfrac{P <:^r R \quad R <:^r Q}{P <:^r
%  Q}\trule{\textsc{trans}} 
%\qquad
%\\[1.5em]
\vspace{-0.4em}
\setlength{\arraycolsep}{0.1em}
\dfrac{\hspace{3em} m \leq n \qquad\qquad r \implies s \hspace{3em}}
{\begin{array}{rl}
\stenFwdSR{m}{d}{r} & <:^r \stenFwdSR{n}{d}{s}
%& \;\, ds \subseteq es \wedge n \leq m
\\
\wedge \; \stenBwdSR{m}{d}{r} & <:^r \stenBwdSR{n}{d}{s}
%& \;\, ds \subseteq es \wedge n \leq m
\\
\wedge \; \stenCenSR{m}{d}{r} & <:^r \stenCenSR{n}{d}{s}
%& \;\, ds \subseteq es \wedge n \leq m
\\
\wedge \; \stenBwdSR{m}{d}{r} & <:^r \stenCenSR{n}{d}{s} \\
\wedge \; \stenFwdSR{m}{d}{r} & <:^r \stenCenSR{n}{d}{s} \\[1.2em]
\end{array}}\trule{\textsc{over}} \\[-0.2em]
\hspace{-0.5em}
\dfrac{P_1 <:^r R_1 \quad P_2 <:^r R_2}
      {P_1 \, \texttt{+} \, P_2 <:^r R_1 \, \texttt{+} \, R_2}
\trule{\textsc{cong}\texttt{+}} \;\;\;
\dfrac{P_1 <:^r R_1 \quad P_2 <:^r R_2}
      {P_1 \, \texttt{*} \, P_2 <:^r R_1 \, \texttt{*} \, R_2}
\trule{\textsc{cong}\texttt{*}} \\[1.5em]
%%
%% INEQUATIONS ON SPEC
%%
%\framebox{$\textit{spec} <: \textit{spec}'$} \\[0.8em]
%
\dfrac{}{\term{readOnce} \, R <: R}\trule{\textsc{rep}}
\quad
\dfrac{}{\term{atLeast} \, R <: \term{atMost} \,
  R}\trule{\textsc{bound}} \\[1.5em]
%%
\dfrac{P <:^r R}{\term{atLeast}  P <: \term{atLeast} 
  R}\trule{\textsc{cong}\texttt{L}}
\ 
\dfrac{P <:^r R}{\term{atMost}  P <: \term{atMost} 
  R}\trule{\textsc{cong}\texttt{M}} \\[1.5em]
\dfrac{P <:^r R}{\term{readOnce} \, P <: \term{readOnce} \,
  R}\trule{\textsc{cong}\texttt{R}} 
\quad
\dfrac{R \equiv S}{R <:^r S}\trule{\textsc{eq}} 
%%
\end{array}
\end{align*}
\caption{Inequations $<:^r$ on \textit{regions} and
$<:$ on \textit{specs} (omitting reflexivity
and transitivity). }
\label{fig:inequations}
\vspace{-0.8em}
\end{figure}

\paragraph{Inequations: sub-specifications}

Figure~\ref{fig:inequations} defines a notion of sub-specifications
via the relation $<:^r$ on \textit{region}
syntax and then $<:$ on \textit{spec} syntax inductively.
Both relations are reflexive and transitive (we omit
these equations) and congruent
with respect to \term{+}, \term{*}, \term{atLeast}, \term{atMost},
and \term{readOnce}. The (\trule{\textsc{eq}}) rule connects region
equations with inequations. The (\trule{\textsc{over}}) rule explains
the notion of spatial over-approximation via overlapping regions.
The (\trule{\textsc{rep}}) allows the modifier that
enforces that every index is read just once to be dropped
as an approximation; (\trule{\textsc{bound}}) gives
a connection between the \term{atLeast} and \term{atMost}
approximation modifiers.

\section{Semantics of specifications; a model}
\label{sec:semantics}

\newcommand{\domainVal}{\mathbb{Z}_\infty}

We define a denotational model of the semantics of our 
stencil specification language. This model has a number of purposes: (1) it is used in the inference,
checking, and synthesis algorithms (Section~\ref{sec:analysis}); (2)
justifies the equational
theory and approximations of the previous section; and (3) can be used
to guide correct implementations. The model domain is over sets of vectors which we call \emph{index
  schemes}, which we introduce first before the model in Section~\ref{subsec:model}.

\subsection{Indexing schemes and generalisation}
\label{subsec:schemes-and-gen}

\begin{definition}
An \emph{index scheme} is a vector of size $n$ (an $n$-vector)
with values drawn from $\domainVal = \mathbb{Z} \cup \{\infty\}$.
Values in $\mathbb{Z}$ represent offsets
of a neighbourhood index (indexing
expressions of the form $i + a$ where $i$ is an induction variable
and $a$ is a constant offset, Def.\ref{def:neighbour},
p.\pageref{def:neighbour}). The additional value
$\infty$ represents any indexing behaviour--- it is a
wildcard.
Throughout $u, v, w$ range over index schemes and $u_i$ denotes
the $i^{th}$ element of $u$. We write $(\domainVal)^n$ for
the set of $n$-dimensional schemes.

Indexing schemes give an abstract
representation of index expressions in the source language.
Our model represents the meaning of stencil specifications
as indexing schemes, which explain the range of possible
indexing behaviours allowed under the specification.
The relationship between indexing schemes and source language
terms is given precisely by the partial function, \textsf{schematic}, which
maps syntactic array-index terms to indexing schemes. This
operation is used by the inference
and the checking procedures.
\end{definition}
%
\begin{definition}%[Schematic]
\label{def:schematic}
The partial function $\textsf{schematic}_I$ (parameterised by a set of
induction variables $I$) maps source indexing terms $(e_1, .., e_n)$
to $n$-dimensional index schemes, defined:
%
\begin{align*}
\mathsf{schematic}_I(e_1, ..., e_n) & =
[\mathsf{s}_I(e_1) ... \mathsf{s}_I(e_n) ]
\quad \textit{iff} \;\; \forall x . \mathsf{s}_I(e_x) \neq \bot
\end{align*}
%
where $\mathsf{s}_I$ is partial and 
maps individual indexing expressions to 
 indexing scheme components in $\domainVal{}$ defined:
%%
\begin{align*}
\mathsf{s}_I(e)
 & =  \begin{cases}
a & e \equiv i + a \; \wedge \; \neigh_I(e) \\
-a & e \equiv i - a \; \wedge \; \neigh_I(e) \\
\infty & \textit{$\mathsf{IV}(e) = \emptyset$} \\
\bot   & \textit{otherwise}
\end{cases}
\end{align*}
%%
where $\mathsf{IV}(e)$ is the set of free induction variables
in an expression, and $\neigh_I$ classifies expressions which
are constant offsets from an induction variable $i \in I$
(Defn.~\ref{def:neighbour}). In the third case,
if the expression is not a neighbourhood index but is not
a relative index either (\ie{}, not defined in terms
of an induction variable) then it is mapped to $\infty$, otherwise
$\mathsf{s}_I(e)$ is undefined (returns $\bot$). The $\mathsf{schematic}$ function
is undefined if $\mathsf{s}_I$ of any of its components $e_i$ is
undefined. We omit the parameter set of induction variables $I$ to
$\mathsf{schematic}$ when clear from the context. 
\end{definition}

\begin{definition}[Generalisation]
Given two schemes $v, w$ of dimensionality $n$,
then $w$ is said to \emph{generalise} $v$
(or conversely $v$ \emph{specialises} $w$),
written $v \preceq_n w$, iff the following holds:
%%
\[
v \preceq_n w \;\; \Leftrightarrow  \;\;
  \forall i\!\in\!\{ 1, \ldots, n \} . \, (w_i = \infty \, \vee \, v_i = w_i)
\]
%%
That is, two schemes are related by the (reflexive and transitive) binary relation
$\preceq_n$ over $(\mathbb{Z}_{\infty})^n$ if in each dimension
the two schemes are equal or $w_i = \infty$
in place of some $\mathbb{Z}$ in $v_i$ for $v \preceq_n w$.
Thus, the element $\infty$ generalises any index in the same dimension.
%
%The subscript on $\preceq_n$ is sometimes dropped when the
%intended dimensionality is clear or inconsequential.
\end{definition}


%Unification relation, $\sim$, establishes whether
%a particular relativised subscript, $u$, of a group of subscripts involved
%in a stencil computation conforms with a unifier, $v$, of the model for
%the stencil computation.

\begin{example}
The following three array indexing terms
$(i, j+1)$, $(1, j+1)$ and $(3, j)$ 
are mapped by \textsf{schematic} to the 
index schemes $\vtwoh{0}{1}$, $\vtwoh{\infty}{1}$
and $\vtwoh{\infty}{0}$ respectively. The following
relationships of generalisation then holds:
%\[
%\xymatrix@R=0.2em@C=2em{
%[\infty \;\; 0] \ar@{-}[dr]^{\preceq_n} &  \\
%& [0 \;\; 1]  \\
%[\infty \;\; 1]  \ar@{-}[ur]_{\preceq_n} &
%}
%\]
%%
$\vtwoh{\infty}{0} \; \not\preceq_2 \; \vtwoh{0}{1}$
and
$\vtwoh{\infty}{1} \; \preceq_2 \; \vtwoh{0}{1}$. 

As an example of undefined \textsf{schematic}, 
 $\textsf{schematic}(i*2, j) = \bot$ as its first index is a non-neighbour relative index, which
 is outside the scope of our specification language.
\end{example}
\noindent
Our terminology of \emph{indexing schemes} and
\emph{generalisation} is by analogy
with the \emph{type schemes} and \emph{type generalisation} of
polymorphic types in ML~\cite{milner1978theory}. Our notion is
much more rigid however, as our schemes do not bind names.
%and thus generalisation does not require substitution; $\infty$ acts
%as a positional placeholder.

From \textsf{schematic} we now give a
formal characterisation of stencil computations for our purposes:
%%
\begin{definition}[Stencil computations]
  Let $a$ be an array of dimensionality $n$ and $\overline{b}$ a
  collection of arrays of arbitrary (possible differing)
  dimensionalities.  
  A \emph{stencil computation} comprises an iteration by a set $I$ of at
  most $n$ induction variables 
  over a subset of the index space of $a$. Elements of $a$ are determined by an
  assignment $a(\bar{e}) = e_r$ where $\bar{e}$ is an array index such
  that  $\mathsf{schematic}_I(\bar{e}) \neq \bot$ and %for all $b \in  \bar{b}$ and
  for all subscripts $b(\bar{e}') \in e_r . \, $
  $\mathsf{schematic}_I(\bar{e}') \neq \bot$. 
\label{def:stencil}
\end{definition}
%%

\subsection{Denotational model}
\label{subsec:model}

The model is given by the interpretation function $\interp{-}_n$
(where $n$ is the maximum dimensionality of the specification being
modelled) mapping closed\footnote{That is, we assume there are no
  occurrences of \textit{rvar} in a specification being modelled.  Any
  \emph{open} specification containing region variables can be made
  closed by straightforward syntactic substitution with a (closed)
  \textit{region}.} specifications to sets of
$n$-dimensional indexing schemes. The interpretation is overloaded on
\emph{regions} in Figure~\ref{fig:region-model} and on the top-level
of a specification \textit{spec} in Figure~\ref{fig:spatial-model}.

We first define some intermediate notations and definitions.

\begin{definition}A \emph{single-entry vector} of size $n$, denoted
$\singleEntry{r}{n}$, is a vector where the $r^{th}$ entry is $1$
and all others are $\infty$, \eg{}, $\singleEntry{1}{2} =
\vtwoh{1}{\infty}$ and $\singleEntry{2}{3} = \vthreeh{\infty}{1}{\infty}$.
Thus, a single-entry vector is an indexing scheme which generalises
all other schemes which at least have $1$ as their $r^{th}$ entry,
describing a neighbour offset of $1$.
%DAO don't understand this sentence:
%In particular the constrained
%requires a non-zero offset from the induction variable.
\end{definition}

\begin{definition}A \emph{zero-entry vector} of size $n$, denoted
$\zeroEntry{r}{n}$, is a vector where the $r^{th}$ entry is $0$ and all others
are $\infty$, \eg{}, $\zeroEntry{1}{2} = \vtwoh{0}{\infty}$.
Similarly to the single-entry vector, zero-entry vectors
are generalise all other schemes
which at least have the $r^{th}$ entry is $0$, representing indices at
the ``origin'' in dimension $r$.
\end{definition}

\begin{figure}[t]
\vspace{-0.9em}
\input{region-model.tex}
%\textit{$a^m \in A$ means there are $n$ copies of $a$ in
%  the multi-set $A$}
\caption{Model of regions,
$\interp{-}_n : \textit{region} \rightarrow \mathcal{P}(\domainVal{}^n)$}
\label{fig:region-model}
\vspace{-1em}
\end{figure}

\noindent
The first four equations of Fig.~\ref{fig:region-model}
give the model of the region constants as sets of indexing
schemes. We illustrate with an example.

\begin{example}
For a $2$-dimensional stencil computation, then
\begin{align*}
& \interp{\stenCenS{2}{1}}_2 \\[-0.1em]
& \qquad = \; \{i\singleEntry{1}{2} \,|\, i \in \{\text{-}2,..., 2\}\!\setminus\!0 \}
  \cup  \{ \zeroEntry{1}{2} \,|\, \textit{true} \} \\[-0.2em]
& \qquad = \; \{-2\singleEntry{1}{2}, \, -\singleEntry{1}{2}, \,
  \singleEntry{1}{2}, \, 2\singleEntry{1}{2}\} \cup
  \{\zeroEntry{1}{2}\} \\[-0.2em]
& \qquad = \; \{\vtwoh{-2}{\infty}, \vtwoh{-1}{\infty}, \vtwoh{0}{\infty},
\vtwoh{1}{\infty}, \vtwoh{2}{\infty}\}
\end{align*}
Note the absorbing behaviour of $\infty$ with respect to
multiplication.
\end{example}
\noindent
The final two equations of Fig.~\ref{fig:region-model} give the
models of $\term{+}$ and $\term{*}$. For $\term{+}$ this is the 
straightforward union of the models of subterms. The model of
$\term{*}$ takes the tensor $\otimes$ of subterm models. The tensor is
non-trivial; we give some informal intuition first. 


\paragraph{$\otimes$ of models}

The intuition behind $\otimes$ is that it takes
all possible pairs of indexing schemes, treating them as the
lower and upper bounds of an $n$-dimensional rectangle from which the
remaining vertices of the rectangle are generated (like a bounding
box) \eg{}:
%%
\begin{align*}
\{\vtwohs{1}{2}, \vtwohs{5}{6}\,\} \otimes \{\vtwohs{3}{4}\} =
\{\vtwohs{1}{2}, \vtwohs{3}{2}, \vtwohs{1}{4}, \vtwohs{3}{4}, 
   \vtwohs{3}{6}, \vtwohs{5}{4}, \vtwohs{5}{6}\,\}
\end{align*}
%%
The tensor takes a Cartesian product of the two models,
giving all pairs of schemes which are combined using the
\emph{pairwise permutation} written $\bowtie$ (defined later).
Pairwise permutation generates all possible interleavings of two vectors
(\ie{}, all possible non-deterministic choices between $u_i$ and
$v_i$ in each dimension). Some care is then taken over
how this interacts with $\infty$: pairwise permutation
corresponds to non-deterministic choice, in each dimension $i$,
between two values $u_i$ and $v_i$, but if either
is $\infty$ then the resulting pairwise permutation is
filtered out if the dimension $i$ has \emph{any other scheme
in the model where $u_i \neq \infty$}, \eg{}:
\begin{align*}
\{\vtwoh{1}{\infty}\} \otimes \{\vtwoh{3}{4}\} =
\{\vtwoh{1}{4}, \vtwoh{3}{4}\}
\end{align*}
%
where $\vtwoh{1}{\infty}$ and $\vtwoh{3}{\infty}$ have been filtered.
%With respect to the notion of unification, the
%
%
% combines non-$\infty$ constraints
%of the unifiers in different dimensions into less accepting unifiers.
%This means an access pattern generalises with this scheme would require
%both models to be satisfied. Use of $dims$ gives the dimensions that
%constituent models talk about and is used in the product to eliminate
%general unifier appearing in these dimensions. Allowing general unifier
%in these dimensions would prevent both models to be satisfied
%simultaneously.
%  u in M * N   u < w
% implies that
%  u_1 in M  u1 < w
%  u_2 in M  u2 < w
%
The notion of which dimensions $i$ have that \emph{any scheme in the model
has $u_i \neq \infty$} is represented by the \emph{constrained
dimensions} intermediate function:
%
\begin{definition}%[Constrained dimensions]
For an $n$-dimensional model $M$, its \emph{constrained dimensions}
is the set of dimension identifiers for which at least one scheme $u \in M$ has
a non-$\infty$ value in that dimension. That is:
%
\begin{align*}
\effdims{M}{n} =
\bigcup_{u \in M} \{i \mid i \in \{1,\ldots,n\} \, \wedge \, u_i \neq
  \infty\}
\end{align*}
For example, $\effdims{\{\vtwoh{0}{\infty},\vtwoh{\infty}{\infty}\}}{2}
 = \{1\}$.
\end{definition}

\begin{definition}The tensor $\otimes_n$ of $n$-dimensional
models is defined:
\begin{alignat*}{2}
& M \otimes_n N =
  \Bigg\{x \; \Bigg| \;
    \parbox{5.2cm}{$(u, v) \in M \times N $ \\[0.1em]
                 $\;\; \wedge \;\, j \in (\effdims{M}{n} \cup
                   \effdims{N}{n})$\\[0.1em]
                  $\;\; \wedge \;\, i \in \{1, \ldots, 2^n\} \, \wedge
                  \, x = (u \bowtie v)_i$ \\[0.1em]
                   $\;\; \wedge \;\, x_j \neq \infty$
                  } \Bigg\}
\end{alignat*}
The first guard takes the Cartesian product of
the models and quantifies over all pairings $(u, v)$.
The second guard binds $j$ which ranges over the constrained
dimensions for $M$ union with the constrained dimensions for $N$.
That is, every $j$ corresponds to a dimension in which
either $M$ or $N$ has a scheme $u$ where $u_j \neq \infty$,
and thus is constrained.

The \emph{pairwise permutation} $u \bowtie v$ 
builds a $2^n \times n$ matrix 
of all possible $n$-vectors generated by
non-deterministically picking for each $j^{th}$ entry either 
$u_j$ or $v_j$ \eg{}
%
\begin{equation*}
\vthreeh{0}{1}{2} \bowtie \vthreeh{3}{4}{5} =
\left[
\setlength{\arraycolsep}{0.42em}
\begin{array}{cccccccc}
0 & 0 & 0 & 0 & 3 & 3 & 3 & 3 \\
1 & 1 & 4 & 4 & 1 & 1 & 4 & 4 \\
2 & 5 & 2 & 5 & 2 & 5 & 2 & 5
\end{array}
\right]
% \\
%\setlength{\arraycolsep}{0.5em}
%\left[\begin{array}{ccc}
%0 & 1 & 2 \\
%0 & 1 & 5 \\
%0 & 4 & 2 \\
%0 & 4 & 5 \\
%3 & 1 & 2 \\
%3 & 1 & 5 \\
%3 & 4 & 2 \\
%3 & 4 & 5
%\end{array}
%\right]
\end{equation*}
%
The $2^n$ unique choices for $\bowtie$ on $n$-vectors
corresponds to taking all bit-strings of length $n$ and
selecting from $u$ for $1$ and $v$ for $0$. The pairwise permutation
matrix is thus defined in terms of the logical
matrix $b$ where $b_{i,j}$ is the $j$-th bit of the integer
$i - 1$ as:
%
\begin{align*}
(u \bowtie v)_{i,j} & = b_{i,j} u_j + \neg b_{i,j} v_j
\end{align*}
%
The permuted schemes $x = (u \bowtie v)_i$ added to the model 
$M \otimes N$ are only those which have do not have $\infty$ in 
the constrained dimensions given by each model ($x_j \neq
\infty$). This filters out all permutations which have
$\infty$ in a constrained dimension position. 
\end{definition}

%The main interpretation function is overloaded on lists of
%variable-spec pairs $\interp{\overline{v : S}}$,
%returning multisets of variable-relative-index pairs. This provides
%the top-level definition of the model, with $\interp{-}$ overloaded
%on $S$, $\interp{S}$ mapping to multisets of
%relative indices not associated to an array variable.


\paragraph{Model of \textit{spec}}

We have explained the model of regions as sets of index
schemes, that is
$\interp{\textit{region}}_n \in \mathcal{P}(\domainVal{}^n)$.
Figure~\ref{fig:spatial-model} defines the top-level model of the
\textit{spec} syntax, which includes the multiplicity and
approximation modifiers. The domain of this interpretation
is $\textsf{Mult}(\textsf{Approx}(\mathcal{P}(\domainVal{}^n)))$
where $\textsf{Mult}$ and $\textsf{Approx}$ are labelled variants
labelling our set-based model with additional information.

\begin{definition} \textsf{Mult}
and \textsf{Approx} are parametric labelled variant types
with injection function given by their definition:
%
\begin{align*}
\textsf{Mult} \, a & = \textsf{mult} \, a \,\mid\, \textsf{only} \, a \\
\textsf{Approx} \, a & = \textsf{exact} \, a \,\mid\, \textsf{lower} \, a \,\mid\,
\textsf{upper} \, a \,\mid\, \textsf{both} \, a \, a
\end{align*}
\ie{}, $\mathsf{lower}$ is an injection $\mathsf{lower} : a \rightarrow \mathsf{Approx} \, a$, and so
on. The $\textsf{Mult}$ type corresponds to the presence or absence of the
\term{readOnce} modifier as shown in Figure~\ref{fig:spatial-model}. 
The $\textsf{Approx}$ type corresponds to the presence or absence of
the spatial approximation modifier, with \textsf{exact} when there is
no such modifier and \textsf{lower} and \textsf{upper} for
\term{atLeast} and \term{atMost}. Later, it will be useful to model
pairs of lower and upper bounds which is provided by \textsf{both} 
(but which isn't used here). These are used for labelled models, and other components later in
Section~\ref{sec:analysis}.% with additional information.
\label{def:mult-and-approx}
\end{definition}
\vspace{-0.5em}

\begin{figure}
\input{spatial-model.tex}
\caption{\textit{spec} model,
$\interp{-}_n : \textit{spec} \rightarrow \textsf{Mult}(\textsf{Approx}(\mathcal{P}(\domainVal{}^n)))$}
\label{fig:spatial-model}
\vspace{-0.75em}
\end{figure}

\subsection{Soundness}
%
Given the above model, we can
consider soundness for the equational theory of
specifications and the notion of spatial approximation. The proofs are given in our supplement.

\begin{theorem}[Soundness of equational theory (Figure~\ref{fig:equations})]
\[
S \equiv T \; \Rightarrow \;
\interp{S}_n = \interp{T}_n
\]
\end{theorem}

\begin{theorem}[Soundness of inequations
  (Figure~\ref{fig:inequations})] 

Let $\leq$ be an ordering on
$\textsf{Mult}(\textsf{Approx}(\mathcal{P}(\domainVal{}^n)))$
and $\leq'$ be an ordering on
$\textsf{Approx}(\mathcal{P}(\domainVal{}^n))$ defined by the
following clauses:
\begin{align*}
\def\arraystretch{1.2}
\begin{array}{c}
\begin{array}{cc}
(M \leq' N \Rightarrow \textit{inj} \, M \leq \textit{inj} \, N) &
(\textsf{once} \, M \leq' \textsf{mult} \, M) \\
%%
%%
(M \subseteq N \Rightarrow \textit{inj}' M \leq' \textit{inj}' N)
& (\textsf{exact} M \leq  \textsf{lower} M)
\end{array} \\ 
(\textsf{lower} M \leq  \textsf{upper} M)
\end{array}
\end{align*}
%%
where $\textit{inj}$ ranges over the unary injections
of $\textsf{Approx}$ and $\textit{inj}'$ ranges over the injections of
$\textsf{Mult}$. Then, soundness of $<:$ is that:
%%
\[
S <: T
\; \Rightarrow \;
\interp{S}_n \leq \interp{T}_n
\]
\end{theorem}

\section{Inference, checking, and synthesis}
\label{sec:analysis}

\noindent
We briefly sketch the algorithms for inferring and synthesising
specifications (Section~\ref{subsec:inference}), for checking code
against specifications (Section~\ref{subsec:checking}). These utilise the semantic model of
Section~\ref{sec:semantics}.

\paragraph{Syntax helper functions}
The function \rhsExp{} maps source statements to a
set of expressions which occur in right-hand positions (\ie{}, not the
target of an assignment). The function \var{} maps expressions to a
set of the variables used in right-hand positions.

\subsection{Inference and specification synthesis\label{subsec:inference}}

We demonstrate the inference procedure over the
following example program which computes the mean value
of a five-point stencil:%at each index of the input array:
%%
\begin{minted}{fortran}
do i = 1, (n-1)
  do j = 1, (m-1)
    x = a(i-1, j)+a(i+1, j); y = a(i, j-1)+a(i, j+1)
    b(i, j) = (a(i, j) + x + y) / 5.0
  end do
end do
\end{minted}
%%
\subsubsection{Step 1: Analyse standard control and data-flow}
\label{sec:inf-step1}

The inference relies on some standard program analyses, computed
before the main inference procedure:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathsf{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable, where we use the predicate
\arrayTy{} to classify variables of array type.
%

\subsubsection{Step 2: Analyse data-access}
\label{sec:inf-step2}

For each assignment statement whose left-hand side is an array
subscript on neighbourhood indices, a finite map is computed which
maps array variables to a set of vectors representing array
subscripts.  This finite map contains all array subscript expressions
which flow to this statement. More formally, a function
$\textit{analyse}$ is applied to each statement in a program with the
following clause:
%
\begin{align*}
\hspace{-0.5em}
\begin{array}{lr}
\textit{analyse}(v(\overline{e_1}) = e_2)
 := \qquad\qquad & \textit{where} \; \neigh(\overline{e_1}) \wedge \arrayTy(v)  \\[0.3em]
\multicolumn{2}{l}{\qquad \bigcup\{v' \mapsto \{
\textsf{schematic}(\bar{e})\} \mid v'(\bar{e}) \leftarrow \mathsf{flowsTo}(e_2),
  \arrayTy(v')\}}
\end{array}
\end{align*}
%
That is, we focus on assignments to an array subscript where the LHS 
indexing expression $\overline{e_1}$ is a neighbourhood index.  For
all array subscripts that flow to the right-hand side of this
statement, a finite map is constructed, mapping each array variable
to a set of indexing schemes for its subscripts, computed
with \textsf{schematic} (Defn.~\ref{def:schematic},
p.~\pageref{def:schematic}).
 Note that \textsf{schematic} is undefined if
$\bar{e}$ contains relative indices which are not neighbourhood
indices (\ie{}, these are not stencil computations we can handle). 

For our example, the \textit{analyse} function matches on
line 5, with the following set for $\textsf{flowsTo}(\texttt{a(i, j) + x +
  y})$:
%
\begin{align*}
\{\texttt{a(i-1, j)}, \texttt{a(i+1, j)}, \texttt{a(i, j-1)},
  \texttt{a(i, j+1)}, \texttt{a(i, j)}\}
\end{align*}
Subsequently the result of \textit{analyse} on line 5 yields the map:
\begin{align*}
\texttt{a} \mapsto \{\vtwoh{-1}{0}, \vtwoh{1}{0},
          \vtwoh{0}{-1}, \vtwoh{0}{1}, \vtwoh{0}{0}\}
\end{align*}
%
If the LHS $\overline{e_1}$ contains non-$0$ neighbour offsets 
then all RHS schemes are \emph{relativised} by
$\textsf{schematic}(\overline{e_1})$. For example, 
if \texttt{a(i+1) = b(i)} then relativisation of the RHS by the LHS
produces an analysis which is equivalent to the analysis of \texttt{a(i) = b(i-1)}. 

\subsubsection{Step 3: Coalesce contiguous schemes into spans}
\label{sec:inf-step3}

Let $U$ range over the finite maps computed by \textit{analyse}.  For
each $x \in \mathsf{dom}(U)$, the algorithm 
constructs next a set of $n$-dimensional rectangles covering all contiguous groups of schemes
in $U(x)$. 

\newcommand{\spanOp}{\textsf{spans}}

\begin{definition}[Spans]
  A \emph{span} represents an $n$-dimensional box
  (\emph{hyper-rectangle}) as a pair of $n$-dimensional vectors (or
  represented as a $2 \times n$ matrix) with values drawn from
  $\domainVal{}$. This gives the co-ordinates of a lower-bound vertex
  (first component) and the upper-bound (second component). We write 
  spans as $\vect{x} = [\vect{x}^L \; \vect{x}^U]$, where $\vect{x}^L$
  and $\vect{x}^U$ give the lower and upper bounds.  In
  the following, $\vect{x}, \vect{y}$ range over spans.  For a span
  $\vect{x}$, we write $\vect{x}_{i:j}$ for the sub-span comprises the
  subvectors $[\vect{x}^L_{i:j} \; \vect{x}^U_{i:j}]$ from entry $i$
  to entry $j$ (inclusive).
\end{definition}

\noindent
Each indexing scheme in $U(x)$ is converted to a \emph{unit} span $u \mapsto [u \; 
u]$, defining the lower and upper bound.
 For the five-point stencil example there are five $1 \times 1$ spans.
Figure~\ref{fig:inference-steps-informal}(a) illustrates these.

% taking permutations is a systematic way of producing all rotations
% of the n-dimensional space - forward ref to fold
The next step repeatedly coalesces any contiguous spans
until a fixed point is reached, resulting in a set of (possibly
overlapping) spans covering the original space of schemes. Two $n$-dimensional spans $\vect{x}$ and $\vect{y}$
are contiguous if for all but one $j \in \{1, \ldots, n\}$ then
$\vect{x}_j = \vect{y}_j$ and for one $j$ then $\vect{x}^U_1 + 1 =
\vect{y}^U$. For example, spans
$\left[\vtwoh{-1}{0}\; \vtwoh{-1}{0}\right]$ and $[\vtwoh{0}{0} \; \vtwoh{1}{0}]$ 
are contiguous in the first dimension and can be coalesced
into the span $[\vtwoh{-1}{0} \; \vtwoh{1}{0}]$.

\begin{definition}\label{def:span-coalesc} Span
  coalescing $\bullet$ is defined for spans contiguous in the first dimension:
%%
\begin{align*}
\vect{x} \bullet \vect{y}
= &
\begin{cases}
(\vect{x}^L, \vect{y}^U) & \vect{x}^U_1 + 1 = \vect{y}^L_1 \; \wedge \;
\vect{x}_{2:n} = \vect{y}_{2:n}) \\
\bot  & \textit{otherwise}
\end{cases}
% $m$-dimensions into coalesced spans which vary in
% $m+1$-dimensions.
\end{align*}
%%
\end{definition}
\noindent
To coalesce regions which are contiguous in other dimensions
other than the first, we generate all rotations of the spans in
$n$-dimensional space by permutation on spans, and fold together contiguous
regions using $\bullet$ (above). This 
generates all possible ways of coalescing regions. For our example,
the unit spans in Figure~\ref{fig:inference-steps-informal}(a)
are coalesced into the contiguous spans in
Figure~\ref{fig:inference-steps-informal}(b).
This procedure is iterated until a fixed point is reached. In this
example this is reached in the first step. 
 Then any spans that are completely contained by any other span are deleted,
leaving a minimal set of spans (which may overlap, but none of which
fully contains another), Figure~\ref{fig:inference-steps-informal}(c).
The final spans are used to synthesise concrete stencil specification
syntax (Section~\ref{sec:inf-step4}), where
each span becomes a product \texttt{*} of regions which are 
combined by the sum \texttt{+}.

More formally the algorithm proceeds as follows.
For all $x \in \mathsf{dom}(U)$, let $M = U(x)$. Every scheme in $M$ 
is mapped to a unit span
by $\textsf{unitSpans}(M) = \{[u \; u] \mid u\!\in\!M\}$. For our example:
%%
\begin{align*}
N(U(\texttt{a})) = \stwo{0}{0}{0}{0} \stwo{1}{0}{1}{0} \stwo{-1}{0}{-1}{0} \stwo{0}{1}{0}{1} \stwo{0}{-1}{0}{-1}
\end{align*}
%%
In the following we let $M_0 = N(U(\texttt{a}))$ for our example.

Each set of unit spans is applied to the fixed point of the \spanOp{} function
(defined shortly), which coalesces spans into contiguous regions. That is, we compute
 $(\mu \, \spanOp)$ on input $N(M)$, where \spanOp{} is defined by the steps:


\begin{figure}[t]
\vspace{-0.8em}
\hspace{-0.5em}
\begin{minipage}{0.16\linewidth}
\begin{align*}
\setlength{\arraycolsep}{0em}
\begin{array}{c}
\quad \\[0em]
\begin{tikzpicture}[scale=0.8]
%\draw[step=0.5cm,lightgray,very thin] (0.5,0.5) grid (2,2);
\node at (1.25,1.22) {\textnormal{\footnotesize{0,0}}};
\draw[thick] (1,1) rectangle (1.5,1.5);
\draw[thick] (1.5,1) rectangle (2,1.5);
\draw[thick] (1,0.5) rectangle (1.5,1);
\draw[thick] (0.5,1) rectangle (1,1.5);
\draw[thick] (1,1.5) rectangle (1.5,2);
\end{tikzpicture} \\[0em]
(a)
\end{array}
\end{align*}
\end{minipage} $\rightarrow$ \begin{minipage}{0.43\linewidth}
\begin{align*}
\setlength{\arraycolsep}{0em}
\begin{array}{c}
\begin{tikzpicture}[scale=0.72]
%\draw[step=0.5cm,lightgray,very thin] (0.5,0.5) grid (2,2);
%\node at (1.25,1.22) {\textnormal{\small{0,0}}};
\draw [black, thin] (0.35,0) to [round left paren ] (0.35,2);
\draw[thick] (0.5,1) rectangle (2,1.5);
\draw[thick] (1,0.40) rectangle (1.5,0.90);
\draw[thick] (1,1.60) rectangle (1.5,2.10);
\node at (2.3,1.22) {+};
\draw[thick] (3.8,1) rectangle (4.3,1.5);
\draw[thick] (2.6,1) rectangle (3.1,1.5);
\draw[thick] (3.2,0.5) rectangle (3.7,2);
\draw [black, thin] (4.4,0) to [round right paren ] (4.4,2);
\end{tikzpicture} \\[-0.5em] (b)
\end{array}
\end{align*}
\end{minipage}$\rightarrow$ \begin{minipage}{0.25\linewidth}
\begin{align*}
\setlength{\arraycolsep}{0em}
\begin{array}{c}
\begin{tikzpicture}[scale=0.72]
%\node at (1.25,1.22) {\textnormal{\small{0,0}}};
\draw [black, thin] (0.8,0) to [round left paren ] (0.8,2);
\draw[thick] (1,0.5) rectangle (1.5,2);
\node at (1.8,1.22) {+};
\draw[thick] (2.1,1) rectangle (3.6,1.5);
\draw [black, thin] (3.7,0) to [round right paren ] (3.7,2);
%\node at (2.75,1.22) {\textnormal{\small{0,0}}};
\end{tikzpicture} \\[-0.5em] (c)
\end{array}
\end{align*}
\end{minipage}
\caption{Illustration of grouping spans in
specification inference}
\label{fig:inference-steps-informal}
\vspace{-0.8em}
\end{figure}

\noindent
\textbf{1)\,} Compute all permutations on the column vectors in a span, \ie{},
  $[\vect{x}^L \vect{x}^U] \mapsto [\pi\vect{x}^L \, \pi\vect{x}^U]$
for a permutation $\pi$. For each permutation function $\pi^n_i$
(the $i$-th permutation for vectors of size $n$) we pair the
permutation function with the set of permuted spans so that
the spans can be un-permuted later.
%
\begin{equation*}
P(M) = \bigcup_{i \in n!} (\pi^n_{i} , \; \{[\pi^n_i
\vect{x}^L \; \pi^n_i\vect{x}^U] \, \mid \, [\vect{x}^L \; \vect{x}^U]
\leftarrow M\}
\end{equation*}
%
This corresponds to all rotations of the space.  For our example:
%
\begin{align*}
P(M_0) =
\{&(\pi^2_1, \{ \stwo{0}{0}{0}{0},
\stwo{1}{0}{1}{0},
\stwo{-1}{0}{-1}{0},
\stwo{0}{1}{0}{1},
\stwo{0}{-1}{0}{-1} \})
\\
&(\pi^2_2, \{
 \stwo{0}{0}{0}{0},
 \stwo{0}{1}{0}{1},
 \stwo{0}{-1}{0}{-1},
 \stwo{1}{0}{1}{0},
 \stwo{-1}{0}{-1}{0}\})\}
\end{align*}
%
where $\pi^2_1$ is the identity permutation and $\pi^2_2$ is the
permutation flips the order of the two elements in the 
vectors. \\[-1em]

\noindent
\textbf{2)\,} Sort each permutation set into an ordered list, by the ordering:
\begin{equation*}
  \vect{x} \leq \vect{y} =
      \exists i \, . \; \vect{x}^L_{i} \leq \vect{y}^L_{i} \; \wedge \;
        (i = n \vee \vect{x}_{i+1:n} = \vect{y}_{i+1:n})
\end{equation*}
%
giving the sorting function $\textsf{sort}(M)$. For our example:
%%
\begin{align*}
\textsf{sort}(P(M_0)) = 
\{&(\pi^2_1, [
\stwo{0}{-1}{0}{-1},
\stwo{-1}{0}{-1}{0},
\stwo{0}{0}{0}{0},
\stwo{1}{0}{1}{0},
\stwo{0}{1}{0}{1}] )
\\
&(\pi^2_2, [
\stwo{0}{-1}{0}{-1},
\stwo{-1}{0}{-1}{0},
\stwo{0}{0}{0}{0},
\stwo{1}{0}{1}{0},
\stwo{0}{1}{0}{1}])\}
\end{align*}
\noindent
\textbf{3)\,} Reduce each list pairwise by $\bullet$ operation 
(Defn.~\ref{def:span-coalesc}) to coalesce contiguous regions,
given by $\textsf{fold}\bullet$. For our example, this yields:
%
\begin{align*}
\{&(\pi^2_1, [
\stwo{0}{-1}{0}{-1},
\stwo{-1}{0}{1}{0},
\stwo{0}{1}{0}{1}
]), (\pi^2_2, [
\stwo{0}{-1}{0}{-1},
\stwo{-1}{0}{1}{0},
\stwo{0}{1}{0}{1}])\}
\end{align*}
%
\textbf{4)\,} Un-permute and union together, \ie{},
%
\[
U(M) = \bigcup \{[\pi \vect{x}^L, \pi \vect{x}^U]
 \mid [\vect{x}^L, \vect{x}^U] \leftarrow S, (\pi, S) \leftarrow M\}
\]
For our example:
%
\begin{align*}
U(M) =
\{\stwo{0}{-1}{0}{-1},
\stwo{-1}{0}{1}{0},
\stwo{0}{1}{0}{1},
\stwo{-1}{0}{-1}{0},
\stwo{0}{-1}{0}{1},
\stwo{1}{0}{1}{0}\}
\end{align*}
%
\textbf{5)\,} Filter by the region containment predicate $\containedin$, that
  is, if any region is contained within another then remove the
  smaller, defined:
%
\begin{align*}
& \vect{x} \containedin \vect{y} = \vect{y}^L_1 \leq \vect{x}^L_1 \wedge \vect{x}^U_1 \leq \vect{y}^U_1
  \wedge (\vect{x}^L_{2:n}, \vect{x}^U_{2:n}) \containedin
  (\vect{y}^L_{2:n}, \vect{y}^U_{2:n})
\end{align*}
For our example this then yields the final result of:
\begin{align*}
\spanOp(M)
= \{\stwo{-1}{0}{1}{0} \stwo{0}{-1}{0}{1}\}
\end{align*}
since $\stwo{0}{1}{0}{1} \sqsubseteq \stwo{0}{-1}{0}{1}$
and $\stwo{1}{0}{1}{0} \sqsubseteq \stwo{-1}{0}{1}{0}$.
Applying \spanOp{} again yields the same
result for our example; the fixed point is reached.

\subsubsection{Step 4: Synthesise specifications from spans}
\label{sec:inf-step4}

\newcommand{\oplusbig}{\operatornamewithlimits{\term{\Large{$\oplus$}}}}
\newcommand{\odobig}{\operatornamewithlimits{\term{\Large{$\odot$}}}}
\newcommand{\bplus}{\operatornamewithlimits{\term{\Large{+}}}}
\newcommand{\tySum}[1]{#1^{\term{+}}}
\newcommand{\tyProd}[1]{#1^{\term{*}}}
\newcommand{\specDNF}{\textbf{spec}}

Abstract syntax trees of the specification language
are synthesised from the set $\spanOp(M)$ of coverings spans. 
This conversion is defined in terms
of an algebra on \textit{spec} syntax in disjunctive-normal form
(which we denote \specDNF{}) and which is wrapped
in the $\textsf{Approx}$ type (see
Defn.~\ref{def:mult-and-approx},
p.~\pageref{def:mult-and-approx}), which we write as $\mathsf{A}$
for brevity.  The algebra mirrors the shape
of the region combinators for sum and product, 
with operators $\oplus$ and $\odot$ and a constructor for \specDNF{}:
%%
\begin{align*}
\oplus & : \mathsf{A}(\specDNF) \rightarrow \mathsf{A}(\specDNF) \rightarrow
  \mathsf{A}(\specDNF) \\
\odot & : \mathsf{A}(\specDNF) \rightarrow \mathsf{A}(\specDNF) \rightarrow
        \mathsf{A}(\specDNF) \\
\mathsf{toSpec} & : (\mathbb{Z} \cup \{\infty\}) \rightarrow (\mathbb{Z} \cup
  \{\infty\})  \rightarrow \mathsf{A}(\specDNF)
\end{align*}
%%
The $\mathsf{toSpec}$ function maps a pair of lower and upper bound
values (one-dimensional) to a specification with a one-dimensional region. 
An entire span is converted into an $n$-dimensional
specification by applying $\mathsf{toSpec}$ to each
pair of lower and upper bounds in a span, per dimension, and multiplying these
specifications by $\odot$. The resulting specifications for
each span are then summed by $\oplus$:
\begin{equation*}
\textsf{spec}(M) = 
\oplusbig\limits_{\vect{x} \in \spanOp(M)} \,
\odobig\limits_{i \in \{1, \ldots, n\}} \, \mathsf{toSpec}(\vect{x}^L_i, \vect{x}^U_i)
\end{equation*}
We unpack the definitions of this algebra.

\begin{definition}[Specifications in DNF]
Let $r_1, ..., r_n$ range over elements of the \textit{region}
syntax (see Figure~\ref{fig:syntax}, p.~\pageref{fig:syntax}).
The set \specDNF{} is a subset of syntax trees \textit{spec},
containing specifications in disjunctive normal form over regions 
where the disjunct is \term{+} (since its model is in terms of set
union) and the conjunct is \term{*} (since its model is a form of tensor).
That is elements of \specDNF{} are of the form:
%%
$
(r^1_{1} \; \term{*} \ldots \term{*} \; r^1_n)\; \term{+} \; \ldots 
\term{+} \; (r^m_1 \, \term{*} \; \ldots \term{*} \; r^m_p)
$. 

More formally, $\specDNF \subseteq (\textit{spec} \cup \{\epsilon\})$, defined:
%%
\begin{align*}
\specDNF{} & ::= \tySum{\specDNF} \mid \epsilon \\
\tySum{\specDNF} & ::= \tyProd{\specDNF} \; \term{+} \; \tySum{\specDNF} \mid
  \tyProd{\specDNF} \\
\tyProd{\specDNF} & ::= \textit{region} \; \term{*} \; \tyProd{\specDNF} \mid
   \textit{region}
\end{align*}
%%
We include the empty element $\epsilon$ which is not present in the
syntax. 
In the following, $S, T$ range over elements of
\specDNF{} and $\tyProd{s}, \tyProd{t}$ range over elements
of $\tyProd{\specDNF}$ (for example, $\tyProd{s} = r^1_{1} \; \term{*}
\ldots \term{*} \; r^1_n$).
\end{definition}

\newcommand{\exactR}{\mathsf{exact}\;}
\newcommand{\exact}[1]{\exactR(#1)}
\newcommand{\upperB}[1]{\mathsf{upper}\;(#1)}


\begin{figure}[t]
%\newcommand{\llower}{\vect{x}^L_i}
%\newcommand{\lupper}{\vect{x}^U_i}
\vspace{-0.7em}
\newcommand{\llower}{l}
\newcommand{\lupper}{u}
{\scalebox{0.97}{
\begin{minipage}{1\linewidth}
\begin{align*}
&\mathsf{toSpec} \; \llower \; \lupper = \\
&\hspace{-0.4em}\begin{cases}
%% FWD
\exact{\stenFwdS{\lupper}{i}}  & \llower = 0 \, \wedge \, \lupper > 0 \\[0.2em]
\exact{\stenFwdSR{\lupper}{i}{\irreflS}}\!\!\!\! & \llower = 1 \, \wedge \, \lupper > 0 \\[0.2em]
%% BWD
\exact{\stenBwdS{|\llower|}{i}}  & \llower < 0 \, \wedge \, \lupper = 0 \\[0.2em]
\exact{\stenBwdSR{|\llower|}{i}{\irreflS}}\!\!\!\! & \llower < 0 \, \wedge \, \lupper = -1 \\[0.2em]
%% CEN
\exact{\stenCenS{\lupper}{i}}& \llower < 0 \wedge \lupper > 0 \wedge |\llower| = \lupper \\[0.2em]
\exactR(\stenBwdS{|\llower|}{i} & \llower < 0 \wedge \lupper > 0  \wedge |\llower| \neq \lupper \\
\qquad\qquad \texttt{+} \, \stenFwdS{\lupper}{i}) & \\[0.2em]
% BOUND
\upperB{\stenFwdS{\lupper}{i}} & \llower > 1 \\[0.2em]
\upperB{\stenBwdS{|\llower|}{i}} \quad & \llower < (-1)
 \\[0.2em]
% ABSOLUTE REP
\exact{\epsilon} & \llower = \infty \, \vee \, \lupper = \infty
  \end{cases}
\end{align*}
\end{minipage}
}}
\caption{\textsf{toSpec} constructor of $\mathsf{A}(\specDNF)$ values.}
\label{fig:to-spec}
\vspace{-0.8em}
\end{figure}

\begin{definition} The $\mathsf{toSpec}$ constructor is defined
in Figure~\ref{fig:to-spec}.
The first two cases map to \texttt{forward} stencils since the lower
bound is $0$ or $1$, with the depth determined by the upper bound of
the span. If the lower bound is $1$, then the
$0$-offset point is missing so the region is given an
\texttt{irreflexive} attribute. The second two cases are similar for
\texttt{backward} but now the depth of the region is determined by the
absolute of the lower bound. In the fifth-case, where the lower bound
is negative and the upper bound is positive and they have the same
magnitude, then a \texttt{centered} region is constructed with
the depth as the common magnitude. If the magnitudes are not the same
(sixth case) then separated \texttt{forward} and \texttt{backward}
regions are summed, with their corresponding depths.

If the lower bound is greater than 1
(which implies the upper bound is greater than 1 too) then
this represents a region that is not at the origin (or next to) the
origin and thus cannot be represented in the specification language.
Thus, an upper bound is instead returned showing the maximum extent
of the region. The penultimate case is the dual, when the lower bound is less
than $-1$, giving an upper bound on a \texttt{backward} specification.

Finally, if either bound is $\infty$, representing a non
neighbourhood index, then an empty specification is given
 with no regions, indicating that there is not even reflexive
0-offset access in this dimension.

Note, $\mathsf{toSpec} \, l \, u$ is always defined 
 if $l$ less than or equal to $u$. 
\end{definition}

%\newcommand{\mkBig}[2]{\overset{\LARGE{\term{#1}}}{#2}}
\begin{definition} The $\odot$ operation on $\textsf{A}(\specDNF{})$
  is defined in terms of the intermediate operator $\hat{\odot}$ on
  \specDNF{}, defined:
%%
\begin{align*}
S \,\hat{\odot}\, \epsilon = S \quad
\epsilon \,\hat{\odot}\, S = S \qquad
S \,\hat{\odot}\, T = \bplus_{(\tyProd{s}, \tyProd{t}) \in (S \times
   T)} (\tyProd{s} \; \term{*} \; \tyProd{t})
\end{align*}
%%
That is, the $\hat{\odot}$ product of two specifications $S$ and $T$ in DNF form 
is the $\term{+}$ sum of all pairwise $\term{*}$ products for every
pair of $\tyProd{spec}$ drawn from $S$ and $T$. The result
is indeed in DNF-form, where $\hat{\odot}$ is essentially applying
 the (\trule{\textsc{dist}}) rule of our equational theory
 (Fig.~\ref{fig:equations},p.~\pageref{fig:equations}). The operation is
commutative and associative, and sound with respect to our
model (see Lemma~\ref{lem:alg-soundness} below).
The $\hat{\odot}$ operation is then lifted to all combinations of
\textsf{Approx} for $\odot$:
\begin{align*}
\textsf{lower}(S) \odot \textsf{exact}(T) = \; &
       %\textsf{exact}(T) \odot \textsf{lower}(S) = \;
       \textsf{both} \, (S \hat{\odot} T, \; T) \\
\textsf{upper}(S) \odot \textsf{exact}(T) = \; & 
       %\textsf{exact}(T) \odot \textsf{upper}(S) =
       \textsf{both} \, (T, \; S \hat{\odot} T) \\
\textsf{lower}(S) \odot \textsf{both}(T_l,T_u) = \; &
        %\textsf{both}(T_l,T_u) \odot \textsf{lower}(S) = \;
        \textsf{both} \, (S \hat{\odot} T_l, \; T_u) \\
\textsf{upper}(S) \odot \textsf{both}(T_l,T_u) = \; & \textsf{both} \,
                                                      (T_l, \; S \hat{\odot} T_u) \\
\textsf{both}(S_l,S_u) \odot
\textsf{both}(T_l,T_u)  = \; & \textsf{both} (S_l \hat{\odot} T_l, \; S_u
                         \hat{\odot} T_u) \\
\textit{inj}(S) \odot \textit{inj}(T) = \; & \textit{inj}(S
                                              \hat{\odot} T)
\end{align*}
where in the last case $\textit{inj}$ corresponds to the unary
injections of \textsf{Approx}. For brevity we omit the cases where the arguments above are flipped
as $\odot$ is commutative.
\end{definition}

\begin{definition}The $\oplus$ operation on $\textsf{A}(\specDNF)$ 
is defined in a similar way to $\odot$, with the intermediate $\hat{\oplus}$ on
$\specDNF$ given by:
%%
\begin{equation*}
S \,\hat{\oplus}\, \epsilon = S \quad
\epsilon \,\hat{\oplus}\, S = S \quad
S \, \hat{\oplus} \, T = S \, \term{+} \, T
\end{equation*}
%%
Thus, if neither specification is empty, their $\hat{\oplus}$ is just
the syntactic sum $\term{+}$. Then $\oplus$ is the lifting of
$\hat{\oplus}$ to \textsf{Approx} with the shape as $\odot$ in the previous
definition.
\end{definition}

\begin{lemma}[$\hat{\odot}$, $\hat{\oplus}$ soundness]$\forall S,
  T \in \specDNF$ where $S\!\neq \epsilon \wedge T\!\neq \epsilon$:
\begin{align*}
\interp{S \; \hat{\odot} \; T}_n = \interp{S}_n \otimes \interp{T}_n
  \qquad
\interp{S \; \hat{\oplus} \; T}_n = \interp{S}_n \cup \interp{T}_n
\end{align*}
\label{lem:alg-soundness}
\vspace{-2em}
\end{lemma}
%
\noindent
Thus our model validates the specification synthesis process which concludes the
inference procedure. For our example, we infer and then synthesise the
5-point specification:
%%
\begin{minted}[linenos=false]{fortran}
!= stencil centered(depth=1, dim=1)*reflexive(dim=2) + centered(depth=1, dim=2)*reflexive(dim=1):: a
\end{minted}
%%

\subsection{Specification checking\label{subsec:checking}}

In checking mode, the access pattern of a stencil computation in the
source language is verified against a specification. The model of
Section~\ref{sec:semantics} again aids this process.  Checking
proceeds by generating a model $M$ from a specification and generating a set $N$ of indexing
schemes from the source code. The source code is then valid with
respect to the specification if $N$ is \emph{consistent} with $M$. The
notion of consistency is built out of index scheme 
\emph{generalisation} (Sect.~\ref{subsec:schemes-and-gen}). 
%Consistency is defined in Figure~\ref{fig:consistency},
We first set up some intermediate definitions.% before unpacking its definition.

\begin{definition}[Checking]
Let \texttt{a} be an array variable and let
$S \in \textit{spec}$ be a specification with
the \textit{specDec} \texttt{!= stencil
  $S$ :: a} in our syntax.
For a array subscript
assignment statement $\textit{assg} = v(\overline{e_1}) = e_2$ in our source language
(with all the appropriate data flow information in place)
where $e_2$ has at most $n$-dimensional array access, 
then the assignment conforms to the specification $S$ if 
the predicate $\mathit{check}_n(S, \textit{assg}, \texttt{a})$ holds, 
defined:
\begin{align*}
& \mathit{check_n}(S, \textit{assg}, x) =
  \mathit{cons_n}(\interp{S}_n, \, \textit{modelise}(\textit{assg},
  x)) \\
& \mathit{modelise} : \textit{statement} \times \textit{variable}
  \rightarrow \textsf{Mult}((\domainVal)^n) \\ 
& \mathit{modelise} (\textit{assg}, x) =
  \begin{cases}
    \textsf{once}(\mathit{analyse}(\textit{assg})(x)) & \textit{unique}(\textit{assg},x) \\
    \textsf{mult}(\mathit{analyse}(\textit{assg})(x)) & otherwise
  \end{cases}
\end{align*}
Thus, checking proceeds by reusing the \textit{analyse} function from 
inference (Sec.~\ref{subsec:inference}) to extract index 
schemes from source code. 
This is then augmented with multiplicity information
by $\mathit{modelise}$ where $\mathit{unique}(\textit{assg},x)$ is a
 predicate indicating whether indices to array $x$ in an
assignment $\textit{assg}$ are unique or not. 
\end{definition}

Subsequently the binary predicate for consistency, at the heart of checking
is defined over the sets: 
%
\begin{equation*}
\textit{cons}_n \subseteq \textsf{Mult}(\textsf{Approx}(\domainVal{}^n))
\times \textsf{Mult}(\domainVal{}^N)
\end{equation*}
%
where first component is a model of a specification,
and the second component is a set of indexing schemes generated from
the array subscripts in a program, with added multiplicity
information. Giving \textsf{Approx} information to the
index schemes inferred from the program is not necessary, nor
desirable-- we have an exact set of schemes. We refer to the first
component of the predicate as \emph{spec model} and the second as \emph{code model}. 

\begin{definition}
Consistency is defined in Figure~\ref{fig:consistency}. We let
$M_s, M_c$ range over elements of $\domainVal{}^n$ where $M_s$ comes
from the spec model and $M_c$ comes from \textit{modelise} on the
source code. Let $N_c$ range over elements of
$\textsf{Mult}(\domainVal{}^n)$ coming from the code model, and $A_s$
over elements of $\textsf{Mult}(\textsf{Approx}(\domainVal{}^n))$ from the spec model.

The first equation states that, if the multiplicity of the spec and code
model are both $\mathsf{once}$, then the problem is reduced to checking consistency of
models in which non-unique indexing is allowed, labelled with
$\mathsf{mult}$. 

The second equation considers the case where the specification is
an \term{atMost} upper-bound approximation (labelled with \textsf{up}
as shorthand for \textsf{upper} here). 
An upper bound specification means that for every scheme in the code
model, modelling a source-level index, $\forall u \in M_c$ there exists
a generalising scheme in the spec model $\exists v \in M_s$, \ie{}, $u
\preceq_n v$. That is, every source-level index is generalised by the model.

The third equation is the converse of an \term{atLeast},
lower approximation (labelled \textsf{low} as shorthand for
\textsf{lower}). Consistency is dual to the above: 
for every scheme in the spec model $\forall v \in M_s$ there
exists a scheme in the code model $\exists u \in M_c$ such that $u
\preceq_n v$. That is, every model scheme is generalised by source indexing.

These two are combined for consistency on an \textsf{exact}
specification (the fourth equation) such that the spec model
provides both a consistent lower and consistent upper bound on
the source code. Thus, for every scheme in the code model there
is a scheme in the spec model that generalises it, and for every
scheme in the spec model there is a scheme in the source model that
specialises it.  

Lastly, if the spec model has both an upper and lower bound
consistency is defined inductively similar to the \textsf{exact} case.
\end{definition}

\begin{figure}
\vspace{-0.4em}
\input{consistency.tex}
\caption{Consistency between a model and indexing schemes}
\label{fig:consistency}
\vspace{-0.9em}
\end{figure}

\begin{example}
We give an extended example of verifying a stencil computation against
its specification. We consider a more general, but still consistent, version of the \textit{five-point}
stencil specification inferred previously in
Section~\ref{subsec:inference}:
%
\begin{minted}[breakindent=8.1em]{fortran}
!= region fivepoint = centered(depth=1,dim=1) + centered(depth=1,dim=2)
!= stencil readOnce, fivepoint :: b
a(i,j) = b(i,j-1)+b(i,j)+b(i,j+1)+b(i-1,j)+b(i+1,j)
\end{minted}
%
We refer to the assignment on line three as $l3$ for brevity.

Verification of the code against the spec is then given by 
$check(({\textcolor{darkgreen}{\texttt{readOnce, fivepoint}}}),l3,\texttt{b})$. 
We explain the steps.
\begin{enumerate}  
%
\item Generate the model from the specification as in
  Section~\ref{sec:semantics}. 
%
\begin{align*}
 M_s= \{  \vtwo{-1}{\infty},
          \vtwo{0}{\infty},
          \vtwo{1}{\infty},
          \vtwo{\infty}{-1},
          \vtwo{\infty}{0},
        \vtwo{\infty}{1} \}  \\[0.4em]
\interp{{\textcolor{darkgreen}{\texttt{readOnce, fivepoint}}}}_2 =
  \textsf{once}(\textsf{exact} (M_s))
\end{align*}
%
\item Obtained the code model via $\textit{modelise}$, giving:
%
\begin{align*}
M_c = \{
    \vtwo{0}{-1},
    \vtwo{0}{0},
    \vtwo{0}{1},
    \vtwo{-1}{0},
    \vtwo{1}{0}
  \}
\\[0.4em]
\textit{modelise}(l3, \texttt{b}) = \textsf{once} (M_c)
\end{align*}
%
\item Consistency $cons_2(\textsf{once}(\textsf{exact}(M_s)),
  \textsf{once}(M_c))$ holds when 
  $\textit{cons}_2(\textsf{mult}(\textsf{exact}(M_s)),\textsf{mult}(M_c))$ (Fig.~\ref{fig:consistency}) 
  which holds when: 
  \begin{align*}
     & \textit{cons}_2(\textsf{mult}(\textsf{up}(M_s)),\textsf{mult}(M_c)) \\
   \wedge \; & \textit{cons}_2(\textsf{mult}(\textsf{low}(M_s),\textsf{mult}(M_c))
  \end{align*}
%
\item This condition holds by the following sets of scheme
  generalisations: for the upper bound, $\forall u \in M_c,
  \exists v \in M_s . u \preceq_2 v$: 
  \begin{align}
    \begin{array}{l}
     \vtwoh{0}{-1} \preceq_2 \vtwoh{0}{\infty} \quad
     \vtwoh{0}{0} \preceq_2 \vtwoh{0}{\infty} \quad
     \vtwoh{0}{1} \preceq_2 \vtwoh{0}{\infty} \\[0.5em]
     \vtwoh{-1}{0} \preceq_2 \vtwoh{\infty}{0} \quad
     \vtwoh{1}{0} \preceq_2 \vtwoh{\infty}{0}
     \end{array}
  \label{eq:check-example-upper}
  \end{align}
  % 
  and for the lower bound: $\forall v \in M_s, \exists u \in M_c . u
  \preceq_n v$: 
  \begin{align}
    \hspace{-1em}
    \begin{array}{l}
     \vtwoh{-1}{0} \preceq_2 \vtwoh{-1}{\infty} \quad
     \vtwoh{0}{0} \preceq_2 \vtwoh{0}{\infty} \quad
     \vtwoh{1}{0} \preceq_2 \vtwoh{1}{\infty}  \\
     \vtwoh{0}{-1}  \preceq_2 \vtwoh{\infty}{-1} \quad
     \vtwoh{0}{0}  \preceq_2 \vtwoh{\infty}{0} \quad
     \vtwoh{0}{1}  \preceq_2 \vtwoh{\infty}{1}
     \end{array}
    \label{eq:check-example-lower}
  \end{align}
  Since both the consistency predicate is satisfied, the array
  accesses flowing to line three in the stencil computation are valid
  with respect to the {\textcolor{darkgreen}{\texttt{fivepoint}}} specification.
\end{enumerate}
\vspace{-0.7em}
\end{example}
\begin{example} 
We consider now an erroneous user modification to $l3$ with an
additional term \texttt{b(i+2,j+2)} such that $l3'$ is:
%
\begin{minted}[firstnumber=3]{fortran}
a(i,j) = b(i,j-1) + b(i,j) + b(i,j+1) + b(i-1,j) + b(i+1,j) + b(i+2,j+2)
\end{minted}
%
The checking procedure proceeds in the same way as the first three
steps of the previous example, except that the result of
$\mathit{modelise}(l3',\texttt{b})$ generates an additional scheme
$\vtwoh{2}{2}$. Since the spec model has not changed and the code
model is has only the additional scheme $\vtwoh{2}{2}$, the generalisations for
the lower bound \eqref{eq:check-example-lower} 
of step 4 above still holds since its consistency condition
universally quantifies over the \emph{spec model}. However, for
the upper bound, the consistency condition universally quantifies
over scheme $u$ of the \emph{code model} for which there exists
a scheme $v \in M_s$ such that $u \preceq_2 v$. Thus, we require a $v
\in M_s$ such that $\vtwoh{2}{2} \preceq_2 v$ but no such generalising
scheme existing in the spec model. Hence the model fails to hold as an upper bound.

Note that if the specification were as follows:
%
\begin{minted}{fortran}
!= stencil atLeast, readOnce, fivepoint :: b
\end{minted}
%
then consistency holds as it no longer requires the failing upper-bound case 
$\mathit{cons}(\textsf{mult}(\textsf{up}(M_s)),\textsf{mult}(M_c))$.
 This makes sense semantically since the region ${\textcolor{darkgreen}{\texttt{fivepoint}}}$
is indeed contained in the regions touched by $\texttt{b}$ in $l3'$. 
\end{example}

\subsection{Approximations and checking}

As noted, the {\textcolor{darkgreen}{\term{fivepoint}}} region
 above is more accepting than that used in
Section~\ref{sec:lang}. This introduces a new notion of approximation
beyond what is given by the syntactic theory of sub-specifications
$<:$ in Section~\ref{sec:eqs}. Consistency leads to a notion of
approximation that is a \textit{semantic sub-specification} relation:
%using upper and lower bounds because the in both cases the specifications are
%used to generate \emph{exact} models.

\begin{definition}[Approximation]
A specification $S'$
\emph{approximates} a more specific specification $S$, written 
$S \sqsubseteq S'$, \emph{iff}:
$$
\forall M_c \in \textsf{Mult}(\domainVal{}^n) . \;\, \mathit{cons}_n(\interp{S}_n,M_c) \implies
\mathit{cons}(\interp{S'}_n,M_c)
$$
\end{definition}
%
For the syntactic sub-specification equations on regions $<:^r$, it follows that
these imply semantic approximation:
%
\begin{lemma}[Sub-specification $<:^r$ coincides with approx 
$\sqsubseteq$]
\begin{equation*}
\forall S, S' . \; S <:^r S' \Rightarrow S \sqsubseteq S'
\end{equation*}
\end{lemma}
%
\noindent
However, the converse direction does not hold. 
The regions describing the more accepting five-point stencil
above do not follow from the definition of $<:$ on the previous
more specific specification.%, that is:
%${\textcolor{darkgreen}{\term{centered(depth=1, dim=1)*reflexive(dim=2)
%      + centered(depth=1, dim=2)*reflexive(dim=1)}}}
%\not{<:} {\textcolor{darkgreen}{\term{centered(depth=1,dim=1) +
%      centered(depth=1,dim=2)}}}$.
 However, consistency (and thus $\sqsubseteq$) shows
that we can check the five-point stencil code against the more general
specification of {\textcolor{darkgreen}{\term{fivepoint}}}. Thus, we
can always use an approximation in place of the
more specific specification. Although this decreases the likelihood of catching
stencil errors (as more access patterns conform), it reduces the space and
effort it takes to write the specification.

\section{Evaluation}
\label{sec:evaluation}
We evaluated our specification language on a corpus of scientific
code.  We overview the corpus itself before presenting our results.

%\subsection{Software Corpus}
\paragraph{Software Corpus}

Table~\ref{tab:corpus} shows summary statistics of the software
packages used in our evaluation, all of which are written in Fortran
90 or Fortran 77. In total we analysed \SI{\overallLoC} lines of code
from 7 packages, of which we successfully parsed
\SI{\overalllinesParsed} lines. The ``Number of files'' column shows
how many files in each corpus that we were able to analyse with
CamFort. The most common reasons for CamFort rejecting a file were
either use of a C-preprocessor, or illegal use of language features
from a modern Fortran variant.

\textbf{The Unified
  Model}~\cite{um}
is a weather forecasting and climate modelling tool developed by the
Met Office in the United Kingdom. It is used by research organisations
and meteorological services around the world. We use the development
branch (trunk) of the model. The code base in closed source but
institutional licenses are available for research purposes. %The Met Office runs a comprehensive code quality system incorporating dedicated committers (we counted 11) for particular parts of the model. We counted 120 additional contributors whose submissions are reviewed and tested before being accepted into the code base.

% e3mg-ea
\textbf{E3MG} (An Energy-Environment-Economy (E3) Model at the Global Level) is a macroeconomic model used for assessment of environmental policy~\cite{RePEc:aen:journl:2006se-a12}. This was developed by Cambridge Econometrics, an independent consultancy company.

\textbf{BLAS}~\cite{blas} (Basic Linear Algebra Subprograms) is a popular
library providing efficient and portable routines for vector and
matrix operations. These routines feature in many other libraries
(including LAPACK). We used version 3.6.0. We chose to include this
package for breadth, as it provides general numerical functions rather
than a specialised scientific model. 

\textbf{Hybrid4} is a vegetation and biomass model for simulating carbon, water and nitrogen flows~\cite{GBC:GBC635}.

\textbf{GEOS-Chem}~\cite{geos-chem} is a three-dimensional model of
tropospheric chemistry developed at Harvard and used by $\sim$70
universities and research institutions world-wide. We use v.10-01.

\textbf{Navier} is a small numerical simulation, giving a discrete
approximation to the two-dimensional Navier-Stokes fluid equations,
based on the book of~\citet{griebel1997numerical}.

\textbf{CP} consists of the example code from the second edition of the book ``Computational Physics''~\cite{nicholas2006computational} introducing numerical techniques and their application to modern physics problems such as fields, waves, statistical mechanics and quantum mechanics.

% atLeast: number of stencils with an atLeast modifier
% atMost: number of stencils with an atMost modifier
% boundedBoth: number of stencils with both atLeast and atMost modifier
%% atLeast == atMost == boundedBoth - whenever we infer one we infer the other but users might write just one

% backward: number of backward stencils
% forward: number of forward stencils
% centereed: number of centered stencils

% justReflexive: number of only reflexive stencils
% irreflexive: number of irreflexive stencils
% readOnce: number of readOnce stencils

% depthX: number of stencils with depth X
% dimsX: number of stencils with dimensions=X (check this!)

% lexFailed: number of files we failed to lex
% parseFailed: number of files we failed to parse
% lexOrParseFailed: number files we failed to lex and parse
% parseOk: number of files parsed successfully
%% lexFailed + parseFailed = lexOrParseFailed
%% lexOrParseFailed + parseOk = number of files in source repo

% tickAssign: number of array subscripts with a LHS which are all neighbour indices or constants
% tickAssignSuccess: number of tickAssign's we generated some specification for
%% tickAssign < tickAssignSuccess

\subsection{Occurrences of stencils}

We first examined how frequently stencil computations occur in our
corpus. This was carried out by running our implementation in 
whole-code-base inference mode. We define a \emph{potential} statement as one whose left-hand
side is an array subscript on neighbourhood indices. These statements
are the inputs to Step 2 of the Inference process described in 
Section~\ref{subsec:inference}. Each potential statement for which we
eventually generate some specification is also counted as
an \emph{actual} statement.

\begin{table}
\centering
\footnotesize
\begin{tabular}{lS[table-format=4]S[table-format=4]SS}
\hline
& \multicolumn{2}{c}{Number of files} & \multicolumn{2}{c}{Lines of code} \\

Package   & {Total} & {Parsed} & {Total} & {Parsed}  \\ % braces prevent headers from being formatted as numbers
\hline
UM        & \umFiles                       & \umparseOk                      & \umLoC                      & \umlinesParsed \\
E3MG      & \ethreemgeaFiles               & \ethreemgeaparseOk              & \ethreemgeaLoC              & \ethreemgealinesParsed \\
BLAS      & \blasFiles                     & \blasparseOk                    & \blasLoC                    & \blaslinesParsed \\
Hybrid4   & \hybridfourFiles               & \hybridfourparseOk              & \hybridfourLoC              & \hybridfourlinesParsed \\
GEOS-Chem & \geoschemFiles                 & \geoschemparseOk                & \geoschemLoC                & \geoschemlinesParsed \\
Navier    & \navierFiles                   & \navierparseOk                  & \navierLoC                  & \navierlinesParsed \\
CP        & \computationalphysicstwoFiles  & \computationalphysicstwoparseOk & \computationalphysicstwoLoC & \computationalphysicstwolinesParsed \\
\hline
\textbf{Total} & \overallFiles  & \overallparseOk & \overallLoC & \overalllinesParsed \\
\end{tabular}
\caption{Summary of software packages used for
  evaluation\label{tab:corpus}}
\vspace{-1em}
\end{table}
\begin{table}
\vspace{-1em}
\sisetup{table-format=4,table-text-alignment=right}
\footnotesize
\centering
\begin{tabular}{lS@{~~~}rS@{~~~}rSS[table-format=1]}
\hline
  & \multicolumn{2}{c}{Potential} & \multicolumn{2}{c}{Actual} & {Exact} & {Inexact}    \\
{Package}     & {\#} & \si{\percent} & {\#} & \si{\percent} \\
\hline
UM            & \umtickAssign & \SI{\umtickAssignPercent}{\percent} &
                \umtickAssignSuccess & \SI{\umtickAssignSuccessPercent}{\percent} &
                \umnumStencilLines &
                \umboundedBoth  \\
E3MG          & \ethreemgeatickAssign & \SI{\ethreemgeatickAssignPercent}{\percent} &
                \ethreemgeatickAssignSuccess & \SI{\ethreemgeatickAssignSuccessPercent}{\percent} &
                \ethreemgeanumStencilLines &
                \ethreemgeaboundedBoth \\
BLAS          & \blastickAssign & \SI{\blastickAssignPercent}{\percent} &
                \blastickAssignSuccess & \SI{\blastickAssignSuccessPercent}{\percent} &
                \blasnumStencilLines &
                \blasboundedBoth \\
Hybrid4       & \hybridfourtickAssign & \SI{\hybridfourtickAssignPercent}{\percent} &
                \hybridfourtickAssignSuccess & \SI{\hybridfourtickAssignSuccessPercent}{\percent} &
                \hybridfournumStencilLines &
                \hybridfourboundedBoth\\
GEOS-Chem     & \geoschemtickAssign & \SI{\geoschemtickAssignPercent}{\percent} &
                \geoschemtickAssignSuccess & \SI{\geoschemtickAssignSuccessPercent}{\percent} &
                \geoschemnumStencilLines &
                \geoschemboundedBoth \\
Navier        & \naviertickAssign & \SI{\naviertickAssignPercent}{\percent} &
                \naviertickAssignSuccess & \SI{\naviertickAssignPercent}{\percent} &
                \naviernumStencilLines &
                \navierboundedBoth \\
CP            & \computationalphysicstwotickAssign & \SI{\computationalphysicstwotickAssignPercent}{\percent} &
                \computationalphysicstwotickAssignSuccess & \SI{\computationalphysicstwotickAssignSuccessPercent}{\percent} &
                \computationalphysicstwonumStencilLines &
                \computationalphysicstwoboundedBoth \\
\hline
\textbf{Total}& \overalltickAssign & \SI{\overalltickAssignPercent}{\percent}  &
                \overalltickAssignSuccess & \SI{\overalltickAssignSuccessPercent}{\percent} &
                \overallnumStencilLines &
                \overallboundedBoth   
\end{tabular}
\caption{Stencil specification assignment rates\label{tab:tickAssign}}
\vspace{-1em}
\end{table}

The first two columns of Table~\ref{tab:tickAssign} show the number
of potential and actual stencils and their rate as a percentage of the
total number of successfully parsed lines of code. The ratio of
actual to potential stencils overall is thus $32\%$, \ie{}, we give
a specification to roughly a third of the potential stencil specifications.

There are a variety of reasons why we might not infer a actual specification from a potential
stencil computation: \\
\noindent 
1) \textbf{Non-subset induction variables} occur when the
induction variables on the RHS are not a subset of those in the LHS. These
cases are not stencils by our definition (Defn.~\ref{def:stencil},p.~\pageref{def:stencil}). The degenerate case of this
is to have only constant indices on the LHS. We see lots of examples
of this in loops as accumulators \eg{} computing the sum over an array; \\
\noindent
2) \textbf{Derived induction variables} where the
indexing variable (\mintinline{fortran}{x}) is derived from an
induction variable (\mintinline{fortran}{i}) as in
\mintinline{fortran}{x = len - i};  \\
\noindent
3) \textbf{Inconsistent induction dimensions} occur when
an induction variable is used to specify more than one array dimension
on the RHS or multiple induction variables are used for the same
dimension on the RHS. These are common in matrix operations such as
LU-decomposition with assignments such as
\mintinline{fortran}{a(l) = a(l) - a(m) * b(l, m)}.

 %% This example is from geos-chem/GeosRad/rrtmg_sw_spcvmc.F90:609
 %%                      pnifddir(ikl) = pnifddir(ikl) + zincflx(iw)*ztdbt(jk)
 %% ikl is a derived induction variable (ikl = rows - jk) - we can't deal with that at the moment

  %% This example is from geos-chem/GTMM/sort_pick_veg.F90
  %% DO k=1,n_veg
  %%    DO j=2,n/n_veg
  %%       a=arr(k,j)
  %%       b=ind(k,j)
  %%       DO i=j-1, 1, -1
  %%          IF (arr(k,i) >=a) exit
  %%          arr(k,i+1)=arr(k,i)
  %%          ind(k,i+1)=ind(k,i)
  %%       END DO
  %%       ! NO STENCIL - inconsistentIV
  %%       ind(k,i+1)=b
  %%       arr(k,i+1)=a
  %%    END DO
  %% END DO
  %% ind(k,j) flows into b but the LHS doesn't use j. This is a valid 'access' stencil but not a valid comonad stencil

%% From geos-chem/GTMM/loadCASAinput.F90:241
%%          ppt_mo(1,i)=sum(ppt(:,:,i))
%% If you expand the loop for the sum
%% do x=1,lenDim1
%%  do y=1,lenDim2
%%   acc += ppt(x,y,i)  ! can't be a stencil but could be an access pattern
%%  enddo
%% enddo
%% ppt_mo(1,i) = acc  ! should be reflexive(dim=3) :: ppt
%% This should be fixable before the paper deadline

  %% From blas/ssyrk.f:337
  %%            DO 210 J = 1,N
  %%                 DO 200 I = 1,J
  %%                     TEMP = ZERO
  %%                     DO 190 L = 1,K
  %%                         TEMP = TEMP + A(L,I)*A(L,J)
  %% 190                 CONTINUE
  %%                     IF (BETA.EQ.ZERO) THEN
  %%                         C(I,J) = ALPHA*TEMP  ! No stencil
  %%                     ELSE
  %%                         C(I,J) = ALPHA*TEMP + BETA*C(I,J)
  %%                     END IF
  %% 200             CONTINUE
  %% 210         CONTINUE
  %% In this case A does flow into TEMP and thus into C but its a reduction. There's an 'access' stencil above TEMP but that's all


   %% From blas/sspr2.f:231
   %%                    DO 10 I = 1,J
   %%                        AP(K) = AP(K) + X(I)*TEMP1 + Y(I)*TEMP2
   %%                        K = K + 1
   %% 10                 CONTINUE
   %% I don't think we notice that K is an induction variable in these cases

  %% From computational-physics-2/fortran90/millikan.f90:73
  %% DO I = 1, N+1
  %%   STMP = U(1,I)*U(1,I)    ! access, not a stencil
  %%   S(1) = S(1) + STMP      ! access, not a stencil
  %%   G(1) = G(1) + K(I)*STMP ! access, not a stencil
  %%   U(1,N+2) = U(1,N+2) + U(1,I)*F(I)  ! access, not a stencil
  %% END DO


%% From UM: mym_solve_simeq_lud.F90:148
%% DO m = 1, n - 1
%%   DO l = m + 1, n
%%     bvec(l) = bvec(l) - bvec(m) * amat(l, m)
%%   END DO
%% END DO
%% We just don't deal with this - Lower upper decomposition solver


If the statement meets the stencil criteria but the inference process
cannot determine an exact stencil for a statement it will instead
produce an upper (\term{atMost}) and lower (\term{atLeast}) bound. The
number of exact and inexact stencils are shown in columns three and
four of Table~\ref{tab:tickAssign}. Note that the total for ``Exact``
is higher than ``Actual`` because for some lines we produce multiple
specifications (perhaps for different array variables).
We see that our specification language is capable of precisely specifying the overwhelming majority of stencils. Most of the inexact stencils apply to some form of data copying. For example (taken from \textbf{E3MG}):
\begin{minted}{fortran}
!- stencil atLeast, readOnce, irreflexive(dims=2), (reflexive(dim=1)) :: sfda
!- stencil atMost, readOnce, (forward(depth=8, dim=2))*(reflexive(dim=1)) :: sfdt
ZZ1(I,J) = SFDT(I,J+8)
\end{minted}

\subsection{Stencil categories}

We grouped our inferred specifications together into four classes based on similar levels of complexity. These four classes account for 99.4\% of all the stencils we found in the corpus.

\textbf{All-reflexive} The vast majority (66\%) of specification are
reflexive in every dimension. These most often correspond
to point-wise transformations on data such as scaling, \eg{} from \textbf{E3MG}: \begin{minted}{fortran}
ZZ1(I,K) = .000041868*ZZ1(I,K)
\end{minted}
Arrays with this class of stencil are indexed by all the induction
variables used in the LHS without any offsets.

\textbf{Some-reflexive} specifications (24\%) consist of only reflexive terms but
leave some dimensions unspecified. These two examples are from
\textbf{GEOS-Chem} and \textbf{E3MG}: 
\begin{minted}{fortran}
leafpools(:,age_class)=leafpool(:,1)
RVM(J,I2) = VRFO(ivar,J)
\end{minted}
where for the first example \mintinline{fortran}{leafpools} contains an
implicit loop due to the range term \texttt{:}, and for the second \mintinline{fortran}{J} is
the induction variable. This stencil permits array indexing by a subset of the LHS induction variables but again without
any offsets.

\textbf{Single-action} specifications (6\%) consist of a single \term{backward},
\term{forward}, or \term{centered} region and some number of \term{reflexive}
region constants. For example, taken from \textbf{GEOS-Chem}: 
% /home/mrd45/src/corpus/geos-chem/GTMM/CasaRegridModule.F90:645
\begin{minted}[breakafter=*]{fortran}
do j=2,jm-ig
   do i=1,im
      != stencil readOnce, (backward(depth=1, dim=2)) *(reflexive(dim=1)) :: dm, q
      al(i,j) = 0.5e+0_fp*(q(i,j-1)+q(i,j)) + r3*(dm(i,j-1) - dm(i,j))
\end{minted}
% TODO: A BIT UNCLEAR
%This stencil requires a neighbourhood index including zero-offset in one dimension only. The remaining dimensions must either have no offset or not pertain to an induction variable.
These kinds of specification require zero offsets in one dimension and 
and neighbourhood offsets (from 0 to $-1$ above) in the other.
The remaining dimensions must either have no offset or not pertain to
an induction variable.

\textbf{Single-action-irreflexive} specifications (3\%) consist of a single
\term{backward}, \term{forward}, or \term{centered} irreflexive region 
and some number of reflexive region constants, \eg{}, from \textbf{GEOS-Chem}:
% /home/mrd45/src/corpus/geos-chem/GeosRad/rrtmg_lw_rtrnmc.F90:355
\begin{minted}{fortran}
do lev = nlayers, 1, -1
    ! ...
    radld = radld - radld * (atrans(lev) + &
       efclfrac(lev,igc) * (1. - atrans(lev))) + &
       gassrc + cldfmc(igc,lev) * &
       (bbdtot * atot(lev) - gassrc)
    != stencil readOnce, forward(depth=1, dim=2, irreflexive) :: cldfmc
    drad(lev-1) = drad(lev-1) + radld
\end{minted}
Note that the read from 
\mintinline{fortran}{cldfmc} on line 5 flows to line 8. Stencils of
the above kind require a neighbourhood index without a zero-offset in
one dimension only. The remaining dimensions must either have no
offset or not pertain to an induction variable.

The remaining specification shapes (less than 1\%) consisted
primarily of multiple \term{forward}, \term{backward}, or
\term{centered} dimensions. We note that only $\sim$0.4\% of inferred
stencil specifications required use of the \term{+} operator. Despite their low frequency these stencils are arguably the most important since they represent more complicated code and thus greater potential for programming errors.

\subsection{Verification case study 1: 2-D Jacobi iteration}

One relatively basic example of a stencil computation is two-dimensional
Jacobi iteration that repeatedly goes through each cell in a matrix
and computes the average value of the four adjacent cells. The kernel
can be expressed in a line of Fortran code:
\begin{minted}{fortran}
  a(i,j) = (a(i-1,j)+a(i+1,j)+a(i,j+1)+a(i,j-1))/4
\end{minted}
and CamFort is able to infer a precise specification for this:
\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil reflexive(dim=1)*centered(depth=1,dim=2,irreflexive)+reflexive(dim=2)*centered(depth=1,dim=1,irreflexive)
\end{minted}
assigned to \term{a}. 
We then tested the error-detecting ability of our approach by 
generating a family of 6,561 Jacobi iteration programs by perturbing
the indices used in the following manner: each access of the array was
templated as \mintinline{fortran}{a(i+ki,j+kj)} and then all possible
combinations of \mintinline{fortran}{ki} and \mintinline{fortran}{kj}
were drawn from the set $\{-1,0,1\}$. There are four uses of
\mintinline{fortran}{ki} and four of \mintinline{fortran}{kj}, hence
$3^8=6561$ possible perturbations of this kind. This particular setup
tests the class of errors in which the programmer typed an incorrect
number but at least got the ordering of the indices correct, although
CamFort would also detect a mixup of variables in this case as well.

We assigned the specification inferred above to the generated Jacobi
stencils programs. CamFort checked all 6,561 programs against this specification and found that only 24 of them were
valid implementations of the stencil specification. This was the
expected result as there are $4!$ possible correct permutations
of the four terms in the kernel. All of the other programs were found
to violate the specification in some way. Another way to test the
programs is through visual examination of their output in graphical
format. Figure~\ref{fig:jacobi} shows some of the results of running
the Jacobi iteration programs, rendered into image files. All of the
correct variants emitted images indistinguishable from
Figure~\ref{fig:jacobicorrect}, while all of the incorrect variants
had wildly different image outputs. Both the ``visual test'' and a
byte-by-byte comparison showed results that completely concurred with
the results of the CamFort test.

\begin{figure}[t]
  \centering
  %\subcaptionbox{\label{fig:jacobicorrect}}{\includegraphics[width=0.1\textwidth]{jacobi-correct.png}}
  %\subcaptionbox{}{\includegraphics[width=0.1\textwidth]{jacobi-incorrect1.png}}
  %\subcaptionbox{}{\includegraphics[width=0.1\textwidth]{jacobi-incorrect2.png}}
  %\subcaptionbox{}{\includegraphics[width=0.1\textwidth]{jacobi-incorrect3.png}}
  \subfigure[]{\label{fig:jacobicorrect}\includegraphics[width=0.1\textwidth]{jacobi-correct.png}}\;\;
  \subfigure[]{\includegraphics[width=0.1\textwidth]{jacobi-incorrect1.png}}\;\;
  \subfigure[]{\includegraphics[width=0.1\textwidth]{jacobi-incorrect2.png}}\;\;
  \subfigure[]{\includegraphics[width=0.1\textwidth]{jacobi-incorrect3.png}}
  \caption{Perturbations of Jacobi code; \subref{fig:jacobicorrect} is reference output.}
  \label{fig:jacobi}
  \vspace{-1em}
\end{figure}

\subsection{Verification case study 2: Turbulence calculation}

\begin{figure}[t]\begin{minted}[fontsize=\scriptsize,breakindent=0em,linenos=false,xleftmargin=0em,breakafter=)]{fortran}
!=stencil readOnce,(forward(depth=1,dim=3,irreflexive))*(backward(depth=1,dim=1))*(backward(depth=1,dim=2))+(forward(depth=1,dim=3))*(backward(depth=1,dim=1))*(reflexive(dim=2))+(forward(depth=1,dim=3))*(backward(depth=1,dim=1,irreflexive))*(backward(depth=1,dim=2,irreflexive))+(forward(depth=1,dim=3))*(backward(depth=1,dim=2))*(reflexive(dim=1))+(backward(depth=1,dim=1))*(backward(depth=1,dim=2,irreflexive))*(reflexive(dim=3))+(backward(depth=1,dim=1,irreflexive))*(backward(depth=1,dim=2))*(reflexive(dim=3))::x
\end{minted}
\caption{A complex specification inferred from
  \textbf{Unified Model}\label{fig:smagorinsky}}
\vspace{-1em}
\end{figure}

\noindent
The Unified Model has an implementation of the Smagorinsky
subgrid-scale model for calculating turbulence on which our
inference yields 39 specs from 340 lines of code. We show
one example in Figure~\ref{fig:smagorinsky}. 
This specifies the access pattern to a 3-dimensional array (which we have renamed to be called \texttt{x}). The array is accessed 8 times in the computation. We tried introducing indexing errors by changing the offset in one dimension of one of the references to \texttt{x}. For example changing \mintinline{fortran}{x(i+1,j,k)} to \mintinline{fortran}{x(i,j,k)} or \mintinline{fortran}{x(i-1,j,k)}.

There are 48 possible errors of this type of which only 6 were not 
detected by the checker. The reason is that the inferred
specification describes a family of access patterns. Some offset errors
produce a stencil computation that belongs to the same family and goes
undetected.
One of the reasons this specification can catch many offset errors is that it is
a \texttt{readOnce} specification. This prevents offset errors leading to
duplicate access patterns be caught even if the resulting set of accesses are
part of the same family.
% /um/trunk/src/atmosphere/diffusion_and_filtering/turb_smagorinsky.F90
% Tried introducing indexing errors replacing one of the indices of cx_rho_instance with -1,0,+1
% 42 cases were caught
% 6 cases were not caught
\section{Related work and conclusions}
\label{sec:discussion}

Various prior approaches to specifying and verifying the behaviour
of stencils have been based on fine-grained representations of the
code. These essentially duplicate the indexing scheme of a stencil
computation in their specifications.

\citet{kamil2016verified} propose a technique they call
\emph{verified lifting} for mapping low-level, possibly
greatly optimised, stencil computations into a high-level
predicate language using inductive program synthesis.
The aim is that the high-level abstract specifications can
be automatically translated into high-performance DSLs. Compared to our approach,
their specification language is more fine grained, capturing
the exact indexing pattern of a stencil. For example, the following
is a post-condition generated by their
compiler \textsc{stng} from a Fortran stencil computation~\cite [p.3]{kamil2016verified}:
%
\begin{align*}
& \textit{post}(\texttt{a}, \texttt{b}) \equiv \forall \texttt{imin}+1
\leq \texttt{i} \leq \texttt{imax}, \texttt{jmin} \leq \texttt{j} \leq
\texttt{jmax} \\
& \qquad \texttt{a}(\texttt{i},\texttt{j}) =
\texttt{b}(\texttt{i}-1,\texttt{j}) + \texttt{b}(\texttt{i},\texttt{j})
\end{align*}
%
Notably, the bounds of the stencil and the exact indexing pattern
are captured. Our approach aims to be much more abstract, to
facilitate human reasoning, and avoid low-level lexical
errors. However, \textsc{stng} specifications are generated, \ie{},
are never written by a programmer, avoiding this
problem. Their inductive program synthesis approach allows
specifications to extracted even from optimised and unrolled code. For
example, the above post condition is generated from the code~\cite [p.3]{kamil2016verified}:
%
\begin{minted}{fortran}
do j=jmin, jmax
    t = b(imin, j)
    do i=imin+1,imax
        q = b(i, j);  a(i, j) = q + t; t = q
    end do
end do
\end{minted}
%
Thus, \textsc{stng} can understand cross-loop data-dependencies
in order to assign the above post-condition. CamFort is not currently
able to ascribe a specification in the above case as the use of
\texttt{t} on line 4 maps only to the definition on line 2, and not to
that on line 4. Extending our approach to follow loop-carried dependencies is
future work. An alternate approach for us would be to build on top of
the work of Kamil~\emph{et al.} by inferring our specifications from
\textsc{stng} (as an intermediate step).

% GPGPU
Our work has some similarities with efforts to verify kernels
written for General-Purpose Graphics Processing Unit (GPGPU)
programming, such as in \citet{Blom:2014:SoCP}. Stencils are a form of
kernel, and GPGPU programming can be viewed as a massively parallel
method of transforming a large matrix. However, that work focuses
mainly on the synchronisation of such kernels and the avoidance of
data races, while we are interested in the correctness of stencils
embedded within a more typical general-purpose programming
language. Other work on GPGPU computation, such as
\citet{Zhang:2012:CGO}, has focused primarily on generating
optimised code based on relatively simple specifications: to
provide performance while keeping the programmer's effort within
reason.

% Sketching Stencils
\citet{Solar-Lezama:2007:PLDI} give specifications of stencils using
unoptimised ``reference'' stencils, coupled with partial
implementations of stencils, which are then completed by a code
generation tool. These kinds of specifications are just simple
implementations, so this tool is useful for hand-written, optimised
stencils. The primary purpose of this tool is optimisation rather than
correctness, and the language of specification is much different and
more elaborate than we envision for our system.

% Pochoir
\citet{Tang:2011:SPAA} define a specification language for writing
stencils embedded in C++ (with Cilk extensions) that are then compiled
into fast parallel programs based on trapezoidal decompositions with
hyperspace cuts. The Pochoir specification language is used for
describing the kernel, boundary conditions and shape of the
stencil. Programs are first compiled in C++ with a template library
that checks whether the annotations are used correctly, and then a
Pochoir preprocessor may be applied to generate the high-performance
parallel versions using Cilk.  Pochoir
is aimed primarily at assisting programmers who may be reluctant to
implement the high-performance tricky cache-oblivious
``hypertrapezoidal'' algorithms for stencils. 
%that are significantly faster than the typical looping implementations
%of stencil computations.
Like much of the related work, the main goal 
is optimisation rather than verifying program correctness.

By contrast, the work of \citet{Abe:2013:IPDPSW} has looked at the
correctness problem explicitly by bringing a form of model-checking to
verify certain stencil computations. This is in the context of
decomposing stencils for parallel computation on multiple processors
 in partitioned global address
space languages. %These are scenarios where an array is divided into
%subarrays on multiple processors but each has the ability to access
%the others' memory. The authors avoid the state explosion dilemma of
%model-checking by relying upon the fact that accesses to the
%``boundary elements'' will require a different method by virtue of the
%non-locality of that memory. Since this access is performed in a
%different manner, those can be identified automatically by static
%analysis. To achieve this, 
The authors have designed a new language to
be used for writing stencil computations. Much of the specification
effort goes towards describing the nuts and bolts of distributing the
computation over multiple processors. The code for the stencil kernel
is generated from a relatively high-level specification. This approach
differs from CamFort because we are interested in integrating directly
into existing, legacy codebases and long-established languages such as
older versions of Fortran. We infer stencil specifications from
Fortran code and check annotations on stencil computations within
Fortran code.

%There are many DSLs for stencil computation aimed at either
%performance or verification, or both. Many eliminate out-of-bounds
%errors, \eg{},~\citet{DBLP:journals/corr/abs-1109-0777}.

\paragraph{Conclusion and future work}

There is an increasing awareness
of the need for verification techniques in
science~\cite{post2005computational,oberkampf2010verification,orchard2014computational}.
Our specification language is an approach in this direction, providing
a system of lightweight specification for numerical code.
Compared to other specification approaches (discussed above), our language is novel in that it does
not aim to reify indexing in the specification, but instead
provides abstract spatial descriptions which capture a large number
of common patterns. %Our tool is useful for both detecting
%errors and for specifying program behaviour to future-proof code and ease
% maintenance. 

%To increase the likelihood of impact, we 
%integrate smoothly with existing practices, providing 
%specifications as comments and specification synthesis
%specifications in the the tool.

We evaluated our approach on top of CamFort, an open-source analysis
tool for Fortran
programs, running the inference process over a corpus of 1.1
million lines of Fortran code. 
 Our motivation for this work was to
provide an intermediate specification language to allow scientists to
verify numerical computations.  Our evaluation showed that relatively
simple stencil computations are the norm comprising mainly reflexive region constants which
are less likely to give rise to programming errors.  However, around
10\% of stencils covered more complicated program structures for which
indexing errors are much more plausible. In the more detailed cases,
with larger specifications, the importance and impact of such
specifications grows.  We showed two examples of more complicated
stencils, for which CamFort was able to detect a significant majority
of possible indexing errors in our case studies.

Our definition of a stencil computation meant that we generated no
specification for a large number of iterated array accesses in the
corpus, such as stencils that incorporates reductions. For
future work, we will be looking into expanding the flexibility of 
our inference approach to more of these examples. Furthermore, our specification
language can be used more flexibly to give descriptions of data access
patterns in any context, not just within a stencil.

%\footnotetext{\url{https://github.com/camfort/camfort}}
\bibliography{references}

\end{document}

%%  LocalWords:  refactoring affine parameterised irreflexive atMost
%%  LocalWords:  centered readOnce atLeast discretisation Equational
%%  LocalWords:  equational disjunction denotational dimensionality
%%  LocalWords:  interprocedural Fortran CamFort preprocessor
%%  LocalWords:  committers
