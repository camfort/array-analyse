\documentclass[9pt]{sigplanconf}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{graphics}
\usepackage{fancyvrb}
\usepackage{subfigure}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{multirow}

\CustomVerbatimEnvironment{SpecVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.65cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98}
\CustomVerbatimEnvironment{ExmVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.65cm,
xrightmargin=0.2cm,baselinestretch=0.98,numbers=left}
\CustomVerbatimEnvironment{IVerbatim}{Verbatim}{fontsize=\relsize{-1},xleftmargin=0.65cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98}


\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\definecolor{darkorange}{rgb}{0.5,0.2,0.0}
\definecolor{marco}{rgb}{0.0,0.3,0.5}
\definecolor{gray}{rgb}{0.2,0.2,0.2}

\newcommand{\bn}{\mathbb{N}}

\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}

\newcounter{block}

\newtheorem{lemma}[block]{Lemma}
\newtheorem{proposition}[block]{Proposition}
%\newtheorem{definition}[block]{Definisssstion}

\theoremstyle{definition}

\newtheorem{theorem}[block]{Theorem}
\newtheorem{remark}[block]{Remark}
\newtheorem{example}[block]{Example}
\newtheorem{definition}[block]{Definition}

% Writing macros
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\newcommand{\dimId}{\texttt{dim}}

% Semantics related
\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

% Syntax macros
\newcommand{\nonterm}[1]{\textit{#1}}
\newcommand{\term}[1]{\texttt{#1}}

\newcommand{\stenFwd}[2]{\texttt{forward} \, (\texttt{depth=}#1,
  \texttt{dim=}#2)}
\newcommand{\stenBwd}[2]{\texttt{backward} \, (\texttt{depth=}#1,
  \texttt{dim=}#2)}
\newcommand{\stenCen}[2]{\texttt{centered} \, (\texttt{depth=}#1,
  \texttt{dim=}#2)}

\title{Time and space specifications for stencils}
\authorinfo{}{}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\bibliographystyle{plain}

\section{Introduction}

\emph{Stencils} are a ubiquitous programming pattern, common in
scientific and numerical computing applications. Informally, a stencil
computation computes an array value, where the value at each index $i$ of
this array is calculated from a \emph{neighbourhood} of values around $i$ in
some input array(s), \eg{}, the Game of Life, convolutions in image
processing, approximations to differential equations. For example, the
following iteratively computes the one-dimensional discrete Laplace
transform (an approximation to a derivative): 
%
\begin{ExmVerbatim}
do iter = 0, itermax
   do i = 1, (n-1)
      b(i) = a(i-1) - 2*a(i) + a(i+1)
   a = b
\end{ExmVerbatim}
%
Line 3 is the core of the stencil computation, calculating
the value at \texttt{b(i)} from a neighbourhood of elements about
\texttt{a(i)}. Line 4 swaps
\texttt{a} and \texttt{b} between iterations, where \texttt{b} becomes the
input for the next iteration. (Note, we use the parentheses syntax
\texttt{( )} for
array subscripts rather than the bracket syntax \texttt{[ ]}. 

%This stencil computation exhibits statically decideable
%spatial and temporal relationships between $\texttt{a}$ and
%$\texttt{b}$.
In this simple example, the dependencies between between \texttt{a}
and \texttt{b} form a simple spatial relationship which is easily
understood. This spatial relationship determines other aspects of the
program and its efficient implementation: how much ``boundary'' is
needed for the array, the most cache-efficient layout in memory,
the partitioning shape for parallel implementations. 

More complex stencil computations can be much harder to understand and
subsequently more prone to error. For example,
Figure~\ref{ref:navier-stokes-fragment} shows three lines from a
Navier-Stokes fluid simulator in which two arrays are read from with
different data access patterns, across two dimensions. The interaction
is much harder to understand, with the potential for the developer to
accidentally introduce an error via simple textual mistakes, for
example writing $\texttt{(i-1,j)}$ instead of $\texttt{(i+1,j)}$.

In this work, we introduce a simple specification language for the
spatial and temporal properties of stencil comptuations. The
specifications abstract over the fine grained detail of stencil access
patterns.  In practise, most stencil computations have a regular shape
that can be described simply and abstractly, with a small set of
coarse-grained descriptions. In the case of our first Laplace example,
our inference procedure provides the specification:
%
\begin{SpecVerbatim}
!=  stencil centered (depth=1, dim=1) :: a
!=  stencil dependency a, mutual       :: b
\end{SpecVerbatim}
%
The first line explains that \texttt{a} is read from with a
symmetrical stencil pattern (``centered'') to a depth of one in each
direction in its first (and only) dimension.  The second line explains
the temporal relationship between \texttt{b} and \texttt{a}: that
previous time step for \texttt{b} is actually provided by \texttt{a},
and vice versa. This is explained as a mutual dependence between
\texttt{a} and \texttt{b}. In the case of the Navier-Stokes example of
Figure~\ref{ref:navier-stokes-fragment}, its inferred specification is shown
in Figure~\ref{ref:navier-stokes-fragment}(b). The 
specification explains that, over the whole fragment, \texttt{u} is
read from with a centered pattern to depth of 1 in both dimensions
(this is known as the \emph{five point stencil}) and \texttt{v}
is read from in a neighbourhood bounded by forward to depth of $1$ in
the first dimension and backward to a depth of $1$ in the second
dimension. These can drawn pictorially as follows where the horizontal
dimensions is \text{dim=1} and the vertical is \texttt{dim=2}:

\begin{center}
\begin{tikzpicture}
\node at (1.25,1.22) {i, j};
\draw (1,1) rectangle (1.5,1.5);
\draw (1.5,1) rectangle (2,1.5);
\draw (1,0.5) rectangle (1.5,1);
\draw (0.5,1) rectangle (1,1.5);
\draw (1,1.5) rectangle (1.5,2);
%
\node at (4.25,1.22) {i, j};
\draw (4,1) rectangle (4.5,1.5);
\draw (4.5,1) rectangle (5,1.5);
\draw (4.5,1.5) rectangle (5,2);
\draw (4,1.5) rectangle (4.5,2);
\end{tikzpicture}
\end{center}


In this paper, we make the following contributions:
%
\begin{itemize}
\item we introduce a specification language for
stencil computations that captures many common forms
of data access pattern, both spatial and temporal (Section~\ref{sec:lang});
\item we detail inference and checking
algorithms for stencil specifications (Section~\ref{sec:analysis});
\item we evaluate our implementation of the approach
in the CamFort tool for Fortran verification, studying
a number of example programs to assess the usefulness
of this approach.
\dnote{insert results here}
\end{itemize}
%

\begin{figure}
\begin{ExmVerbatim}[firstnumber=20]
du2dx = ((u(i,j)+u(i+1,j))*(u(i,j)+u(i+1,j))+
    gamma*abs(u(i,j)+u(i+1,j))*(u(i,j)-u(i+1,j))-
    (u(i-1,j)+u(i,j))*(u(i-1,j)+u(i,j))-
    gamma*abs(u(i-1,j)+u(i,j))*(u(i-1,j)-u(i,j)))
    /(4.0*delx)

duvdy = ((v(i,j)+v(i+1,j))*(u(i,j)+u(i,j+1))+
   gamma*abs(v(i,j)+v(i+1,j))*(u(i,j)-u(i,j+1))-
   (v(i,j-1)+v(i+1,j-1))*(u(i,j-1)+u(i,j))-
   gamma*abs(v(i,j-1)+v(i+1,j-1))*(u(i,j-1)-u(i,j)))
   /(4.0*dely)

laplu = (u(i+1,j)-2.0*u(i,j)+u(i-1,j))/delx/delx+
          (u(i,j+1)-2.0*u(i,j)+u(i,j-1))/dely/dely
\end{ExmVerbatim}
(a). Excerpt from the Fortran code,
showing highly-detailed stencil computations. \\

%\begin{SpecVerbatim}[xleftmargin=0.1cm]
%20-24  u: centered depth=1 dim=1
%6-30  u: centered depth=1 dim=2
%      v: forward depth=1 dim=1, backward depth=1 dim=1
%32-33  u: centered depth=1 dim=1,2
%\end{SpecVerbatim}

\begin{SpecVerbatim}[xleftmargin=0.3cm]
!=   stencil centered(depth=1, dim=1)
           + centered(depth=1, dim=2) :: u

!=   stencil forward(depth=1, dim=1)
           * backward(depth=1, dim=2) :: v
\end{SpecVerbatim}
(b). Inferred stencil specification from CamFort
\caption{Fragment of Navier-Stokes fluid simulator and its specification}
\label{ref:navier-stokes-fragment}
\end{figure}

\section{Stencil specification language}
\label{sec:lang}

Our specification system is based on the observation
that most forms of array access in numberical code have
a fixed, statically-determined access pattern. For example, the
``\emph{five-point stencil}'' on a two-dimensional array reads from array
indices $(i, j)$, $(i-1, j)$, $(i+1, j)$, $(i, j-1)$, and $(i, j+1)$
for all $i, j$ within the inner boundary of the array (to avoid
out-of-bounds access at the edges). We revisit this hypothesis
in Section~\ref{sec:evaluation} where the inference of
such regular stencil patterns on a corpus of numerical programs (both
small and large). We found that indeed \dnote{..}.

We outline the specification language here. Section~\ref{sec:syntax}
oultines the syntax. Section~\ref{sec:semantics} defines its semantics
via a simple multi-set interpretation over indices. Section~\ref{sec:eqs} provides an
equational theory for specifications via relation ($\equiv$) and a
theory of approximation via relation ($<:$). These equations are then
proven sound with respecto the multi-set semantics of Section~\ref{sec:semantics}.

\subsection{Syntax}
\label{sec:syntax}

Figure~\ref{fig:syntax}
gives the syntax, which we introduces in stages below.
The top-level is given by the \textit{spec} production
which splits into either a \textit{spatial} specification or
a \textit{temporal specification}.
%%

\begin{figure}[t]
\begin{align*}
\def\arraystretch{1.2}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{\mathbb{D}}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec}
  \\
\nonterm{regionDec} ::= &  \texttt{region} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\
\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}   \\[1em]
\nonterm{spatial} ::= & [\nonterm{mod}] \;
                       [\nonterm{approxMod},] \; [\nonterm{region}] \\
\nonterm{mod} ::= & [\nonterm{modR},] \; [\nonterm{modRefl},] \; [\nonterm{modIrefl},] \\
\nonterm{modR} ::= &
 \term{readOnce} \\
\nonterm{modRefl} ::= & \term{reflexive}, \; \term{dims=}\dimTy \{\term{,} \; \dimTy\} \\
\nonterm{modIrrefl} ::= & \term{irreflexive}, \; \term{dims=}\dimTy \{\term{,}
          \dimTy\}\\
\nonterm{approxMod} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \term{forward}, \term{depth=}\mathbb{N}, \term{dim=}\dimTy  \\
\mid \; & \term{backward}, \term{depth=}\mathbb{N}, \term{dim=}\dimTy \\
\mid \; & \term{centered}, \term{depth=}\mathbb{N}, \term{dim=}\dimTy \\
\mid \; & \nonterm{region} \; \term{+} \; \nonterm{region} \\
\mid \; & \nonterm{region} \; \term{*} \; \nonterm{region} \\
\mid \; & \nonterm{rvar}  \\[0.5em]
\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \})
  \\[0.5em]
\dimTy ::= \; & \mathbb{N}_{>0} \\
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\end{figure}

\paragraph{Spatial specifications}


\paragraph{Temporal specifications}



\subsection{Equational theory and approximations}
\label{sec:eqs}

Figure~\ref{fig:equations}

\begin{figure}
\begin{align*}
\hspace{-1em}
\setlength{\arraycolsep}{0.05em}
\begin{array}{c}
\framebox{$\overline{\texttt{v} : S} \equiv \overline{\texttt{u} : T}$} \\[1em]
\begin{array}{rl}
(\textsc{coalesceF}) \;\; & (\texttt{a} : \texttt{fwd} \;
                       \texttt{dims}=ds \; \texttt{depth}=n; \\
&  \;\, \texttt{a} :  \texttt{fwd} \; \texttt{dims}=ds \; \texttt{depth}=n+1)\\
\equiv \; & \texttt{a} :  \texttt{fwd} \; \texttt{depth}=n+1,
         \texttt{dims}=ds \\[0.75em]
(\textsc{coalesceB}) \;\; & (\texttt{a} : \texttt{bwd} \;
                       \texttt{dims}=ds \; \texttt{depth}=n; \\
&  \;\, \texttt{a} :  \texttt{bwd} \; \texttt{dims}=ds \; \texttt{depth}=n+1) \\
\equiv \; & \texttt{a} :  \texttt{bwd} \; \texttt{depth}=n+1,
         \texttt{dims}=ds \\[0.75em]
(\textsc{idem}) \;\; & (\texttt{a} : S; \texttt{a} : S) \equiv (\texttt{a}
                  : S)
\end{array} \\ \\
\framebox{$\texttt{v} : S \equiv \texttt{v'} : S'$} \\[1em]
\begin{array}{ll}
(\texttt{a} : \; \texttt{bwd} \; \texttt{depth=1\{b\}} \;
  \texttt{dim=t})
\, & \equiv \,
(\texttt{b} : \; \texttt{bwd} \; \texttt{depth=1\{a\}} \;
  \texttt{dim=t})
\\
(\texttt{a} : \; \texttt{fwd} \; \texttt{depth=1\{b\}}\;
  \texttt{dim=t})
\, & \equiv \,
(\texttt{b} : \; \texttt{fwd} \; \texttt{depth=1\{a\}} \;
  \texttt{dim=t})
\end{array}
\\ \\
\framebox{$S \equiv S'$} \\[0.75em]
\begin{array}{ll}
(a : \texttt{read-once} \; S) \; & \equiv \; (a : \texttt{read-once} \;\,
  \texttt{read-once} \; \, S)
\end{array}
\end{array}
\end{align*}
\caption{Equations on specifications}
\label{fig:equations}
\end{figure}


\begin{theorem}[Soundness]
\[
\overline{\texttt{v} : S}\equiv \overline{\texttt{u} : T}
\; \Rightarrow \;
\interp{\overline{\texttt{v} : S}} = \interp{\overline{\texttt{u} : T}}
\]
\end{theorem}

\paragraph{Proof} (see Appendix)


\subsubsection{Safety and sub-specifications}

Figure~\ref{fig:inequations}

\begin{figure}[t]
{\framebox{
\begin{minipage}{0.88\linewidth}
\begin{align*}
\hspace{-0.7em}
\begin{array}{c}
\dfrac{}{S <: S}(\textsc{refl}) \qquad \dfrac{R <: S \quad S <: T}{R <:
  T}(\textsc{trans}) \\[1.5em]
\dfrac{}{S <: \; \texttt{unspecified dims=}ds}(\top)
\\[1.5em]
\dfrac{}{\texttt{read-once} \, S <: S}(\textsc{rep})
\\[1.5em]
\setlength{\arraycolsep}{0.1em}
\dfrac{\hspace{3em} ds \subseteq es \; \wedge \; n \leq m \hspace{3em}}
{\begin{array}{rl}
\texttt{fwd} \; \texttt{depth=}n \; \texttt{dim=}ds & <: \texttt{fwd} \;
  \texttt{depth=}m \; \texttt{dim=}es
%& \;\, ds \subseteq es \wedge n \leq m
\\
\wedge \; \texttt{bwd} \; \texttt{depth=}n \; \texttt{dim=}ds & <: \texttt{bwd} \;
  \texttt{depth=}m \; \texttt{dim=}es
%& \;\, ds \subseteq es \wedge n \leq m
\\
\wedge \; \texttt{fwd} \; \texttt{depth=}n \; \texttt{dim=}ds & <: \texttt{sym} \;
  \texttt{depth=}m \; \texttt{dim=}es
%& \;\, ds \subseteq es \wedge n \leq m
\\
\wedge \; \texttt{bwd} \; \texttt{depth=}n \; \texttt{dim=}ds & <: \texttt{sym} \;
  \texttt{depth=}m \; \texttt{dim=}es
\end{array}}
%{\footnotesize{(\textsc{cover})}}
%\hspace{-0.1em}
\end{array}
\end{align*}
\end{minipage}}}
\caption{Definition of sub-specification relation}
\label{fig:inequations}
\end{figure}


\begin{theorem}[Soundness]
\[
\overline{\texttt{v} : S} <: \overline{\texttt{u} : T}
\; \Rightarrow \;
\interp{\overline{\texttt{v} : S}} \subseteq \interp{\overline{\texttt{u} : T}}
\]
\end{theorem}

\paragraph{Proof} (see Appendix)


\section{Semantics of specifications; a model}
\label{sec:semantics}

\newcommand{\relix}{(\mathbb{Z}_\bot)^\mathbb{D}}

We give a model of our specifications which explains
the range of indices which correspond to the specifications.
The model is based on multi-sets since array indices my be repeated
in an expression.

Figure~\ref{fig:model} describes the model in terms of
an interpretation function $\interp{-}$ which maps specifications
to multisets of relative indices.

\begin{definition}Relative indices are drawn
from $(\mathbb{Z}_{\bot})^{\mathbb{D}}$, essentially an infinite
tuple of offsets. For example, $(i, j+1)$ corresponds to
the relative index $(0, 1, \bot, \bot, \ldots)$
\end{definition}

The main interpretation function is overloaded on lists of
variable-spec pairs $\interp{\overline{v : S}}$,
returning multisets of variable-relative-index pairs. This provides
the top-level definition of the model, with $\interp{-}$ overloaded
on $S$, $\interp{S}$ mqpping to multisets of
relative indices not associated to an array avariable.

\begin{figure}
\input{model.tex}
%\textit{$a^m \in A$ means there are $n$ copies of $a$ in
%  the multi-set $A$}
\caption{Multi-set model of specifications}
\label{fig:model}
\end{figure}


\section{Examples and common patterns}

% Implicit vs explicit differentiation methods
% (forward implicit needs 'solver')
% backward - Euler
% runge-kutta 2nd-order

\begin{example}[FTCS (Forward time, centered space)]

  Otherwise known as the \emph{explicit method}, is a common
  pattern since it tends to be more efficient than other approches
  (see BTCS and CTCS below). However, its disadvantage is that it is
  unstable if the resolution is not well chosen.

\begin{ExmVerbatim}
b(x) = a(x) + r*(a(x-1) - 2*a(x) + a(x+1))
\end{ExmVerbatim}
%
For this statement, the inference provides the specification:
%
\begin{SpecVerbatim}
!=  stencil centered, depth=1, dim=0 :: a
\end{SpecVerbatim}



\end{example}

\paragraph{BTCS (Backward time, centered space) -- implicit method}

\paragraph{CTCS (Centered time, centered space) - Crank-Nicolson method}

\section{Inference, checking, and synthesis}
\label{sec:analysis}

\mnote{Few cases that we might like to consider (there are examples
    of each in \#camfort-main Slack channel):
  \begin{itemize}
    \item Matrix operator overloading $a + b$, where both are arrays
    \item Scalar operator overloading $a + b$, where a is an array b is a
      scalar. $b$ is added to all.
    \item Sliding. $a = b$ where the dimensionsare $a(1:10)$, $b(2:11)$,
      so the assignment causes shifting.
  \end{itemize}
}

\noindent
We briefly sketch the algorithms for inferring and checking
specifications and for synthesising programs from specifications.
Checking and synthesis use the set-based semantic model of
Section~\ref{sec:semantics}. 

% SYNTAX OPERATIONS AND PREDICATES
\newcommand{\neigh}{\textsf{neigh}}
\newcommand{\arrayTy}{\textsf{array}}
\newcommand{\rhsExp}{\textsf{rhsExp}}
\newcommand{\var}{\textsf{var}}

%% VECTOR NOTATIONS
\newcommand{\vect}[1]{\textbf{#1}}
\newcommand{\vtwo}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}$#1$\\$#2$\end{array}\right]}
\newcommand{\stwo}[4]
%{\vtwo{#1}{#2}\!\vtwo{#3}{#4}}
{\setlength{\arraycolsep}{0.1em}
\left[\begin{array}{rr}$#1$ & $#3$\\$#2$ & $#4$\end{array}\right]}

%% OPERATIONS ON SPANS and VECTORS 
\newcommand{\containedin}{\sqsubseteq}

\renewcommand*{\arraystretch}{0.8}
\paragraph{Basic syntax definitions} In the following, $v$
  ranges over variables, $s$ over statements, and $e$ over expressions
  (which may be impure).  By ``variable'', we mean in the imperative
  sense (\ie{}, named binders to memory cells) instead of mathematical
  variables. The function \rhsExp{} maps statements to a set of
  expressions which occur in right-hand positions (\ie{}, not the
  target of an assignment). The function \var{} maps expressions to a
  set of the variables used in right-hand positions. 

\begin{definition}[Standard: base induction variable]
An integer variable \textit{i} is a \emph{base induction variable} 
within the scope of a ``for'' loop (or equivalent for the target
language, \eg{}, \texttt{do} in Fortan for our implementation) if it
is the control variable of the loop, incremented by $1$ per
iteration. 
\end{definition}

\begin{definition}[Standard: array subscript]
An \emph{array subscript} is an expression index an array, which in
our abstract we write as $v(\bar{e})$ where $\bar{e}$ is shorthand for
a syntactic list of indexing expressions. 
\end{definition}

\begin{definition}[Neighbourhood index]
An array subscript $e$ is a \emph{neighbourhood index} if,
for an induction variable $i$, then $e \equiv i + a$ or $e \equiv i - a$
where $a$ is a constant of integer type. The relation $\equiv$ identifies terms
up-to commutativity of $+$ and the inverse
relation of $+$ and $-$ (\eg{}, $(-b) + i \equiv i - b$).
In the following, we classify neighbourhood indices 
using the predicate \neigh{}.
\end{definition}

\subsection{Inference}

We demonstate the main steps of the inference procedure over the
following example program which computes the mean value 
of a five-point stencil at each index of the input array:
%%
\begin{ExmVerbatim}
do i = 1, (n-1)
   do j = 1, (m-1)
      x       = a(i-1, j) + a(i+1, j) 
      y       = a(i, j-1) + a(i, j+1)
      b(i, j) = (a(i, j) + x + y) / 5.0
   end do
end do
\end{ExmVerbatim}
%%
\paragraph{Step 1: Standard control and dataflow analyses}
The inference relies on some standard program analyses, computed
before the main inference procedure:
%
\begin{enumerate}
\item basic blocks (CFG);
\item induction variables per basic block;
\item (interprocedural) dataflow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathsf{flowTo}$ is used, implicitly parameterised by this graph,  
  mapping an expression to the set of all expressions
  with forwards dataflow to this expression, based on the transitive
  closure of the flows graph);
\item type information per variable, where we use the predicate
\arrayTy{} to classify variables of array type. 
\end{enumerate}
%

\paragraph{Step 2: Data-access analysis}

For each assignment statement whose left-hand side is an array
subscript on neighbourhood indices, a finite map is computed which
maps array variables to a set of vectors representing array
subscripts.  This finite map contains all array subscript expressions
which flow to this statment. More formally, a function
$\textsf{analyse}$ is applied to each statement in a program with the
following clause:
%
\begin{align*}
\begin{array}{lr}
\textsf{analyse}(v(\overline{e_1}) = e_2)
 := \qquad\qquad & \textit{where} \; \neigh(\overline{e_1}) \wedge \arrayTy(v)  \\[0.3em]
\multicolumn{2}{l}{\qquad \bigcup\{v' \mapsto \{\textsf{convert}(\bar{e})\} \mid v'(\bar{e}) \leftarrow \mathsf{flowsTo}(e_2),
  \arrayTy(v')\}}
\end{array}
\end{align*}
%
That is, we focus on assignments to an array subscript where each
index indexing expression in $\bar{e}$ is a neighbourhood index.  For
all array subscripts that flow to the right-hand side of this
statement, a finite map is constructed from each array variable
in this flow set to a representation of the subscripts, computed
with \textsf{convert}.

The \textsf{convert} function maps subscripts to a column vector
representation with values drawn from $\mathbb{Z}_\top = \mathbb{Z} \cup \{\top\}$
where $\mathbb{Z}$ represents the offset of a neighbourhood index
and $\top$ represents any non-neighbourhood subscripts, defined:
%
\begin{align*}
& \textsf{convert}((e_1, \ldots, e_n)) = [\textsf{conv}(e_1), \ldots,
  \textsf{conv}(e_n)] \\
& \textsf{conv}(e) \begin{cases}
\pm a & \neigh(e) \wedge \, e \equiv i \pm a \\
\top & \textit{otherwise} 
\end{cases} 
\end{align*}
%
For our example, the \textsf{analyse} function matches on
line 5, with the following set for $\textsf{flowTo}(a(i, j) + x +
  y)$:
%
\begin{align*}
\{\texttt{a(i-1, j)}, \texttt{a(i+1, j)}, \texttt{a(i, j-1)},
  \texttt{a(i, j+1)}, \texttt{a(i, j)}\}
\end{align*}
Subsequently the result of \textsf{analyse} on line 5 yields the map:
\begin{align*}
\texttt{a} \mapsto \{\vtwo{-1}{0}, \vtwo{1}{0},
          \vtwo{0}{-1}, \vtwo{0}{1}, \vtwo{0}{0}\}
\end{align*}
%

\paragraph{Step 3: Coalesce contiguous indices into regions}

Let $M$ range over the finite maps generated by \textsf{analyse}.  For
each $v \in \mathsf{dom}(M)$, the algorithm then constructs a group
of regions which cover all contiguous groups of relative indices
(from $M(v)$) in the $n$-dimensional space. 

Informally, the procedure proceeds as follows. First, relative
indices are turned into unit regions in $n$-dimensions. For
example, for the five point stencil there are five $1 \times 1$ regions,
called \emph{spans}, which are essentially $0$-dimensional:
%
\begin{center}
\begin{tikzpicture}
%\draw[step=0.5cm,lightgray,very thin] (0.5,0.5) grid (2,2);
\node at (1.25,1.22) {\textnormal{\small{0,0}}};
\draw[thick] (1,1) rectangle (1.5,1.5);
\draw[thick] (1.5,1) rectangle (2,1.5);
\draw[thick] (1,0.5) rectangle (1.5,1);
\draw[thick] (0.5,1) rectangle (1,1.5);
\draw[thick] (1,1.5) rectangle (1.5,2);
\end{tikzpicture}
\end{center}
%
Each dimension is traversed, coalescing consecutive spans
which vary in $m$-dimensions into coalesced spans which vary in 
$m+1$-dimensions. In this example, the $0$-dimensional spans
 become $1$-dimensional spans (rows/columns):
%
\begin{align*}
\begin{array}{cc}
\begin{tikzpicture}
%\draw[step=0.5cm,lightgray,very thin] (0.5,0.5) grid (2,2);
%\node at (1.25,1.22) {\textnormal{\small{0,0}}};
\draw[thick] (0.5,1) rectangle (2,1.5);
\draw[thick] (1,0.5) rectangle (1.5,1);
\draw[thick] (1,1.5) rectangle (1.5,2);
\end{tikzpicture}
\qquad
&
\qquad
\begin{tikzpicture}
%\draw[step=0.5cm,lightgray,very thin] (0.5,0.5) grid (2,2);
%\node at (1.25,1.22) {\textnormal{\small{0,0}}};
\draw[thick] (1.5,1) rectangle (2,1.5);
\draw[thick] (0.5,1) rectangle (1,1.5);
\draw[thick] (1,0.5) rectangle (1.5,2);
\end{tikzpicture}
\\
\textit{dimension 1} \qquad & \qquad \textit{dimension 2}
\end{array}
\end{align*}
%
Any spans that are contained with any other span are deleted,
leaving a minimal set of spans (which may overlap, but none of which
fully contains another).
\begin{center}
\begin{tikzpicture}
%\node at (1.25,1.22) {\textnormal{\small{0,0}}};
\draw[thick] (1,0.5) rectangle (1.5,2);
\node at (2,1.22) {+};
\draw[thick] (2.5,1) rectangle (4,1.5);
%\node at (2.75,1.22) {\textnormal{\small{0,0}}};
\end{tikzpicture}
\end{center}
%
The procedure is then iterated till a fixed point is reached. In this
example this is reached in the first step. These final spans
go on to form the basis of the spatial stencil specification, where
each span is a region product \texttt{*} and multiple spans are
combined with the region sum \texttt{+}.


\paragraph{Span coalescing, formally}

Let $\vect{x}, \vect{y}, \vect{z}$ range over the column vectors of size
$n$ whose values are drawn from $\mathbb{Z}_\top$.
We write $\vect{x}_i$ for the $i$-th value of vector $\vect{x}$ (1
indexed) and $\vect{x}_{i:j}$ for the subvector from entry $i$ to
entry $j$ (inclusive). 

\begin{definition}[Spans]
  A \emph{span} represents an $n$-dimensional box (\emph{hyperrectangle}) as
  a pair of $n$-dimensional vectors (represented as a $2 \times n$
  matrix) giving the co-ordinates of the lower-bound vertex (first
  column) and the upper-bound vertex (second column). We use the
  notation $[\vect{x}^L \; \vect{x}^U]$ for such a span to mark out
  the lower and upper bound vecvtors. 
\end{definition}

The algorithm to create contiguous spans, covering the space of
indices, then proceeds as follows. 
Firstly, for all $v \in \mathsf{dom}(M)$ then a new map $M'$ is
created where each vector is mapped to the trivial \emph{unit span} is
created by pairing a vector with itself:
%
\begin{align*}
N(v) = \{[\vect{x} \; 
  \vect{x}] \mid \vect{x} \in M(v)\}
\end{align*}
%
For our example, this yields:
%%
\begin{align*}
N(\texttt{a}) = \stwo{0}{0}{0}{0} \stwo{1}{0}{1}{0} \stwo{-1}{0}{-1}{0} \stwo{0}{1}{0}{1} \stwo{0}{-1}{0}{-1}
\end{align*}
%%
A fixed point is then compute for the following
procedure \textsf{regions} which, for per variable
in the map, coalesces spans into contiguous regions in
the $n$-dimensional spaace. That is, we compute
 $(\mu \; \textsf{regions}) N$ where \textsf{regions}
is defined as follows for each variable in the map:
%
\begin{enumerate}

\item Compute all permutations on the column vectors in a span, \ie{},
  $[\vect{x}^L \vect{x}^U] \mapsto [\pi\vect{x}^L \, \pi\vect{x}^U]$
for a permutation $\pi$. For each permutation function $\pi^n_i$
(the $i$-th permutation for vectors of size $n$, we pair the
permutation function with the set of permuted spans so that 
the spans can be unpermuted later. 
%
\[
P(v) = \bigcup_{i \in !n} (\pi^n_{i} , \; \{[\pi^n_i
\vect{x}^L \; \pi^n_i\vect{x}^U] \, \mid \, [\vect{x}^L \; \vect{x}^U]
\leftarrow N(v)\}
\]
%
For our example, this yields:
%
\begin{align*}
P(\texttt{a}) = 
\{&(\pi^2_1, \{ \stwo{0}{0}{0}{0}
\stwo{1}{0}{1}{0} 
\stwo{-1}{0}{-1}{0} 
\stwo{0}{1}{0}{1} 
\stwo{0}{-1}{0}{-1} \})
\\
&(\pi^2_2, \{ 
 \stwo{0}{0}{0}{0}
 \stwo{0}{1}{0}{1}
 \stwo{0}{-1}{0}{-1}
 \stwo{1}{0}{1}{0}
 \stwo{-1}{0}{-1}{0}\})\}
\end{align*}
%
where $\pi^2_1$ is the identity permutation and $\pi^2_2$ is the
permutation flips the order of the two elements in the column
vectors. 

\item Sort each permutation set into an ordered list, based on the ordering:
\[
\vect{x} \leq \vect{y} = \exists i \, . \; \vect{x}_i \leq \vect{y}_i 
\; \wedge \; \vect{x}_{i:n} = \vect{y}_{i:n}
\]
%
This yields:
%%
\begin{align*}
\{&(\pi^2_1, [
\stwo{0}{-1}{0}{-1}
\stwo{-1}{0}{-1}{0} 
\stwo{0}{0}{0}{0}
\stwo{1}{0}{1}{0} 
\stwo{0}{1}{0}{1}] )
\\
&(\pi^2_2, [
\stwo{0}{-1}{0}{-1}
\stwo{-1}{0}{-1}{0}
\stwo{0}{0}{0}{0}
\stwo{1}{0}{1}{0}
\stwo{0}{1}{0}{1}])\}
\end{align*}
%%
\item Fold each list pairwise by the following partial operation
 $\bullet$ which coalescees contiguous regions:
%
\begin{align*}
& (\vect{x}^L,\vect{x}^U) \bullet (\vect{y}^L,\vect{y}^U) \\
= &
\begin{cases}
(\vect{x}^L, \vect{y}^U) & \vect{x}^U_1 + 1 = \vect{y}^L_1 \; \wedge \;
(\vect{x}^L_{1:n}, \vect{x}^U_{1:n}) = (\vect{y}^L_{1:n}, \vect{y}^U_{1:n}) \\
\bot  & \textit{otherwise}
\end{cases}
\end{align*}
For our example, this yields:
%
\begin{align*}
Q(v) = \{&(\pi^2_1, [
\stwo{0}{-1}{0}{-1}
\stwo{-1}{0}{1}{0}, 
\stwo{0}{1}{0}{1}, 
]) \\
&(\pi^2_2, [
\stwo{0}{-1}{0}{-1},
\stwo{-1}{0}{1}{0},
\stwo{0}{1}{0}{1}])\}
\end{align*}
%
\item Unpermute and union together, \ie{},
%
\[
U(v) = \bigcup \{[\pi \vect{y}^L, \pi \vect{y}^U]
 \mid [\vect{y}^L, \vect{y}^U] \leftarrow S, (\pi, S) \leftarrow Q(v)\}
\]
Which yields:
%
\begin{align*}
U(\texttt{a}) = 
\{\stwo{0}{-1}{0}{-1}
\stwo{-1}{0}{1}{0}
\stwo{0}{1}{0}{1}
\stwo{-1}{0}{-1}{0}
\stwo{0}{-1}{0}{1}
\stwo{1}{0}{1}{0}\}
\end{align*}
%
\item Finally, filter by the region containment predicate $\containedin$, that
  is, if any region is contained within another then remove the
  smaller. The $\containedin$ predicate is defined:
%
\begin{align*}
& (\vect{x}^L, \vect{x}^U) \containedin (\vect{y}^L, \vect{y}^U) = \\
& \vect{y}^L_1 \leq \vect{x}^L_1 \wedge \vect{x}^U_1 \leq \vect{y}^U_1
  \wedge (\vect{x}^L_{1:n}, \vect{x}^U_{1:n}) \containedin
  (\vect{y}^L_{1:n}, \vect{y}^U_{1:n})
\end{align*}
For our example this then yields the final result of: 
\begin{align*}
\textsf{regions}(M) 
= \{\stwo{-1}{0}{1}{0} \stwo{0}{-1}{0}{1}\}
\end{align*}
since $\stwo{0}{1}{0}{1} \sqsubseteq \stwo{0}{-1}{0}{1}$
and $\stwo{1}{0}{1}{0} \sqsubseteq \stwo{-1}{0}{1}{0}$. 
\end{enumerate}
For our example, applying \textsf{regions} again yields the same
result, hence we have reached a fixed point.

\section{Evaluation}
\label{sec:evaluation}

\section{Discussion}
\label{sec:discussion}


\bibliography{references}


\onecolumn
\appendix

\section{Correctness}


\begin{theorem}[Soundness]
\[
\overline{\texttt{v} : S}\equiv \overline{\texttt{u} : T}
\; \Rightarrow \;
\interp{\overline{\texttt{v} : S}} = \interp{\overline{\texttt{u} : T}}
\]
\end{theorem}

\paragraph{Proof}
\begin{itemize}
\item \textsc{coalesceF}
\begin{align*}
\llbracket & \texttt{v} : \texttt{fwd} \; \texttt{dims}=ds \; \texttt{depth}=n; \,
  \texttt{v} :  \texttt{fwd} \; \texttt{dims}=ds \;
  \texttt{depth}=n+1)\rrbracket \\
& =  \{ (\texttt{v}, ix)^m \mid \forall \, m, ix : \relix, d : \mathbb{N}
  \, . \, d \in \textit{ds} \Rightarrow ix \, d \leq (n+1) \} \; \cup \; \{ ix^m \mid \forall \, m, ix : \mathbb{Z}^{\mathbb{N}}, d : \mathbb{N}
  \, . \, d \in \textit{ds} \Rightarrow ix \, d \leq n \}\\
& =  \{ (\texttt{v}, ix)^m \mid \forall \, m, ix : \relix, d : \mathbb{N}
  \, . \, d \in \textit{ds} \Rightarrow ((ix \, d \leq (n+1)) \vee (ix \,
  d \leq n)) \} \\
& =  \{ (\texttt{v}, ix)^m \mid \forall \, m, ix : \relix, d : \mathbb{N}
  \, . \, d \in \textit{ds} \Rightarrow ix \, d \leq (n+1) \} \\
& = \interp{\texttt{v} : \texttt{fwd} \; \texttt{dim}=ds \;
  \texttt{depth}=n + 1} \qquad \Box
\end{align*}
\end{itemize}

\end{document}
