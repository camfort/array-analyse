\noindent
We outline here the procedures for checking conformance
of source code against specifications (\Cref{subsec:checking})
and for inferring specifications from code (\Cref{subsec:inference}).
Both rely on a program analysis that converts array subscripts
 into sets of index schemes. We outline this analysis
first (\Cref{subsec:analysis}). Note that the analysis
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. At the moment, the analysis
is largely \emph{syntactic}, with only a small amount of
semantic interpretation of the code.

\begin{example}
\label{exm:checking}
We demonstrate analysis, checking, and inference on the 
five-point stencil example:
%%
\begin{minted}{fortran}
b(i, j) = (a(i, j) + a(i-1, j) +a (i+1, j) + a(i, j-1) + a(i, j + 1)) / 5.0
\end{minted}
\end{example}

\subsection{Analysis of array accesses}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}
\noindent
The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathit{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable.% where we use the predicate
%\arrayTy{} to classify variables of array type.

The analysis traverses the control-flow graph of a program top-down
and traverses statements inside of loops bottom-up. The right-hand
side of any assignment statement in a loop is classified based on
whether it has array subscripts flowing to it which are neighbourhood
offsets (or potential absolute in some dimensions). These are then
converted into our model domain by the interpretation
$\interp{-}^{\mathit{aterm}}$ (\Cref{defn:subscript}) and grouped
into a finite map from array variables to set of subscript schemes.
We denote sets of index/subscripts schemes by
$\mathcal{S}$.

For our example, the set of subscript schemes from the analysis is:
%
\begin{equation*}
\mathcal{S}_0 = \{\{0\} \times \{0\}, \{-1\} \times \{0\},
\{0\} \times \{-1\}, \{0\} \times \{1\}, \{1\} \times \{0\}\}
\end{equation*}
%
This set of index schemes is then augmented with multiplicity
information (\textsf{only} or \textsf{mult}) depending on whether
subscripts are unique or not in the analysed statement.
Thus, for each assignment, the analysis generates a map from array
variables to values in $\mathsf{Mult}(\mathcal{P}(\bz)^N)$.

Any assignment statement from which array subscripts flow to the
current assignment is marked as visited such that the main analysis
does not classify it as the root of an array computation.  Thus,
combined with the bottom-up traversal inside of loops, we assign
specifications only to the leaves of dataflow paths in a loop.

\subsection{Checking code against specifications}
\label{subsec:checking}

\noindent
Checking verifies the access pattern of an array computation in the
source language against any associated specifications. Checking
proceeds by generating a model from a specification and generating a
model from the source code (above), and comparing them for
consistency.  Since the model of \Cref{sec:model} interprets both
array indices and specifications as sets of points in $N$-dimensional
space. The notion of consistency is then intuitively whether these two
(potentially infinite) sets of points are equal. This leads to a
simple notion of consistency, where $\mathit{consistent}(M_C, M_S)$
tests the consistency of a modal $M_C$ of source code against
a model $M_S$ of a specification:
%
\begin{align*}
  \mathit{consistent} & :
    \mathsf{Mult}(\mathcal{P}(\bz{}^N)) \times
    \mathsf{Mult}(\mathsf{Approx}(\region{N})) \to \mathbb{B} & \\
%
  \mathit{consistent}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    \mathsf{false} & \mathit{model} = \mathsf{once}(x) \wedge ix =
    \mathsf{mult}(y) \\
    \mathsf{false} & \mathit{model} = \mathsf{mult}(x) \wedge ix = \mathsf{once}(y) \\
    \mathit{consistent'}(\mathit{peel}(ix), \mathit{peel}(model)) & \textit{otherwise}
  \end{cases} \\
%
  \mathit{consistent'} & :
    \mathcal{P}(\bz{}^N) \times
    \mathsf{Approx}(\region{N}) \to \mathbb{B} & \\
%
  \mathit{consistent'}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    m = \mathit{ix} & \mathit{model} = \mathsf{exact}(m) \\
    m \supseteq \mathit{ix} & \mathit{model} = \mathsf{upper}(m) \\
    m \subseteq \mathit{ix} & \mathit{model} = \mathsf{lower}(m)
  \end{cases}
\end{align*}
%
The first function, $\mathit{consistent}$, checks whether the linearity of the
specification matches that of the indices, \ie{} if the specification allows
indices to be repeated or not. Then it delegates to $\mathit{consistent'}$
to check if the points observed in the array terms match the space
defined by the specification. Lower bounds, marked by the \texttt{atLeast}
modifier, require the space defined by the specification to remain inside the
set of indices, while an upper bound, market by \texttt{atMost},
requires the opposite: enclosure. In the absence of such modifiers, we expect
the space defined by observed indices corresponds exactly with those defined by the
region in the specification, hence requiring set equality.

As explained in \Cref{subsec:union-normal-form}, the sets being compared are
potentially infinite thus equality cannot be computed by exhaustively
comparing elements in each set. Instead, we compile the region into
interval constraints and subscript schemes into membership constraints and pass
these to the \textsc{Z3} SMT solver~\citep{de2008z3} to see if they are equal. The
query is expressed in quantifier-free linear arithmetic, which is decidable.

Although satisfiability is super-exponential with the length of the formula in
the worst case~\cite{fischer1974super}, the performance of consistency checking
using satisfiability is fast in practice as the length of the formula is linearly
related with two factors: (1) dimensionality times the number of regions connected
with \texttt{+} and (2) dimensionality times the number of array terms flowing
into an assignment. In \Cref{subsec:additional-data}, we
established that  99.6\% of array computations have 
dimensionality of at most four, and 97\% of array computations
involve at most 4 array subscript terms. In
\Cref{sec:evaluation}, we show the number of regions that are
connected with no more than two \texttt{+} operations in 100\% of the cases.


\subsection{Inferring specification automatically}
\label{subsec:inference}
%
\noindent
We provide an inference procedure for generating specifications from
code which are inserted automatically as comments. This supports
maintenance of a legacy code base, and aids adoption of the
specification language. 

The program analysis converts the concrete syntax of
array subscripts into sets of subscript schemes. Inference then has
two parts. First, ``adjacent'' index schemes are coalesced into a
smaller sets of index schemes, remaining in union normal
form. Secondly, the resulting union normal form is converted to the
specification syntax.

\subsubsection{Covering}
A covering of (possibly overlapping) intervals is calculated
by coalescing \emph{contiguous} index schemes
until a fixed-point is reached.

\newcommand{\contig}[2]{\mathit{adjacent}(#1, #2)}
\begin{defn}[Adjacent]
  \label{def:contiguity}
  Two index schemes $S$ and $T$ are \emph{adjacent} written
  $\contig{S}{T}$, iff $\pi_i(S) = \pi_i(T)$ for all $1 \leq i \leq N$
  apart from some dimension $k$ such that $\pi_k(S) = [a, b]$ and
  $\pi_k(T) = [b+1, c]$.
\end{defn}
%
Given a set of indexing schemes $\mathcal{S}$ and a particular index scheme $S$
we generate a set from coalescing $S$ with adjacent index schemes:
%
\begin{equation*}
\mathit{coalesce}(S, \mathcal{S}) = 
  \{\,S \cup T \mid T \in \mathcal{S} \, \wedge \,
  \contig{S}{T} \}
\end{equation*}
%
This is then used by the following recursive procedure:
%
\begin{align*}
  \mathit{coalesceStep}(\mathcal{S}) =
  \exists T \in \mathcal{S} . 
  \begin{cases}
    \{T\} \cup \mathit{coalesceStep}(\mathcal{S} - \{T\}) &
    \mathit{coalesce}(T, \mathcal{S}) = \emptyset \\
    \mathit{coalesceStep}(\mathit{coalesce}(T, \mathcal{S}) \cup
                                        \mathcal{S} - \{T\}) & \textit{otherwise}
  \end{cases}
\end{align*}
%
This gives a specification rather than an implementation. Our
implementation represents sets by a list, and so
$\exists T \in \mathcal{S}$ above corresponds to deconstructing
the list into its head element $S$ (picking an element from the set).
If $T$ has no adjacent index schemes, then coalescing is attempted on
the rest of the set, and $T$ is returned in the result. Otherwise,
the set of coalesced index scheme is computed and this is passed to
a recursive procedure called to $\mathit{coalesceStep}$, along with the rest of
the elements).

The fixed-point of $\textit{coalesceStep}(\mathcal{S})$ is computed to
give a covering over the initial subscript space.
%
\begin{restatable}{lem}{closureInference}
  \label{lem:closuer-inference}
  For a set of index schemes $\mathcal{S}$, then
  $\mathit{coalesceSet}(\mathcal{S})$ is a set of
  index schemes in Union Normal Form.
\end{restatable}
%
For our example, the fixed-pointed of $\mathit{coalesceStep}$ is reached within two
steps:
%
\begin{align*}
  \mathit{coalesceStep}(\mathcal{S}_0) & =
  \{[-1,0] \times [0,0],\,[0,0] \times [-1, 0],\,[0,0] \times
    [0,1],\,[0,1] \times [0,0]\} \\
  \mathit{coalesceStep}^2(\mathcal{S}_0) & =
  \{[-1, 1] \times [0, 0],\,[0, 0] \times [-1, 1]\} = \mathit{coalesceStep}^3(\mathcal{S}_0)
\end{align*}
%
%\todo{Prove that this is in $Region_N$}

\subsubsection{Index schemes to syntax}

\newcommand{\finalSet}{\mathcal{S}_\omega}
Let the covering indexing scheme from the fixed point of
$\mathit{coalesceStep}$ on input $\mathcal{S}_0$ be written as
$\finalSet{}$.  Next, $\finalSet{}$ is translated into specification
syntax. This happens in three stages.
%
\begin{enumerate}[leftmargin=2em]
  \item We check whether $\finalSet{}$
  is the top indexing scheme $\bz{}^N$. This occurs if absolute indices
  appear in each of the dimension across the array subscripts,
  leading to an unconstrained access pattern, which is not represented
  in our syntax, ending inference.

  \item Otherwise, we determine if the indexing schemes are interval
  schemes (\Cref{def:interval-scheme}) so that they can be represented
  exactly by our syntax. It not, they are altered into interval
  schemes to be represented as approximations.

  \item Interval schemes into a joins of meets
  of region constants, where some intervals are split into separate
  region constants.
\end{enumerate}
%
An index scheme is an interval scheme (\Cref{def:interval-scheme}) if
each of vector can be represented as a vector of holed intervals
$\interv{a}{b}{c}$.  If so, we convert each index scheme to an
interval scheme as a vector of holed interval representation.

Since index schemes of the previous stage are all contiguous and form
closed intervals, a lower bound $\leq 0$ and an upper bound $\geq 0$
is sufficient to form an interval scheme.  Otherwise, an approximate
specification is generated.

An upper bound is established by
\emph{elongating} any index schemes in multiple dimensions such that
they become interval schemes. The elongation function is
given as
%
\begin{align*}
  \mathit{elongate}([a,b]) = \begin{cases}
    \interv{0}{b}{\textsf{false}} & a > 1 \\
    \interv{a}{0}{\textsf{false}} & b < -1
  \end{cases}
\end{align*}
%
If any dimension of an index scheme is elongated, then the whole index
scheme is elongated. In $\finalSet$, all index schemes that are
representable as interval schemes form a lower bound, whilst those
that do not produce an upper bound by their elongation. A lower bound
may not be generated if all indexing schemes are not interval schemes.
In the case of our example, the resulting $\finalSet$ comprises a set
of interval schemes, thus we can generate an exact specification.

\paragraph{Translation from interval schemes}

Recall the model of region constants in \Cref{subfig:region-model}
where $\interp{-}$ maps to holed intervals which have either $0$ as
the lower-bound or upper-bound for \fortran{forward} and
\fortran{backward} respectively, or both $0$ for \fortran{pointed}, or
$-k$ and $k$ lower and upper bounds for \fortran{centered}. We can
invert this map to generate region constants from holed
intervals. However, some intervals computed from the above steps
may not the constraints of this interpretation,
\eg{}, $\interv{-2}{1}{} \times \interv{-1}{1}{}$.  By
\Cref{lem:vector-union}, we can split interval schemes into two into
the relevant form, for example, producing
$\interv{-2}{0}{} \times \interv{-1}{1}{}$ and
$\interv{0}{1}{} \times \interv{-1}{1}{}$. 
The following function
$\textit{split}$ iterates over the components of an index scheme,
splitting apart interval schemes when necessary:
%
\begin{align*}
  %\textit{split}(\emptyset) = \emptyset \quad
  \textit{split}(\interv{a}{b}{c} \times S) =
   \begin{cases}
  \{ \interv{a}{0}{c} \times T \mid T \in \textit{split}(S) \}
  \cup
  \{ \interv{0}{b}{c} \times T \mid T \in \textit{split}(S) \}
  & a < 0 \vee b > 0 \vee (|a| \neq b) \\
  \{ \interv{a}{b}{c} \times T \mid T \in \textit{split}(S) \}
\end{cases}
\end{align*}
%
This forms a set of interval schemes to which $\interp{-}^{-1}$ can be
applied. In the case of our example, no splitting is necessary.

The final stage of inference is simply mapping interval schemes into
region constants and combining these. Each translated interval scheme
is connected with \texttt{+}. Individual schemes are decomposed using
\Cref{lem:vector-intersect} such that each of the resulting index
schemes have all but one dimensions set to \interv{-\infty}{\infty}{}.

Each of these interval schemes are mapped to region constants using
\Cref{subfig:region-model} and connected with \texttt{*}.
%
\begin{align*}
\textit{convert}_N(\mathcal{S}) = \sum_{S \in S} \prod_{1 \leq i \leq N} \interp{\pi_i(S)}^{-1}
\end{align*}
%
In the example, $\interv{-1}{1}{} \times \interv{0}{0}{}$ is decomposed into
$\interv{-1}{1}{} \times \interv{-\infty}{\infty}{}$ and
$\interv{-\infty}{\infty}{} \times \interv{0}{0}{}$. These are then mapped to
\texttt{\stencil{c}{1}{1}{} * \stencil{p}{2}{}{}}. The decomposition of
$\interv{0}{0}{} \times \interv{-1}{1}{}$ is similar. When combined we obtain the
following specification:
%
\begin{equation*}
  \texttt{stencil readOnce,} \;
  \stencil[s]{c}{1}{1}{} \texttt{*} \stencil[s]{p}{2}{}{} \; \texttt{+} \;
  \stencil[s]{p}{1}{}{}  \texttt{*} \stencil[s]{c}{2}{1}{}
\end{equation*}
