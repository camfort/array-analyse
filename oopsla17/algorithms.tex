%
We outline here the procedures for checking conformance
of source code against specifications (\Cref{subsec:checking})
and for inferring specifications from code (\Cref{subsec:inference}).
Both rely on a program analysis that converts array subscripts
 into sets of index schemes. We outline this analysis
first (\cref{subsec:analysis}). Note that the analysis
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. At the moment, the analysis
is largely \emph{syntactic}, with only a small amount of
semantic interpretation of the code.

\subsection{Union Normal Form}\label{subsec:union-normal-form}

We need to address the problem of representation in the model for index schemes.
In each case, the objects are sets and union and intersection are the
combinators. However, they are often infinite sets due to \bz{} in Cartesian
product. This happens when constant indices of array terms are converted to
\bz{} in subscript schemes and when infinite interval is generated in interval
schemes. This calls for a finite (and ideally compact) representation for
indices.

First recall \Cref{lem:vector-intersect}, which states that intersection of
indexing schemes is still an indexing scheme. When combined with
\Cref{lem:interval-identities}, we can extend this closure to interval schemes.
Subscripts schemes do not enjoy the same propery as intersection of two
singleton sets might easily be empty, which disqualifies it from being a
subscript index. In the following sections we will not rely on intersection of
subscript indices, so that is not a problem.

Union, however, is not as flexible as intersection. \Cref{lem:vector-union} does
not form a closure for indexing schemes in general. For this reason, we
represent collection of all forms of indexing schemes as unevaluated unions.
Since the model forms a distributive lattice as established in
\Cref{prop:region-lattice}, the intersections can be pushed in using the
distributive law leaving only unions. We further exploit associativity of union
to put unions into a cons tree making the unions effectively a non-empty list.
We do not, however, attempt to canonicalise the representation. Later on
\Cref{lem:vector-union} and index scheme subset are used to reduce the size of
union normal form.

\subsection{Analysis of array accesses}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}

The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathsf{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable.% where we use the predicate
%\arrayTy{} to classify variables of array type.


\subsection{Checking code against specifications}
\label{subsec:checking}

In the model, we can regard both array indices and specifications as groups of
points in $N$-dimensional space. Notion of consistency is then intuitively
whether these two (potentially infinite) sets of points in space match or not.
This leads to a simple set based consistency function defined as
%
\begin{align*}
  \mathit{consistent} & :
    \mathsf{Mult}(\mathcal{P}(\bz{}^N)) \times
    \mathsf{Mult}(\mathsf{Approx}(\region{N})) \to \mathbb{B} & \\
%
  \mathit{consistent}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    \mathsf{false} & \mathit{model} = \mathsf{once}(x) \wedge ix = \mathsf{mult}(y) \\
    \mathit{consistent'}(\mathit{peel}(ix), \mathit{peel}(model)) & \textit{otherwise}
  \end{cases} \\
%
  \mathit{consistent'} & :
    \mathcal{P}(\bz{}^N) \times
    \mathsf{Approx}(\region{N}) \to \mathbb{B} & \\
%
  \mathit{consistent'}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    m = \mathit{ix} & \mathit{model} = \mathsf{exact}(m) \\
    m \supseteq \mathit{ix} & \mathit{model} = \mathsf{upper}(m) \\
    m \subseteq \mathit{ix} & \mathit{model} = \mathsf{lower}(m)
  \end{cases}
\end{align*}
%
The first function, $\mathit{consistent}$, checks whether the linearity of the
specification matches that of the indices, \ie{} if the specification allows
indices to be repeated or not. Then it delegates to $\mathit{consistent'}$
function to check if the points observed in the array terms match the space
defined by the specification. Lower bounds, marked by \texttt{atLeast}
modifier, require the space defined by the specification to remain inside the
set of indices, while an upper bound, market by \texttt{atMost} modifier,
requires the opposite: enclosure. In the absence of such modifiers, we expect
the space defined by observed indices correspond exactly those defined by the
region in the specification, hence requiring set equality.

As explained in \Cref{subsec:union-normal-form}, the sets being compared are
potentially infinite and set comparisons cannot be done by exhaustively
comparing the points of one with the other. Instead, we compile the region into
interval constraints and subscript schemes into membership constraints and pass
it to \textsc{Z3}~\citep{de2008z3} SMT solver to see if they are equal. The
query belongs to to quantifier free linear arithmetic, which is a decidable
theory.

Although satisfiability is super-exponential with the length of the formula in
the worst case~\cite{fischer1974super}. Performance of consistency checking
using satisfiability is irrelevant as the the length of the formula is linearly
related with two factors: (1) dimensionality times number of regions conntected
with \texttt{+} and (2) dimensionality times the number of array terms flowing
into an assignment assignment. In \Cref{sec:study}, we establish dimensonality
99\% of all array variables that we can assign a specification is X, and 99\% of
number of array terms that flows into such an assignment is Y. In
\Cref{sec:evaluation}, we show the number of regions that are connected with
\texttt{+} is Z in 99\% of the cases.

\mnote{DOMINIC fills in X, Y, and Z}

\subsection{Infering specification automatically}
\label{subsec:inference}
%
\noindent
We provide an inference procedure for generating specifications from
code, which are inserted automatically as comments. This helps support
maintenance of legacy code, and aids understanding of our
specification language. We illustrate inference using the
five-point stencil of \Cref{exm:checking}.

The preceding source code analysis converts the concrete syntax of
array subscripts into a set of subscript schemes in
$\mathcal{P}(\bz)^N$. These subscripts are then coalesced iteratively
into sets of index schemes. We denote sets of index schemes by
$\mathcal{S}$, and initial set of subscript schemes from the analysis
as $\mathcal{S}_0$. For our example:
%
\begin{equation*}
\mathcal{S}_0 = \{\{0\} \times \{0\}, \{-1\} \times \{0\},
\{0\} \times \{-1\}, \{0\} \times \{1\}, \{1\} \times \{0\}\}
\end{equation*}
%
%For each array variable $a \in \mathsf{dom}(U)$, the algorithm
%constructs a set of $n$-dimensional rectangles covering all contiguous
%groups of schemes in $U(a)$.
%
We explain the algorithm in two parts. First, we show how
\emph{contiguous} index schemes are coalesced into a smaller set of
index schemes while remaining in union normal form. Then, we explain
how this smaller unioned indexing schemes are converted to
specifications.

\subsubsection{Covering}
A covering of (possibly overlapping) intervals is calculated as a
value of \region{N} by coalescing \emph{contiguous} index schemes
until a fixed-point is reached.

\newcommand{\contig}[2]{\mathsf{contig}(#1, #2)}
\begin{defn}[Contiguity]
  \label{def:contiguity}
  Two index schemes $S$ and $T$ are \emph{contiguous} written
  $\contig{S}{T}$, iff $\pi_i(S) = \pi_i(T)$ for all $1 \leq i \leq N$
  apart from some dimension $k$ such that $\pi_k(S) = [a, b]$ and
  $\pi_k(T) = [b+1, c]$.
\end{defn}
%
A coalesced set of index schemes is computed by:%
%
\begin{align*}
  \mathsf{coalesce}(\mathcal{S}) = \; & \;\;
  \{\,S \cup T \mid S \in \mathcal{S}, T \in \mathcal{S} \, \wedge \,
                                        \contig{S}{T} \}
  \;\;\; \cup \;\;\;
  \{\,S \in \mathcal{S} \mid \neg \exists T \in \mathcal{S} . \; \contig{S}{T}\}
\end{align*}
%
Thus, $\mathsf{coalesce}(\mathcal{S})$
comprises the union of the set of coalesced pairs of contiguous
schemes and the set of index schemes for which there is no other
contiguous scheme.
%
\begin{lemma}[Closure]
  For a set of index schemes $\mathcal{S}$, then
  $\mathsf{coalesce}(\mathcal{S})$ is well-defined and is a set of
  index schemes.
\end{lemma}
\begin{proof}
  By \Cref{lem:vector-union}, the union of two index schemes is an
  index scheme if all components are equal except at most one
  component. Contiguity (\Cref{def:contiguity}) matches
  this precondition, thus the first part of the union in
  \textsf{coalesce} produces a set of index schemes. The second part
  comprises a subset of the original index schemes.
\end{proof}
%
For our example, the fixed-pointed of \textsf{coalesce} is reached within two steps:
%
\begin{align*}
  \textsf{coalesce}(\mathcal{S}_0) & =
  \{[-1,0] \times [0,0],\,[0,0] \times [-1, 0],\,[0,0] \times
    [0,1],\,[0,1] \times [0,0]\} \\
  \textsf{coalesce}^2(\mathcal{S}_0) & =
  \{[-1, 1] \times [0, 0],\,[0, 0] \times [-1, 1]\} = \textsf{coalesce}^3(\mathcal{S}_0)
\end{align*}
%
\todo{Prove that this is in $Region_N$}



\subsubsection{Index schemes to syntax}
