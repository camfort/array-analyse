%\setlength{\tabcolsep}{8pt}

\noindent
We start with the following hypotheses about array programming idioms
in scientific code, formed from our observations and conversations
with scientists:
\begin{enumerate}[leftmargin=2em]
\item Computations involving loops over arrays are common, where
  arrays are read according to a static pattern based on constant offsets
  from (base or dervied) induction variables;

\item Most loop-array computations of the previous form read from
  arrays with a \emph{contiguous} pattern, \eg{}:
%
\begin{minted}{fortran}
  b(n) = a(i-1) + a(i) + a(i+1)
\end{minted}
%
\item Most loop-array computations of the previous form read from
  arrays with a pattern that includes the origin index or its
  immediate neighbours (offsets of 1 from the induction variables);

\item Many array computations are \emph{stencil computations}: an
  assignment whose right-hand side comprises array subscripts with
  neighbourhood indices and whose left-hand side is a
  neighbourhood-indexed array subscript (\eg{}, the Laplace operator);

\item Many array computations read from each particular array index just
  once. The significance of this hypothesis is that, if true, it would
  be useful to provide a specification of index uniqueness, so accidental
  repetition of subscripts in complex code can be detected.
\end{enumerate}
%
From these hypotheses, we conjecture that the spatial properties of
the above programming idioms can be specified declaratively via a
small set of combinators, capturing data access patterns. % based on
%overlapping (hyper)rectangles.
We performed a large scale source-code analysis to validate these
hypotheses and guide the design of our language. These results are
potentially of interest to others, such as designers of array/stencil DSLs
or autotuners.

\subsection{Methodology}
%
\noindent
We constructed a corpus of eleven scientific computing packages
written in Fortran ranging in size and scope:
%
\begin{enumerate}[leftmargin=1.5em]
\item The Unified Model (UM) developed by the UK Met Office
for weather modelling~\cite{um};
\item E3ME, a mixed economic/energy impact predication
  model~\cite{RePEc:aen:journl:2006se-a12}

\item Hybrid4, a global scale ecosystem model~\cite{GBC:GBC635};

\item GEOS-Chem, troposhperic chemstry model~\cite{geos-chem};

\item Navier, a small-size Navier-Stokes fluid model (based
  on \cite{griebel1997numerical};

\item Computational Physics (CP), programs from a popular
 textbook~\cite{giordano1997computational};

\item BLAS, a common linear-algebra
  library used in modelling~\cite{blas};

\item ARPACK-NG, an open-source library for solving large-scale
eigenvalue problems~\cite{arpackng};

\item SPECFEM3D, global seismic wave models~\cite{specfem3d};

\item MUDPACK, a general multi-grid solver for elliptical
partial differentials~\cite{MUD};

\item Cliffs, a tsunami model~\cite{tolkova2014land}
\end{enumerate}
%
These cover approximately 1.4 million lines of Fortran code
(2.4 million including comments and white space).  The UM and
GEOS-Chem packages are the largest at $\approx$630kloc and
$\approx$450kloc respectively.  Appendix~\ref{app:corpus} provides
further detail on these packages and their sizes.  We used Wheeler's
\emph{SLOCCount} to get a count of the physical source lines
(excluding comments and blank lines)~\cite{wheeler2001sloccount}.
A third of the packages come from active research teams who are our project
partners (\ie{}, they were not selected carefully to fit our
hypotheses).

We built a code analysis tool based on CamFort, an open-source Fortran
analyser~\cite{camfort}. Fortran source files are parsed to an AST and
 standard control-flow and data-flow analyses are computed,
including some of key importance for us: induction variable identification
and reaching definitions. The resulting AST is traversed top-down and
assignment statements inside loops are analysed and classified.

%\paragraph{Classifications}
Left-hand sides and right-hand sides of assignments are classified
based on their array subscripting expressions:
%
\begin{center}
\begin{tabular}{l|l|l}
 % Shorthand &
 Classification (of subscripts) & Applies to & Example \\ \hline
 %(\textsf{vars}) &
 Just a variable & LHS & \fortran{x = ...}
  \\
 %(\textsf{IVs}) &
 Induction variables & LHS & \fortran{a(i, j)} \\
 %(\textsf{neigh}) &
 Neighbourhood offsets (of the form
                                                  $i \pm c$) & LHS/RHS
                                                               & \fortran{a(i, j-1)} \\
 %(\textsf{neigh+c}) &
 Neighbourhood offsets and absolutes & LHS/RHS &
                                                            \fortran{b(i, 0, j+1)} \\
 %(\textsf{aff}) &
 Affine offsets (of the form $a * i \pm b$) & LHS/RHS &
                                     \fortran{a(2*i+1,j)} \\
 %(\textsf{aff+c}) &
 Affine offsets and absolutes & LHS/RHS & \fortran{a(i+1, 0,
                                                   3*j+2)} \\
 %(\textsf{other}) &
 Subscript expression not included above & LHS/RHS &
\fortran{x(f(i))}, \fortran{a(i*i)}, \fortran{a(0,1)}
\end{tabular}
\end{center}
%
%Note \textsf{vars} and \textsf{IVs} classifications apply only to
%left-hand sides.
Classifications are computed from all the information that flows into an
assignment. For example, the following decomposes a one-dimensional
three-point pattern across multiple intermediate assignments:
%%
\begin{minted}{fortran}
do i = 1, n
  x = a(i)
  y = a(i+1)
  b(i) = (a(i-1) + x + y)/3.0
end do
\end{minted}
%%x
Our analysis recognises this as a single array computation (rather than three), starting at
line 4, and reading from subscripts \fortran{a(i)}, \fortran{a(i+1)},
\fortran{a(i-1)}. To compute this we traverse the loop body in reverse,
using reaching-definitions to calculate the array reads that flow
to a particular assignment. Since \fortran{x} and \fortran{y} flow to
line 4, the intermediate statements on line 2 and line 3 are not classified separately, though multiple
assignments can flow to multiple classified statements.

We further sub-classify sets of array subscripts
on the right-hand side based on their spatial properties: 

\begin{center}
\begin{tabular}{l||l|p{0.28\linewidth}|l}
  Property   & Shorthand & Classifications (of RHS pattern) & Example \\ \hline
%%%%%%
\multirow{2}{*}{Contiguity} & (\textsf{contig}) & Contiguous  &
                                                                \fortran{a(i) + a(i+1) + a(i+2)} \\
  & (\textsf{disjoint}) & Non-contiguous & \fortran{a(i) + a(i+2)} \\ \hline
%%%%%%
%\multirow{2}{*}{Shape} & (\textsf{rect}) & (Hyper)rectangle &
% \fortran{a(i,j) + a(i+1,j) + a(i,j+1) + a(i+1,j+1)} \\
%           & (\textsf{sumRect}) & Composed (hyper)rectangles &
%  \fortran{a(i,j) + a(i,j-1) + a(i-1,j) + a(i+1,j) + a(i,j+1)} \\ \hline
%%%%%%
  \multirow{2}{*}{Reuse} & (\textsf{readonce}) & Unique subscripts
                                         & \fortran{b(i) = a(i) + a(i+1)} \\
  & (\textsf{mult}) & Repeated subscripts &
 \fortran{b(i) = a(i)  + a(i)} \\ \hline
  \multirow{2}{*}{Positioning} & (\textsf{origin}) & Includes origin
& \fortran{a(i)} or \fortran{a(i+1, j)} (in $2^{\textit{nd}}$
  dimension) \\
             & (\textsf{straddle}) & Within distance 1 of origin &
\fortran{a(i+1,j) + a(i-1,j)} \\
             & (\textsf{away}) & Away from the origin
                                          & \fortran{a(i+2), a(i+3)}
\end{tabular}
\end{center}
%
%To assess the hypothesis that
%arrays are mostly read in a pattern that includes the immediate neighbours
%to the ``origin'', we categorised the position of subscript patterns for each
%right-hand side, in each dimension: \\
%
%\noindent
%
Finally, we categorise the relationship between the left-hand side
and right-hand side, in terms of the use of induction variables.
The two sides are \emph{consistent} if the same induction variables
appear in each side, used for the same dimension. This is
weakened to a \emph{permutation} if the roles of the induction
variables changes. This is weakened further if the left-hand side
induction variables are either
a subset or superset of the induction variables on the right-hand
side. Otherwise, the two sides are seen as inconsistent:
%
\begin{center}
\begin{tabular}{l|l|l}
  Shorthand & Classification & Example \\ \hline
  (\textsf{const}) & Consistent & \fortran{a(i, j) = b(i, j) +
                                  b(i+1,j+1)} \\
  (\textsf{perm}) & Permutation & \fortran{a(i, j) = c(j, i)} or \fortran{a(i,
                                                               0) =
                                 b(0, i)} \\
  (\textsf{LHSsub}) & LHS subset & \fortran{a(i) = b(i, j) + b(i, j-1)}
  \\
  (\textsf{LHSsup}) & LHS superset & \fortran{a(i, j) = b(i)} \\
  (\textsf{inconst}) & Inconsistent & \fortran{a(i) = b(j)}
\end{tabular}
\end{center}
%
If an assignment is not inconsistent, but one of the other four
categories, we refer to it as *consistent.

\subsection{Results}

\noindent
We revisit each hypothesis and show the related data and conclusions.
%
\begin{enumerate}
\item Computations involving loops over arrays are common, where an
  arrays are read from with a static pattern based on constant offsets
  from (base or dervied) induction variables;
\end{enumerate}
%
We identified \num{108773} instances of assignments within loops in
which an array subscript flows to the right-hand side. We refer
to each one of these as an \emph{array computation}.
We performed the classification described above
and grouped the data by the right-hand side classification only:
%%
\begin{center}
\begin{tabular}{l|S[table-format=4]@{\extracolsep{5pt}}S[table-format=2.2]c}
\textbf{RHS classification} & \textbf{Number} & \% &
\textit{Grouping 1} \\ \hline
Affine                          & 34        & 0.03\%
& \multirow{3}{*}{81.43\%} \\ \cline{1-3}
Neighbourhood                   & 65334     & 60.06 \%  \\ \cline{1-3}
Neighbourhood + absolute        & 23209     & 21.34\%  \\ \hline
Other                           & 20196     & 18.57 \%  \\ \hline \hline
\textbf{Total}                  & 108773    & 100\% \\
\end{tabular}
\end{center}
%
\noindent
Since, affine and neighbour patterns are static, we group them
(\textit{Grouping 1}) to see that $81.43\%$ of the array computations
(88,577) have a static pattern that comprises constant offsets of
base/derived induction variables (potential with some absolute
indices), confirming \emph{Hypothesis 1}. Note that affine subscripts
are rare, perhaps due to programmers relying on compilers for
optimisation rather than hand optimising (which tends to lead to
affine indices).  Overwhelmingly, the main category is neighbourhood
offsets (possibly mixed with constants in some dimensions). The
``affine + absolute'' class is not represented at all. \marginpar{\mnote{(2)
  Mention what sort of things are included in other.}}

\begin{enumerate}[resume]
\item Most loop-array computations of the previous form read
from arrays with a \emph{contiguous} pattern.
%
\item Most loop-array computations of the previous form read
from arrays with a pattern that includes the immediate
neighbours (offsets of 1 from the induction variables);
\end{enumerate}
%
We grouped the data based on subclassifications of \emph{Grouping 1}
in terms of contiguity and positioning.
%Focussing on grouping 1.
\begin{center}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]lS[table-format=4]S[table-format=2.2]}
\textbf{RHS classification} & \textbf{Number} & \% {(of whole)}
&\textbf{Position} & \textbf{Number} & \% {(of whole)} \\ \hline
Affine, contiguous
& 31 & 0.03\% \\ \hline
%\multirow{3}{*}{Affine, contiguous}
% & %\multirow{3}{*}{31}
% & %\multirow{3}{*}{0.03\%}
% & \textsf{away} & 4 & 0.00\% \\
%& 31 & 0.03\% & \textsf{origin} & 15 & 0.01\% \\
%&&& \textsf{straddle} & 12 & 0.01\% \\ \hline
Affine, non-contiguous
 & 3
 & 0.00\% & \\ \hline
\multirow{3}{*}{Neighbour, contiguous}
 & %\multirow{3}{*}{83689}
 & %\multirow{3}{*}{83.08\%}
 & \textsf{away} & 152 & 0.14\% \\
& 83689 & 76.94\% & \textsf{origin} & 81309 & 74.75\% \\
&&& \textsf{straddle} & 2228 & 2.05\% \\ \hline
Neighbour, non-contiguous
 & 4854
 & 4.46\% \\ \hline
Other & 20196 & 18.57\%  \\
 \hline \hline
\textbf{Total}  & 108773    & 100\% \\
\end{tabular}
\end{center}
%%
Thus, $76.94\%$ of array computations have only neighbour
indices (which may include some absolute indices) in a contiguous
pattern on the right hand side, with $76.80\%$ either including the origin
($74.75\%$) or offset by a distance of 1 from the origin
($2.05\%$). This confirms both Hypothesis 2 and Hypothesis 3. Only 152 instances
of index patterns not immediately next-to or over the origin were
found.  There is a non trivial amount of non-contiguous arrays access,
but it is a much smaller proportion of the whole.

\begin{enumerate}[resume]
\item Many array computations are \emph{stencil computations}:
an assignment whose
 right-hand side comprises array subscripts with neighbourhood indices
and whose left-hand side is a neighbourhood array subscript.
\end{enumerate}
%
We subclassified the data based on the right-hand side
and left-hand side categories
being either a variable, or induction-variable indexed,
neighbour-indexed or affined-indexed array. We additionally
included the orthogonal classification of whether
left- and right-hand sides are inconsistent or
otherwise (have a common subset of induction variables).
%
\begin{center}
\begin{tabular}{ll|S[table-format=4]S[table-format=2.2]S[table-format=4]S[table-format=2.2]c}
\multicolumn{2}{l|}{\textbf{LHS and RHS classification}}
& \textbf{\# inconsistent}
& \% {(whole)}
& \textbf{\# *consistent}
& \% {(whole)}
& \textit{stencils} \\ \hline
%
LHS Vars & RHS neigh & 0 & 0.00\% & 4591      & 4.22\%
 & \multirow{7}{*}{66.01\%} \\\cline{1-6}
%
%
%
LHS IVs & RHS neigh   &  4560      & 4.19\%  & 50861     & 46.76\% \\\cline{1-6}
%
%
LHS neigh & RHS neigh & 2358      & 2.17\% & 16336     & 15.02\%   \\\cline{1-6}
%
LHS Vars & RHS affines & 0 & 0.00\%  & 4         & 0.00\% \\\cline{1-6}
%
LHS IVs, & RHS affines & 7 & 0.01\% & 0 & 0.00\%  \\\cline{1-6}
%
LHS affine & RHS affines & 0 & 0.00\% &  6         & 0.01\% \\\hline
%
LHS neigh & RHS affines & 8         & 0.01\% & 0 & 0.00\%  \\\hline
%%
LHS affine & RHS neigh  & 23        & 0.02\% & 0 & 0.00\% \\\hline
%
other       &                      & 30019     & 27.60\%  & &
  \\\hline\hline
 Total & & 36975 & & 71798 & 
%Total        &                      & 108773    &
%  LHS var, & RHS affine             & 4         & 0.00\%
% & \multirow{7}{*}{72.37\%} \\\cline{1-3}
%  LHS var, & RHS neighbour          & 4591      & 4.22\%  \\\cline{1-3}
%  LHS IVs, &RHS affine             & 7         & 0.01\%  \\\cline{1-3}
%  LHS IVs, &RHS neighbour          & 55421     & 50.95\% \\\cline{1-3}
%  LHS neighbour, &RHS neighbour    & 18694     & 17.19\% \\\cline{1-3}
%  LHS affine, &RHS affine          & 6         & 0.01\%  \\\hline
%  LHS affine, &RHS neighbour       & 23        & 0.02\%  \\\hline
%  LHS neighbour, &RHS affine       & 8         & 0.01\%  \\\hline
%  other   & other                   & 30019     & 27.60\%  %\\\hline\hline
%  Total                           & 108773    &  \\
\end{tabular}
\end{center}
%
The most common category has an LHS array subscript
indexed by induction variables, and a right-hand side comprising
neighbourhood offsets. Next most common is to have neighbourhood
offsets on the left-hand and right-hand sides. Notably
there are two categories always seen as inconsistent:
``LHS affine, RHS neighbour'' and ``LHS neighbour, RHS affine''
since they comprise different indexing schemes
on each side of the assignment, e.g. $a(i + 1) = b(2*i + 1)$. These
appear very rarely. Thus, we find that $66.01\%$ of array computations
have a static pattern on the left- and right-hand side that is either
affine or a constant translation. Thus, the data supports our
hypothesis that stencils are common. Based on this grouping, we
considered two subclassifications of different kinds of
left-right-hand side relationship and contiguity:
%%
\begin{center}
\begin{minipage}{0.42\linewidth}
\hspace{-1.6em}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]}
\textbf{Contiguity} & \textbf{Number} & \% {(whole)} \\\hline
Contiguous stencil         & 68246     & 62.74\%  \\\hline
Non-contiguous stencil     & 3552      & 3.27\%  \\\hline
other                      & 36975     & 33.99\% \\\hline
%\textbf{Total}             & 108773    &  \\
\end{tabular}
\vspace{2.4em}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]S[table-format=4]S[table-format=2.2]}
\textbf{Consistency} & \textbf{Number} & \% & \textbf{relativised \#} & \% \\\hline
Direct                            & 47448     & 43.62\% & 636       & 0.58\%  \\\hline
LHSsubset                         & 9812      & 9.02\% & 65        & 0.06\%  \\\hline
LHSsuperset                       & 10110     & 9.29\%  & 84        & 0.08\%  \\\hline
Permutation                       & 3604      & 3.31\%  & 39        & 0.04\%  \\\hline
other                             & 36975     & 33.99\% \\\hline
\end{tabular}
\end{minipage}
\end{center}
%%
Most stencils are contiguous, but there is a non-trivial
amount of non-contiguity. Most stencils have matching induction
variables on the left and right-hand sides but again there
are non-trivial amounts of the other kinds of relationship.
%%
\begin{enumerate}[resume]
\item Many array computations read from each particular index just
  once.
\end{enumerate}
%
We classified right-hand sides which are neighbourhood offsets (or
affine) and subclassified this by whether array subscripts were
unique or repeated:

\begin{center}
\begin{tabular}{l|S[table-format=4]S[table-format=2.2]S[table-format=4]}
\textbf{RHS form and reuse} & \textbf{Number} & \% \\ \hline
RHS neighbour/affine unique subscripts      & 78349     & 72.03\%  \\\hline
RHS neighbour/affine repeated subscripts   & 10228     & 9.40\%  \\\hline
other                             & 20196     & 18.57\%  \\\hline\hline
Total                             & 108773    &
\end{tabular}
\end{center}
%
Thus, Hypothesis 5 is confirmed, the majority of array computations
have access patterns with linear usage of array subscripts.

We used these results to inform the design of our specification
language. The objective is to capture the salient aspects of the
programming patterns we identified above whilst remaining independent
of their implementation (and associated programming errors).
