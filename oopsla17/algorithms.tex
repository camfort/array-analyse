\begin{equation*}
\texttt{a} \mapsto \{[0,0]\times[0,0], \;\; [-1,0]\times[0,0], \;\;
[0,0]\times[-1,0], \;\; [0,0]\times[1,0], \;\; [0,1]\times[0,0]\}
\end{equation*}
%
We outline here the procedures for checking conformance
of source code against specifications (\Cref{subsec:checking})
and for inferring specifications from code (\Cref{subsec:inference}).
Both rely on a program analysis that converts array subscripts
 into sets of index schemes. We outline this analysis
first (\cref{subsec:analysis}). Note that the analysis
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. At the moment, the analysis
is largely \emph{syntactic}, with only a small amount of
semantic interpretation of the code.

\subsection{Union Normal Form}\label{subsec:union-normal-form}

We need to address the problem of representation in the model both for observed
array terms converted into subscripts schemes and for specifications converted
into interval schemes. In each case, the objects are sets and union and
intersection are the combinators. However, they are often infinite sets due to
infinite interval and constant indices being converted to \bz{}. This calls for
a finite (and ideally compact) representation for indices.

First recall \Cref{lem:vector-intersect}, which states that intersection of
indexing schemes is still an indexing scheme. When combined with
\Cref{lem:interval-identities}, we can extend this closure to interval schemes.
Subscripts schemes do not enjoy the same propery as intersection of two
singleton sets might easily be empty, which disqualifies it from being a
subscript index. In the following section we will not rely on intersection of
subscript indices, so that is okay.

Union is, however, not as flexible as intersection. \Cref{lem:vector-union} does
not form a closure for indexing schemes in general. For this reason, we
represent collection of all forms of indexing schemes as unevaluated unions.
Since the model forms a distributive lattice as established in
\Cref{prop:region-lattice}, the intersections can be pushed in using the
distributive law leaving only unions. We further exploit associativity of union
to put unions into a cons tree making the unions effectively a non-empty list.
We do not, however, attempt to canonicalise the representation.


\subsection{Analysis of array accesses}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}

The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathsf{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable.% where we use the predicate
%\arrayTy{} to classify variables of array type.


\subsection{Checking code against specifications}
\label{subsec:checking}

In the model, we can regard both array indices and specifications as groups of
points in $N$-dimensional space. Notion of consistency is then intuitively
whether these two (potentially infinite) sets of points in space match or not.
This leads to a simple set based consistency function defined as
%
\begin{align*}
  \mathit{consistent} & :
    \mathsf{Mult}(\mathcal{P}(\mathcal{P}(\bz{})^N)) \times
    \mathsf{Mult}(\mathsf{Approx}(\region{N})) \to \mathbb{B} & \\
%
  \mathit{consistent}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    \mathsf{false} & \mathit{model} = \mathsf{once}(x) \wedge ix = \mathsf{mult}(y) \\
    \mathit{consistent'}(\mathit{peel}(ix), \mathit{peel}(model)) & \textit{otherwise}
  \end{cases} \\
%
  \mathit{consistent'} & :
    \mathcal{P}(\mathcal{P}(\bz{})^N) \times
    \mathsf{Approx}(\region{N}) \to \mathbb{B} & \\
%
  \mathit{consistent'}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    m = \mathit{ix} & \mathit{model} = \mathsf{exact}(m) \\
    m \supseteq \mathit{ix} & \mathit{model} = \mathsf{upper}(m) \\
    m \subseteq \mathit{ix} & \mathit{model} = \mathsf{lower}(m)
  \end{cases}
\end{align*}
%
The first function, $\mathit{consistent}$, checks whether the linearity of the
specification matches that of the indices, \ie{} if the specification allows
indices to be repeated or not.Then it delegates to $\mathit{consistent'}$
function which checks if the points observed in the array expression matches
the space defined by the specification. Lower bounds, marked by \texttt{atLeast}
modifier, require the space defined by the specification to remain inside the
set of indices, while an upper bound, market by \texttt{atMost} modifier,
requires the opposite: enclosure. In the absence of such modifiers, we expect
the space defined by observed indices correspond exactly those defined by the
region in the specification, hence requiring set equality.

Reader will realise that since index schemes allows infinite intervals in the
product, set equality cannot be done by exhaustively checking the points of one
are inside the other. Instead, we compile the region into interval constraints
and subscript schemes into membership constraints and pass it to
\textsc{Z3}~\citep{de2008z3} SMT solver to see if they are equal. The query
belongs to to quantifier free linear arithmetic, which is a decidable theory.
Performance of consistency checking using SMT solver is irrelevant as the number
of interval constraints and the number of indices that can reasonably appear in
an assignment is too small restricting the size of the formula being checked.

\mnote{It would be great if we had data on number of indexing expressions that
occur (counting the ones that flow in) and also the length of specifications
(which I think we do generate). This would justify my efficiency claims}.


\subsection{Infering specification automatically}
\label{subsec:inference}

We provide an inference procedure for generating specifications from
code, which are inserted automatically as comments. This helps support
maintenance of legacy code, and aids understanding of our
specification language. We illustrate inference using the
five-point stencil of \Cref{exm:checking}.

The preceding source code analysis converts the concrete syntax of array
subscripts into a subscript space in $\mathcal{P}(\bz)^N$.
Let $U$ range over finite maps from array variables to sets of
of subscript schemes.

 The
inference then attempts to construct a $\emph{Region}_N$ from this.

 For
each array variable $a \in \mathsf{dom}(U)$, the algorithm constructs a set of
$n$-dimensional rectangles covering all contiguous groups of schemes
in $U(a)$.


\begin{enumerate}[leftmargin=1.5em]
\item
A covering of (possibly overlapping) regions is computed iteratively
by the following steps until a fixed-point is reached:

\begin{enumerate}
\item \textbf{Coalesce intervals}
Intervals which are adjacent (contiguous in one dimension) are
coalesced.

\begin{defn}{[Contiguous]}
  An index scheme
  A subscript $S$ is said to be \emph{adjacent at index $j$} of another
  subscript $S'$ if for every index $i$ except $j$, $\pi_i(S) = \pi_i(S')$ but
  at $j$ then $\pi_j(S) \neq \pi_j(S')$ such that $|S| = |S'| + 1$.
\end{defn}
%
\item \textbf{Remove completely overlapped intervals}
\item \textbf{Covering}
\end{enumerate}
\end{enumerate}
