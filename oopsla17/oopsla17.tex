\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{minted}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{syntax}
\usepackage{indentfirst}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{stencilmacros}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\fvset{fontsize=\scriptsize}

\setlength{\grammarindent}{3em} % increase separation between LHS/RHS

\newcommand{\inbar}{\ \ \textbar\ \ }

% For evluation and empirical study
% Defines the commands (headers)
\input{resultsCmds}
% renews the commands with actual data
%\input{results}

\begin{document}
\title{Understanding and Verifying the Shape of Stencil Computations}

\author{Dominic Orchard}
\affiliation{
  \department{School of Computing}
  \institution{University of Kent}
}
\email{d.a.orchard@kent.ac.uk}


\author{Mistral Contrastin}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Mistral.Contrastin@cl.cam.ac.uk}

\author{Matthew Danish}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Matthew.Danish@cl.cam.ac.uk}


\author{Andrew Rice}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Andrew.Rice@cl.cam.ac.uk}

\maketitle

\begin{abstract}
  Arrays computations are the workhorse of numerical modelling and
  computational science.
  Many practitioners are aware of need to ensure program
  correctness, yet very few of the techniques from the programming
  research community are applied by scientists. We aim to change that
  by providing lightweight verification tools to scientists.
  We focus on one error-prone aspect of numerical code: the 
  data access pattern of arrays. 
  Firstly, we report on a code analysis study on twelve real-world
  computational science code base, identifying common idioms of array
  usage and their spatial properties. This provides much needed data
  on array programming idioms common in science, spanning roughly 1.5
  million lines of code.
  From this data, we 
  designed a lightweight declarative specification language capturing
  the majority of access patterns for arrays. We details its semantics
  and algorithms for checking and inference.
  We detail the design and implementation of a verification tool for
  our specification language, which both checks and infers
  specifications.
  We evaluate our tool on the our previous corpus of scientific code
  and give verification case studies of bugs that could be detected
  with our approach. We find roughly 60,000 targets for specification, showing the vast majority
  of stencil computations indeed have a simple, regular, static shape.
\end{abstract}
  
 %S ubsequently, Fortran continues to be a
%  popular language choice, due to its focus on arrays and its high
%  performance.

%  In this paper, we propose an alternate approach:
%  a specification language and automated tool for verifying the
%  spatial behaviour of stencils. The specification language is based
%  on the hypothesis that stencil computations read from arrays with a
%  regular, fixed pattern which can be captured by a simple
%  set of abstract combinators. These
%  specifications can be embedded as annotations in source code,
%  against which code can be checked for conformance. For legacy code,
%  spatial specifications can be inferred, providing documentation and
%  aiding future software maintenance. We evaluate our specification
%  language and verification tool against
%  a corpus of numerical Fortran code ($\sim$ 1 million lines) for
%  which we generate $\sim$60,000 specifications, showing the vast majority
%  of stencil computations indeed have a simple, regular, static shape.
%\end{abstract}

\section{Introduction}

\paragraph{Context of this research}

There is an increasing awareness of the need for program verification
techniques in
science~\cite{post2005computational,oberkampf2010verification,orchard2014computational}.
Whilst there are various kinds of automated and semi-automated
verification tools available, they see little use in science. This is
partly due to a lack of training and a lack of awareness. But its also
due to a lack of targetting. This paper is part of a line of research
to provide lightweight verification tools targetting
programming patterns common in computational science code, 
that are easy to use by scientists, and that integrate with common
practises and workflows.


\subsection{Terminology and notation}

\begin{definition}[Induction variables]
  An integer variable is a \emph{base induction variable} if it is the control
  variable of a ``\texttt{for}'' loop, incremented by $1$ per iteration. A variable
  is interpreted as an induction variable only within the scope of the loop
  body. Throughout, $i, j, k$ range over induction variables.

  A \emph{derived induction variable} is an expression of the form $a
  i + b$, \ie{}, an affine expression on an induction variable $i$.
\end{definition}

\begin{definition}[Array subscripts and indices]
  An \emph{array subscript}, denoted $a(\bar{e})$, is an expression
  which reads from an array $a$ at an \emph{index} specified by a
  comma-separated sequence of integer expressions denoted $\bar{e}$ or
  in expanded form as $(e_1, \ldots, e_n)$. An index $e_i$ is called
  \emph{relative} if the expression involves an induction variable.
  An \emph{absolute index} is a integer expression which is constant
  relative to the enclosing loop.
\end{definition}

\begin{definition}[Neighbourhood index]
\label{def:neighbour}
  For an array subscript $a(\bar{e})$ an index $e \in \bar{e}$ is a
  \emph{neighbourhood index} if $e$ is of the form $e \equiv i$, $e \equiv i +
  c$, or $e \equiv i - c$, where $c$ is an integer constant. That is, a
  neighbourhood index is a constant translation of an induction variable. (The
  relation $\equiv$ identifies terms up-to commutativity of $+$ and the inverse
  relationship of $+$ and $-$ \eg{}, $(-b) + i \equiv i - b$).
\end{definition}

\section{An Empirical Study of Array Computations in Scientific Fortran code}



\begin{enumerate}
\item Stencils are ubiquitious;
\item Most stencils read their data from source arrays with a static pattern
base on constant offsets from the mid-point;
\item Most stencils read their data from contiguous \emph{regions} in an array;
\item Most stencils read each index at most once.
\end{enumerate}

\subsection{Study}
%
\noindent
We put together a corpus of around 1 million lines of Fortran code from a
\numPackages{} scientific computing packages ranging in size and scope: The Unified Model (UM)~\cite{um},
E3MG~\cite{RePEc:aen:journl:2006se-a12}, BLAS~\cite{blas},
Hybrid4~\cite{GBC:GBC635}, GEOS-Chem~\cite{geos-chem}, Navier (based
on \cite{griebel1997numerical}), Computational Physics
2~\cite{nicholas2006computational},
ARPACK-NG~\cite{arpackng}, and
SPECFEM3D~\cite{specfem3d}. Appendix~\ref{app:corpus} provides
further detail on these packages.

\begin{itemize}
% (Vars, ...)
\item An assignment to a variable, with an RHS comprising some array
  computation, tends to correspond to a reduction (e.g., calculating
the max value in an array).

\end{itemize}

\section{A Specification Language for Shape}

\begin{figure}[t]
\begin{align*}
\def\arraystretch{1}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{$\mathbb{N}_{>0}$}
\newcommand{\depthRange}{$\mathbb{N}_{>0}$}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec} \;
                        \texttt{::} \; v \\
\nonterm{regionDec} ::= &  \texttt{region} \; \texttt{::} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\[0.4em]
%\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}
%\\[1em]
\nonterm{spec} ::= & [\nonterm{mult},] \; [\nonterm{approx},] \; \nonterm{region} \\
\nonterm{mult} ::= & \term{readOnce} \\
\nonterm{approx} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \nonterm{rvar} \; \mid \;
                       \stencil{p}{\dimTy}{}{} \; \\
& {\qquad\; \mid \; \stencil{f}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{b}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{c}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \nonterm{region} \, \term{+}
  \, \nonterm{region} \; \mid \; \nonterm{region} \; \term{*} \; \nonterm{region}} \\[0.25em]
%\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{rvar}}
%\\[0.5em]
%\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \}) [, \texttt{mutual}]
%  \\[0.5em]
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+\\[-1em]
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\end{figure}

\subsection{Specification syntax}
\label{subsec:syntax}

\Cref{fig:syntax} gives the syntax of stencil specifications, which is
detailed below. The entry point is the \nonterm{specification} production which
splits into either a \emph{region declaration} or a \emph{specification
declaration}.
Regions comprise \emph{region constants} which are
combined via region operators \term{+} and \term{*}.


\section{Analysis, Checking, and Inference}

\section{Evaluation}

\bibliography{references}

\appendix
% http://2017.splashcon.org/track/splash-2017-OOPSLA#Instructions-for-Authors
% "There is no page limit for bibliographic references and appendices,
% and, therefore, for the overall submission."
\input{appendix}

\end{document}
