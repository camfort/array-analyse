\documentclass[acmlarge,review,anonymous,10pt]{acmart}\settopmatter{printfolios=true}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{hyperref}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{syntax}
\usepackage{indentfirst}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{minted}
\usepackage{etoolbox}
\usepackage{enumitem}
\usepackage{thmtools}
\usepackage{thm-restate}

\newcommand{\fortran}[1]{\mintinline{fortran}{#1}}

\errorcontextlines 10000
\usepackage{stencilmacros}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=w),
  xleftmargin=3\parindent,
  numbersep=1em
}

\usemintedstyle{vs}

\setlength{\grammarindent}{3em} % increase separation between LHS/RHS

\newcommand{\inbar}{\ \ \textbar\ \ }

% For evluation and empirical study
% Defines the commands (headers)
\input{resultsCmds}
\input{studyResults}
% renews the commands with actual data
% \input{results}

\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{case}{Case}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\title{Verifying Spatial Properties of Array Computations}

\author{Dominic Orchard}
\affiliation{
  \department{School of Computing}
  \institution{University of Kent}
}
\email{d.a.orchard@kent.ac.uk}


\author{Mistral Contrastin}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Mistral.Contrastin@cl.cam.ac.uk}

\author{Matthew Danish}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Matthew.Danish@cl.cam.ac.uk}


\author{Andrew Rice}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Andrew.Rice@cl.cam.ac.uk}


\begin{abstract}
  Arrays computations are at the core of numerical modelling and
  computational science applications. However, low-level manipulation of array
  indices is a source of program error.  Many practitioners are aware
  of the need to ensure program correctness, yet very few of the
  techniques from the programming research community are applied by
  scientists. We aim to change that by providing targetted lightweight
  verification techniques for scientific code.  We focus on the all
  too common mistake of array offset errors as a generalisation of
  off-by-one errors.  Firstly, we report on a code analysis study on
  twelve real-world computational science code base, identifying
  common idioms of array usage and their spatial properties. This
  provides much needed data on array programming idioms common in
  scientific code.  From this data, we designed a lightweight
  declarative specification language capturing the majority of array
  access patterns via a small set of combinators. We detail a semantic
  model, and the design and implementation of a verification tool for
  our specification language, which both checks and infers
  specifications.  We evaluate our tool on our corpus of scientific
  code and give verification case studies of bug fixes that are
  detected by our approach. We found roughly 60,000 targets for
  specification across roughly 1.4 million lines of code, showing the
  vast majority of array computations read from arrays in a pattern with
  a simple, regular, static shape.
\end{abstract}
  
%  We focus on one error-prone aspect of numerical code: the 
%  data access pattern of arrays. 

\begin{document}
\maketitle

\section{Introduction}
\label{sec:introduction}
\input{introduction}

\section{An Empirical Study of Array Computations in Scientific Fortran code}
\label{sec:study}
\input{study}

\section{A Specification Language for the Shape of Array Patterns}
\label{sec:lang}
\input{lang}

\section{Equational \& Approximation Theories}
\label{sec:theory}
\input{theory}

\section{Semantic Model}
\label{sec:model}
\input{model}

\section{Analysis, Checking, and Inference}
\label{sec:algorithms}
\input{algorithms}

\section{Evaluation}
\label{sec:evaluation}
\input{evaluation}

\section{Related Work}
\label{sec:related-work}
\input{related-work}

\bibliography{references}

\appendix
% http://2017.splashcon.org/track/splash-2017-OOPSLA#Instructions-for-Authors
% "There is no page limit for bibliographic references and appendices,
% and, therefore, for the overall submission."
\input{appendix}

\end{document}
