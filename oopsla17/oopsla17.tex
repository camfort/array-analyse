\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{hyperref}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{syntax}
\usepackage{indentfirst}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{minted}
\usepackage{etoolbox}

\usepackage{thmtools}
\usepackage{thm-restate}


\errorcontextlines 10000
\usepackage{stencilmacros}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=w),
  xleftmargin=3\parindent,
  numbersep=1em
}

\usemintedstyle{vs}

\setlength{\grammarindent}{3em} % increase separation between LHS/RHS

\newcommand{\inbar}{\ \ \textbar\ \ }

% For evluation and empirical study
% Defines the commands (headers)
\input{resultsCmds}
\input{studyResults}
% renews the commands with actual data
% \input{results}

% Essential declarations
\theoremstyle{definition}
\newtheorem{defn}{Definition}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{case}{Case}

\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}



\title{Verifying Spatial Properties of Array Computations}

\author{Dominic Orchard}
\affiliation{
  \department{School of Computing}
  \institution{University of Kent}
}
\email{d.a.orchard@kent.ac.uk}


\author{Mistral Contrastin}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Mistral.Contrastin@cl.cam.ac.uk}

\author{Matthew Danish}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Matthew.Danish@cl.cam.ac.uk}


\author{Andrew Rice}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Andrew.Rice@cl.cam.ac.uk}


\begin{abstract}
  Arrays computations are the workhorse of numerical modelling and
  computational science. However, low-level manipulation of array
  indices is a source of program error.  Many practitioners are aware
  of the need to ensure program correctness, yet very few of the
  techniques from the programming research community are applied by
  scientists. We aim to change that by providing targetted lightweight
  verification techniques for scientific code.  We focus on the all
  too common mistake of array offset errors as a generalisation of
  off-by-one errors.  Firstly, we report on a code analysis study on
  twelve real-world computational science code base, identifying
  common idioms of array usage and their spatial properties. This
  provides much needed data on array programming idioms common in
  scientific code.  From this data, we designed a lightweight
  declarative specification language capturing the majority of array
  access patterns via a small set of combinators. We detail a semantic
  model, and the design and implementation of a verification tool for
  our specification language, which both checks and infers
  specifications.  We evaluate our tool on our corpus of scientific
  code and give verification case studies of bug fixes that are
  detected by our approach. We found roughly 60,000 targets for
  specification across roughly 1.2 million lines of code, showing the
  vast majority of array computations read from arrays in a pattern with
  a simple, regular, static shape.
\end{abstract}
  
%  We focus on one error-prone aspect of numerical code: the 
%  data access pattern of arrays. 

\begin{document}
\maketitle

\section{Introduction}

\paragraph{Context of this research}

There is an increasing awareness of the need for program verification
techniques in
science~\cite{post2005computational,oberkampf2010verification,orchard2014computational}.
Whilst there are various kinds of automated and semi-automated
verification tools available, they see little use in science. This is
partly due to a lack of training and a lack of awareness. But its also
due to a lack of targetting. This paper is part of a line of research
to provide lightweight verification tools targetting
programming patterns common in computational science code, 
that are easy to use by scientists, and that integrate with common
practises and workflows.


\subsection{Terminology and notation}

\begin{definition}[Induction variables]
  An integer variable is a \emph{base induction variable} if it is the control
  variable of a ``\texttt{for}'' loop, incremented by $1$ per iteration. A variable
  is interpreted as an induction variable only within the scope of the loop
  body. Throughout, $i, j, k$ range over induction variables.

  A \emph{derived induction variable} is an expression of the form $a
  i + b$, \ie{}, an affine expression on an induction variable $i$.
\end{definition}

\begin{definition}[Array subscripts and indices]
  An \emph{array subscript}, denoted $a(\bar{e})$, is an expression
  which reads from an array $a$ at an \emph{index} specified by a
  comma-separated sequence of integer expressions denoted $\bar{e}$ or
  in expanded form as $(e_1, \ldots, e_n)$. An index $e_i$ is called
  \emph{relative} if the expression involves an induction variable.
  An \emph{absolute index} is a integer expression which is constant
  relative to the enclosing loop.
\end{definition}

\begin{definition}[Neighbourhood index]
\label{def:neighbour}
  For an array subscript $a(\bar{e})$ an index $e \in \bar{e}$ is a
  \emph{neighbourhood index} if $e$ is of the form $e \equiv i$, $e \equiv i +
  c$, or $e \equiv i - c$, where $c$ is an integer constant. That is, a
  neighbourhood index is a constant translation of an induction variable. (The
  relation $\equiv$ identifies terms up-to commutativity of $+$ and the inverse
  relationship of $+$ and $-$ \eg{}, $(-b) + i \equiv i - b$).
\end{definition}

\section{An Empirical Study of Array Computations in Scientific Fortran code}

Hypotheses:
\begin{enumerate}
\item Loops over arrays mainly read from arrays with a static pattern
based on constant offsets from (base or dervied) induction variables;

\item Most loop-array computations of the previous form read
from a arrays with a contiguous pattern;

\item Most loop-array computations of the previous form read
from arrays with a pattern that includes the immediate
neighbours (i.e., offset 1 from the induction variable);

\item Many array computations are \emph{stencil computations},
with a static access pattern, writing
to an array at an index based on a constant offset from induction
variables.

\item Many array computations read from a particular index just once
\end{enumerate}

\subsection{Methodology}
%
\noindent
We constructed a corpus of around 1.4 million lines of Fortran code
(2.4 million including comments and white space) from a \numPackages{}
scientific computing packages ranging in size and scope: The Unified
Model (UM)~\cite{um}, E3MG~\cite{RePEc:aen:journl:2006se-a12},
BLAS~\cite{blas}, Hybrid4~\cite{GBC:GBC635},
GEOS-Chem~\cite{geos-chem}, Navier (based on
\cite{griebel1997numerical}), Computational Physics
2 (CP2) ~\cite{nicholas2006computational}, ARPACK-NG~\cite{arpackng}, and
SPECFEM3D~\cite{specfem3d}. \dnote{Include the rest}
Appendix~\ref{app:corpus} provides further detail on these packages.
Half of the packages come from research groups who 
are our project partners (\ie{}, they were
not selected carefully to skew results). BLAS was selected as it is
a common library in numerical code; similarly CP2 was selected as 
it presents a set of standard numerical analysis algorithms from a
popular computational physics textbook. 

We used Wheeler's \emph{SLOCCount} to get a count of the physical
source lines (excluding comments and blank
lines)~\cite{wheeler2001sloccount}; including non-physical lines
 our corpus totals \dnote{insert}.




\begin{itemize}
% (Vars, ...)
\item An assignment to a variable, with an RHS comprising some array
  computation, tends to correspond to a reduction (e.g., calculating
the max value in an array).
\end{itemize}

\subsection{Results}

\paragraph{Addressing the hypotheses}

\begin{enumerate}
\item Loops over arrays mainly read from arrays with a static pattern
based on constant offsets from (base or dervied) induction variables;
\end{enumerate}

%\begin{tabular}
%Neighbourhood or Constant Affine RHS &  Total 
%\end{tabular}

\section{A Specification Language for Shape}

\begin{figure}[t]
\begin{align*}
\def\arraystretch{1}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{$\mathbb{N}_{>0}$}
\newcommand{\depthRange}{$\mathbb{N}_{>0}$}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec} \;
                        \texttt{::} \; v \\
\nonterm{regionDec} ::= &  \texttt{region} \; \texttt{::} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\[0.4em]
%\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}
%\\[1em]
\nonterm{spec} ::= & [\nonterm{mult},] \; [\nonterm{approx},] \; \nonterm{region} \\
\nonterm{mult} ::= & \term{readOnce} \\
\nonterm{approx} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \nonterm{rvar} \; \mid \;
                       \stencil{p}{\dimTy}{}{} \; \\
& {\qquad\; \mid \; \stencil{f}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{b}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{c}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \nonterm{region} \, \term{+}
  \, \nonterm{region} \; \mid \; \nonterm{region} \; \term{*} \; \nonterm{region}} \\[0.25em]
%\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{rvar}}
%\\[0.5em]
%\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \}) [, \texttt{mutual}]
%  \\[0.5em]
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+\\[-1em]
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\end{figure}

\subsection{Specification syntax}
\label{subsec:syntax}

\Cref{fig:syntax} gives the syntax of stencil specifications, which is
detailed below. The entry point is the \nonterm{specification} production which
splits into either a \emph{region declaration} or a \emph{specification
declaration}.
Regions comprise \emph{region constants} which are
combined via region operators \term{+} and \term{*}.

Region constants specify a finite interval in a 
single dimension relative to the origin and are either \term{pointed},
\term{forward}, \term{backward}, or \term{centered}. The region names are
inspired by numerical analysis terminology, \eg{} the standard explicit method for
approximating PDEs is known as the \emph{Forward Time, Centered Space} (FTCS)
scheme~\citep{dawson1991finite}.

Each region
constant has a dimension identifier $d$ given as a positive natural number.
Each constant except \term{pointed} has a depth
parameter $n$ given as a positive natural number; \term{pointed}
regions implicitly have a depth of $0$.

A \term{forward} region of depth $n$ specifies a contiguous
region in dimension $d$ starting at the origin. This corresponds
to specifying neighbourhood indices in dimension $d$ ranging from $i$ to $i + n$
for some induction variable $i$. Similarly, a
\term{backward} region of depth $n$ corresponds to contiguous indices
from $i$ to $i - n$ and \term{centered}
of depth $n$ from $i - n$ to $i + n$. A \term{pointed}
stencil specifies a neighbour index $i$. For example, the
following shows four specifications with four consistent stencil
kernels reading from arrays \term{a}, \term{b}, \term{c} and \term{d}:
%%
\begin{minted}{fortran}
!= stencil forward(depth=2, dim=1) :: a
e(i, 0) = a(i, 0) + a(i+1, 0) + a(i+2, 0)

!= stencil backward(depth=2, dim=1) :: b
e(i, j) = b(i, j) + b(i-1, j) + b(i-2, j)

!= stencil centered(depth=1, dim=1) :: c
e(i, j) = (c(j-1) + c(j) + c(j+1))/3.0

!= stencil pointed(dim=3) :: d
e(i, j) = d(0, 0, i)
\end{minted}
%%
Not every dimension needs to be specified, \eg{},
specifications on lines $1$, $4$, and $10$ leave some dimensions unspecified.
The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointed} which marks absence
of the origin.  For example, the following is a
\term{nonpointed} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointed) :: a
b(i) = a(i-1) + 10*a(i-2)
\end{minted}
%
Not every dimension needs to be specified, \eg{},
specifications on lines $1$, $3$, and $7$ leave some dimensions
unspecified which leaves indices in these dimensions unconstrained.

The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointed} which marks absence
of the origin.  For example, the following is a
\term{nonpointed} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointed) :: a
b(i) = a(i-1) + 10*a(i-2)
\end{minted}

\paragraph{Combining regions}

The region operators \term{+} and \term{*} respectively combine
regions by union and intersection. The intersection of two regions
$r \term{*} s$ means that any indices in the specified code must be
consistent with both $r$ and $s$ simultaneously.
 Dually, for the union of two regions
 $r \term{+} s$ means that indices in the specified code must be
 in consistent with one of $r$ or $s$, or both.
For example, the following \emph{nine-point stencil}
has a specification given by the product of two \texttt{centered}
regions in each dimension:
%%
\begin{minted}[breakindent=2.9em]{fortran}
x = a(i, j)   + a(i-1, j)   + a(i+1, j)
y = a(i, j-1) + a(i-1, j-1) + a(i+1, j-1)
z = a(i, j+1) + a(i-1, j+1) + a(i+1, j+1)
!= stencil centered(depth=1, dim=1) * centered(depth=1, dim=2) :: a
b(i, j) = (x + y + z) / 9.0
\end{minted}
%
%This pattern is common in image convolution applications.
The specification ranges over the
values that flow to the array subscript on the left-hand side,
and so ranges over the intermediate assignments to \term{x},
\term{y}, and \term{z}. Each index in the code is consistent
with both specifications simultaneously, \eg{}, \texttt{a(i-1, j+1)}
is within the centered region in dimension $1$ and the centered region
in dimension $2$.

The union of two regions $r \term{+} s$ means that any indices
in the specified code must be consistent with either of $r$ or $s$.
For example, the following gives the specification of a five-point
stencil which is the sum of two compound \texttt{pointed} and
\texttt{centered} regions in each dimension:
%
\begin{minted}{fortran}
!= stencil centered(depth=1, dim=1)*pointed(dim=2) + centered(depth=1, dim=2)*pointed(dim=1) :: a
b(i,j) = -4*a(i,j) + a(i-1,j) + a(i+1,j) + a(i,j-1) + a(i,j+1)
\end{minted}
%%
Here the left-hand side of \texttt{+} says that when the second dimension
(induction variable $j$) is fixed at the origin, the first dimension
(induction variable $i$) accesses the immediate vicinity of the origin
(to depth of one). The right hand side of \texttt{+} is similar but the dimensions are reversed.
This reflects the symmetry under rotation of the five-point stencil.

\paragraph{Region declarations and variables}

Region specifications can be assigned to region variables via
region declarations. For example, the shape of a
``\emph{Roberts cross}'' edge-detection convolution~\cite{davis1975survey}
can be stated:
%%
\begin{minted}{fortran}
!= region :: r1 = forward(depth=1, dim=1)
!= region :: r2 = forward(depth=1, dim=2)
!= region :: robertsCross = r1*r2
!= stencil robertsCross :: a
\end{minted}
This is useful for common patterns, such as the five-point
pattern, as the regions can be defined once and reused.
%%
\paragraph{Modifiers}
%%
Region specifications can be modified
by \emph{approximation} and \emph{multiplicity} information
(in \textit{spec} in \Cref{fig:syntax}).
The \texttt{readOnce} modifier enforces that no index appears more
than once (that is, its multiplicity is one). For example, all of
the previous examples could have \texttt{readOnce} added:
%
\begin{minted}{fortran}
!= stencil readOnce, backward(depth=2, dim=1) :: a
b(i+1) = a(i) + a(i-1) + a(i-2)
\end{minted}
%
This specification would be invalid if any of the
array subscripts were repeated. This modifier provides a way to
rule out any accidental repetition of array subscripts.
The notion is similar to that of linear types~\cite{wadler1990linear}, where a value must be used
exactly once. We opt for the more informative and easily understood name
\texttt{readOnce}. This modifier is optional, so it need not
be present even if the stencil is linear.

In some cases, it is useful to give a lower and/or upper bound for a
stencil. This can be done using either the \term{atMost} or
\term{atLeast} modifiers. This is particularly useful in situations
where there is a non-contiguous stencil pattern, which cannot be expressed
precisely in our syntax. For example:
%
\begin{minted}{fortran}
!= stencil atLeast, pointed(dim=1)         :: a
!= stencil atMost, forward(depth=4, dim=1) :: a
b(i) = a(i) + a(i+4)
\end{minted}

\section{Semantic model}
\label{sec:model}

\noindent
We define a simple set-theoretic model of array access patterns
which serves as both a denotational model of the semantics
of our specification language and an abstract interpretation
domain for source code. This model has a number of uses: 
(1) it serves to explain the meaning of our specifications
(2) it is used in the inference and checking algorithms
(\Cref{sec:analysis}); (3) justifies an equational theory for
specifications in the next section; and (4) can be used to guide
correct implementations.

The model is defined over vectors of sets of integers which we call
\emph{index schemes}.  As an initial informal example, consider the
following simple stencil computation:
%
\begin{minted}{fortran}
do i = 1, n
  b(i) = a(i,0) + a(i+1,0)
end do
\end{minted}
%
The access pattern on array \term{a}, relative
to induction variable \term{i}, is captured
by a vector of length 2 containing integer sets $\langle{\{0, 1\},
  \mathbb{Z}\}}\rangle$. This describes that, in the first dimension,
the array is read at offsets of $0$ and $1$ from an induction
variable. In the second dimension, the index is unconstrained
as it is a constant.

Index schemes form a lattice which provides a rich set of equations
and properties, which we exploit. We first set up the 
domain of the model (\S\ref{sec:domain}), using it to define a semantics
for our specification language (\S\ref{sec:semantics}) and then as
the target for an abstract interpretation on imperative
code (\S\ref{sec:fromcode}).

\subsection{Lattice model of regions}
\label{sec:domain} 

%\begin{defn}[Extended integers]
%  We define the set \zinf{} as
%  $\mathbb{Z}$ extended with $\infty$ and $-\infty$. For any $a$ in
%  \zinf{}, we have $-\infty \leq a \leq \infty$. The resulting set is
%  a total order with top and bottom elements $-\infty$ and
%  $\infty$ respectively.
%\end{defn}

\begin{defn}[Index scheme]
  An $N$-dimensional \emph{index scheme} is a vector of length $N$ of
  extended integer sets, \ie{}, a member of $\mathcal{P}(\bz)^{N}$.
  An equivalent view of these vectors is as an $N$-times finite Cartesian
  product on subsets of $\bz$.  We use $S, T, U$ to denote index
  schemes.

Index schemes can be \emph{projected} in the $i^{\textit{th}}$ dimension by
  $\pi_i : {\mathcal{P}(\bz{})}^N \to \mathcal{P}(\bz{})$ where $1 \leq i
  \leq N$. For an index scheme $I$, we refer to $\pi_i(S)$ as the
  \emph{$i^{th}$ component} of $S$.
\end{defn}


\begin{restatable}{lem}{vectorIntersect}
\label{lem:vector-intersect}
  Intersection distributes over $N$-dimensional index schemes. 
  That is, for index schemes $S, T \in \mathcal{P}(\bz)^N$
%
  \begin{equation*}
    S \cap T = \prod_{i = 1}^{N} \pi_i(S) \cap \pi_i(T)
  \end{equation*}
\end{restatable}

 Union does not distribute over $N$-dimensional index schemes--
 however, a more restricted property holds.

\begin{restatable}{lem}{vectorUnion}
\label{lem:vector-union}
Let $S, T$ be $N$-dimensional index schemes such that
$\pi_i(S) = \pi_i(T)$ for all $1 \leq i \leq N$ apart 
from some dimension $k$ where $\pi_k(S) \neq \pi_k(T)$,
then:
%
  \begin{equation*}
    S \cup  T
    =
    \pi_1(S) \times \cdots \times
    (\pi_k(S) \cup \pi_k(T)) \times \cdots \times
    \pi_N(S)
  \end{equation*}
%  \begin{equation*}
%    S \cup T
%    =
%    (\prod_{i=1}^{k-1} \pi_i(S)) \times (\pi_k(S) \cup \pi_k(T)) \times \prod_{k+1}^{N} \pi_i(S)
%  \end{equation*}
%
\end{restatable}
%

\begin{defn}[Intervals with an optional hole]
  We define an extended notion of closed interval on $\bz{}$ which may contain
  a \emph{hole} at the origin, written \interv{a}{b}{c} where $a$ and $b$ are
  drawn from \bz{} with $a \leq 0 \leq b$
   and $c$ is drawn from $\mathbb{B} = \{ \mathsf{true}, \mathsf{false}
  \}$. Intervals are interpreted as sets as follows:
%
  \begin{equation*}
    \interv{a}{b}{c} \triangleq
      \{ n \mid a \leq n \leq b \wedge (\neg c \implies n \neq 0) \}
  \end{equation*}
%
  We denote the set of all such intervals (sets) as
   $\textit{Interval}$. If the superscript is
  omitted it is treated as $\mathsf{true}$.
\end{defn}

\begin{restatable}{lem}{intervalIdentities}
 \label{lem:interval-identities}
  We have the following dual identities for \bz{} intervals:
%
  \begin{align*}
    \interv{a}{b}{c} \cap \interv{d}{e}{f} & =
      \interv{\max \{a,d\}}{\min \{b,e\}}{c \wedge f} \\
    \interv{a}{b}{c} \cup \interv{d}{e}{f} & =
      \interv{\min \{a,d\}}{\max \{b,e\}}{c \vee f}
  \end{align*}
\end{restatable}
%

We define two subsets of index scheme: \emph{subscript} schemes and
\emph{interval} schemes:

\begin{defn}[Interval scheme]
  An interval scheme is a finite Cartesian product of intervals on
  \bz{} or \bz{} itself, 
  denoted by the set $\textit{Interval}^N$ for a product of $N$ intervals.
\end{defn}

\begin{defn}[Subscript scheme]
  A $N$-dimensional \emph{subscript scheme} is an $N$-dimensional
  interval scheme where:
  %
  \begin{equation*}
    \forall i.\ 1 \leq i \leq N \implies
      \pi_i (S) = [p, p] 
      \; \vee \;
      \pi_i (S) = \bz{}
    \end{equation*}
    That is, the $i^{th}$ component of the set is either a singleton
  in $\mathbb{Z}$ or the infinite interval.
\end{defn}
%
\dnote{May want a predicate as well}
   
\begin{defn}{(\emph{Region})}
  A region \region{N} is an $N$-dimensional index scheme
  (\ie{}, $\region{N} \subseteq \mathcal{P}(\bz)^N)$ defined as the smallest set satisfying the following:
%
  \begin{enumerate}
    \item If $R$ is in $\textit{Interval}^N$, then $R$ is in \region{N}.
    \item If $R$ and $S$ are in \region{N}, then so are $R \cap S$ and
      $R \cup S$.
  \end{enumerate}
\end{defn}

\begin{restatable}{prop}{regionLattice}
  \label{prop:regionLattice}
  $(\region{N},\cup,\cap,\subseteq)$ is a bounded distributive lattice with top
  $\top = \bz{}^N$ and bottom $\bot = \emptyset$.
\end{restatable}
%
\begin{proof}
  Straightforward, since $\cup$ and $\cap$ are on sets (and therefore commutative,
  associative, and absorptive with each
  other). Furthermore, $\mathbb{Z}^N \cap R = R$ and $\empty \cup R =
  R$ giving the bounds. Furthermore, the lattice is distributive since
 union distributes over intersection and vice versa
\end{proof}

\begin{defn}{}
  $\mathsf{Mult}$ and $\mathsf{Approx}$ are parametric labelled variant types
  with injections given by their definition:
%
  \begin{align*}
    \mathsf{Mult} \;\; a \;\; &
      \triangleq \mathsf{mult} \; a \;\mid\; \mathsf{only} \; a \\
    \mathsf{Approx} \;\; a \;\; &
      \triangleq \mathsf{exact} \; a \;\mid\; \mathsf{lower} \; a \;\mid\;
        \mathsf{upper} \; a
  \end{align*}
%
  \eg{}, $\mathsf{lower}$ is an injection $\mathsf{lower} : a \to \mathsf{Approx}
  \; a$ etc.
  These will be used in the following subsection to give meaning to the
  specification modifiers for approximation and multiplicity.
\end{defn}

\subsection{Denotational semantics for specifications}
\label{sec:semantics}

\noindent
An interpretation function $\interp{-}_N$ maps closed\footnote{That
  is, we assume there are no occurrences of \textit{rvar} in a
  specification being modelled.  Any \emph{open} specification
  containing region variables can be made closed by straightforward
  syntactic substitution with a (closed) \textit{region}.}
specifications to sets of $N$-dimensional index schemes with modifier
information, \ie{} specifications are mapped to
$\textsf{Mult} (\textsf{Approx} (\mathcal{P}({\bz})^N))$ where $N$ is
the maximum dimensionality of the specification being modelled.

The interpretation is overloaded on \emph{regions} in
\Cref{subfig:region-model}. Various intermediate notions are used.

\begin{defn}
Let $\textit{promote}_N : \mathbb{N}^+ \times \textit{Interval} \to
\textit{Interval}^N$ be a function generating an $N$-dimensional 
interval such that $\pi_i(\vecgen{N}{i}{\interv{a}{b}{c}}) = 
\interv{a}{b}{c}$ and $\pi_j(\vecgen{N}{i}{\interv{a}{b}{c}}) = 
\bz{}$ in all other dimensions $j$. 
\end{defn}

%
\begin{figure}[!t]
\begin{subfigure}[t]{0.5\textwidth}
\begin{align*}
\interp{-}_N & : \textit{region} \rightarrow \mathcal{P}(\bz)^N \\
  \interp{\stencil{p}{$i$}{}{}}_N & =
    \vecgen{N}{i}{\interv{0}{0}{\mathsf{true}}}\\
%
  \interp{\stencil{c}{$i$}{$k$}{\textcap{p}}}_N & =
    \vecgen{N}{i}{\interv{-k}{k}{\interp{\textcap{p}}}} \\
%
  \interp{\stencil{f}{$i$}{$k$}{\textcap{p}}}_N & =
    \vecgen{N}{i}{\interv{0}{k}{\interp{\textcap{p}}}} \\
%
  \interp{\stencil{b}{$i$}{$k$}{\textcap{p}}}_N & =
  \vecgen{N}{i}{\interv{-k}{0}{\interp{\textcap{p}}}}
\\
  \interp{\texttt{\textcap{r} + \textcap{s}}}_N & =
    \interp{\textcap{r}}_N \vee \interp{\textcap{s}}_N
\\
  \interp{\texttt{\textcap{r} * \textcap{s}}}_N & =
    \interp{\textcap{r}}_N \wedge \interp{\textcap{s}}_N \\[-1em]
\end{align*}
\caption{Interpretation of regions}
\label{subfig:region-model}
\end{subfigure}
\hspace{1em}
\begin{subfigure}[t]{0.4\textwidth}
\begin{align*}
\interpApprox{-} & : \textit{approx} \rightarrow (A \rightarrow
  \textsf{Approx} \, A) \\
\interpApprox{\texttt{atLeast}} & = \mathsf{lower} \\
  \interpApprox{\texttt{atMost}} & = \mathsf{upper} \\
  \interpApprox{\epsilon} & = \mathsf{exact} \\ \\
  \interpMult{-} & : \textit{mult} \rightarrow (A \rightarrow
  \textsf{Mult} \, A) \\
  \interpMult{\texttt{readOnce}} & = \mathsf{once} \\
  \interpMult{\epsilon} & = \mathsf{mult}
\end{align*}
\caption{Interpretation of modifiers}
\label{subfig:modifier-model}
\end{subfigure}
\label{fig:semantics}
\caption{Semantic model of specifications}
\end{figure}


The first four equations of \Cref{subfig:region-model} model region 
contants. The final two equations model the \term{+} and \term{*}
operators in terms of the join (union) and meet (intersection)
of interval schemes. Thus regions are modelled as members
of $\mathcal{P}(\bz)^N$. 

We mark in our model the presence of modifiers such as
\texttt{readOnce} and \texttt{atMost} as introduced in \Cref{}.
Approximation modifiers are interpreted as injections into the
$\mathsf{Approx}$ variant by $\interpApprox{}$ in
\Cref{subfig:modifier-model}.  The $\textsf{Approx}$ type corresponds
to the presence or absence of the spatial approximation modifier, with
\textsf{exact} when there is no such modifier and \textsf{lower} and
\textsf{upper} for \term{atLeast} and \term{atMost}. In a similar way,
multiplicity modifiers are interpreted as injections in the
$\mathsf{Mult}$ variant by $\interpMult{}$, corresponding to the to
the presence or absence of the \term{readOnce} modifier as shown in
\Cref{subfig:modifier-model}.

\begin{defn}[Semantics of specifications]
The intermediate interpretations of \Cref{fig:semantics}
are composed to give a model for the top-level specification
syntax as:
%
\begin{equation*}
  \interp{\texttt{stencil \textcap{mult}, \textcap{approx}, \textcap{region}}}_N =
    \interpMult{\textcap{mult}} \;
           {(\interpApprox{\textcap{approx}} \;
                    {\interp{\textcap{region}}_N)}}
\end{equation*}
\end{defn}
%
\begin{thm}
The semantic model $\interp{-}_N$ of $N$-dimensional specifications
is sound with respects to the equational theory of the language,
that is:
%
\begin{equation*}
\forall S, T, N . \quad
S \equiv T \; \Rightarrow \;
\interp{S}_N = \interp{T}_N
\end{equation*}
%
We define the equational theory in \Cref{sec:equational-theory}.
\end{thm}

\subsection{Abstract interpretation}
\label{sec:fromcode}

\begin{defn}
The function $\textit{schematic}_I$ parameterised by
a set of induction variables $I$, which maps
from an array subscript into a $n$-dimensional (closed) interval:
%
\begin{align*}
\textit{schematic}_I(\bar{e}) & =
\prod_{i \in |\bar{e}|} \textit{interval}(e_i)
\qquad
\textit{interval}_I(e) = \begin{cases}
[c, c] & e = i \pm c \, \wedge \, i \in I \\
\bz & FV(e) \cap I = \emptyset
\end{cases}
\end{align*}
Note that \textit{inveral} may be undefined (it is a partial function)
in which case \textit{schematic} is undefined if any of its
components are undefined.
\end{defn}



  


\section{Analysis, Checking, and Inference}

\section{Evaluation}

\bibliography{references}

\appendix
% http://2017.splashcon.org/track/splash-2017-OOPSLA#Instructions-for-Authors
% "There is no page limit for bibliographic references and appendices,
% and, therefore, for the overall submission."
\input{appendix}

\end{document}
