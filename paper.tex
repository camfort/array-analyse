\documentclass[9pt,preprint]{sigplanconf}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{graphics}
\usepackage{fancyvrb}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{minted}
\usepackage{breqn}
\usepackage{enumitem}
%\usepackage{subcaption}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{tikz}
\usepackage{xypic}
\usepackage{natbib}

\usetikzlibrary{calc}

%% http://tex.stackexchange.com/questions/55068/is-there-a-tikz-equivalent-to-the-pstricks-ncbar-command
\tikzset{
    ncbar angle/.initial=90,
    ncbar/.style={
        to path=(\tikztostart)
        -- ($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)
        -- ($(\tikztotarget)!($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztostart)$)
        -- (\tikztotarget)
    },
    ncbar/.default=0.5cm,
}

\tikzset{round left paren/.style={ncbar=0.4cm,out=110,in=-110}}
\tikzset{round right paren/.style={ncbar=0.4cm,out=70,in=-70}}


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=),
  xleftmargin=\parindent
}

\usemintedstyle{vs}

\definecolor{darkblue}{rgb}{0.0,0.0,0.5}
\definecolor{darkgreen}{rgb}{0.0,0.4,0.0}
\definecolor{darkdarkgreen}{rgb}{0.0,0.35,0.0}

\usepackage{hyperref}
\hypersetup{
    unicode=false,          % non-Latin characters in Acrobat's bookmarks
    pdftoolbar=true,        % show Acrobat toolbar?
    pdfmenubar=true,        % show Acrobat menu?
    pdffitwindow=false,      % page fit to window when opened
    pdftitle={},    % title
    pdfauthor={}
    pdfsubject={},   % subject of the document
    pdfnewwindow=true,      % links in new window
    pdfkeywords={keywords}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=darkblue,          % color of internal links
    citecolor=darkblue,        % color of links to bibliography
    filecolor=green,      % color of file links
    urlcolor=blue,          % color of external links
}


\CustomVerbatimEnvironment{SpecVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98,numbersep=0.9em}
\CustomVerbatimEnvironment{ExmVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,
xrightmargin=0.2cm,baselinestretch=0.98,numbers=left,numbersep=0.9em,commandchars=\\\{\}}
\CustomVerbatimEnvironment{IVerbatim}{Verbatim}{fontsize=\relsize{-1},xleftmargin=0.5cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98,numbersep=0.9em}


\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\definecolor{darkorange}{rgb}{0.5,0.2,0.0}
\definecolor{marco}{rgb}{0.0,0.3,0.5}
\definecolor{gray}{rgb}{0.2,0.2,0.2}

\newcommand\mdef{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

\newcommand{\bn}{\mathbb{N}}

\newcommand{\todo}[1]{\textcolor{blue}{Dom: #1}}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}

\newcounter{block}

\newtheorem{lemma}[block]{Lemma}
\newtheorem{proposition}[block]{Proposition}

\theoremstyle{definition}

\newtheorem{theorem}[block]{Theorem}
\newtheorem{remark}[block]{Remark}
\newtheorem{example}[block]{Example}
\newtheorem{definition}[block]{Definition}

% Writing macros
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\newcommand{\dimId}{\texttt{dim}}

% Semantics related
\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

% Syntax macros
\newcommand{\nonterm}[1]{\textit{#1}}
\newcommand{\term}[1]{\texttt{#1}}

\newcommand{\stenRefl}[1]{\term{pointwise} \, (\term{dim=}#1)}
\newcommand{\stenFwd}[3]{\term{forward} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\stenBwd}[3]{\term{backward} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\stenCen}[3]{\term{centered} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\irrefl}{\texttt{nonpointwise}}

\newcommand{\stenReflS}[1]{\term{point} \, (\term{dim=}#1)}
\newcommand{\stenFwdS}[2]{\term{fwd} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\stenBwdS}[2]{\term{bwd} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\stenCenS}[2]{\term{cen} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\irreflS}{\texttt{nonpoint}}

\newcommand{\stenFwdSR}[3]{\term{fwd} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenBwdSR}[3]{\term{bwd} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenCenSR}[3]{\term{cen} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenReflSR}[1]{\term{point} (\term{dim=}#1)}

% SYNTAX OPERATIONS AND PREDICATES
%\newcommand{\neigh}{\textsf{neigh}}
\newcommand{\arrayTy}{\textsf{array}}
\newcommand{\rhsExp}{\textsf{rhsExp}}
\newcommand{\var}{\textsf{var}}

%% VECTOR NOTATIONS
\newcommand{\vect}[1]{\textbf{#1}}

\newcommand{\vtwohs}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{cc}#1 \, & \, #2\end{array}\right]\!}

\newcommand{\vtwoh}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{cc}#1 \; & \; #2\end{array}\right]}

\newcommand{\vthreeh}[3]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{ccc}#1 \; & \; #2 \; & \; #3\end{array}\right]}
\newcommand{\vtwo}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}#1\\#2\end{array}\right]}
\newcommand{\vthree}[3]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}$#1$\\$#2$\\$#3$\end{array}\right]}
\newcommand{\stwo}[4]
%{\vtwo{#1}{#2}\!\vtwo{#3}{#4}}
{\setlength{\arraycolsep}{0.1em}
\left[\begin{array}{rr}$#1$ & $#3$\\$#2$ & $#4$\end{array}\right]}

\newcommand{\singleEntry}[2]{\textbf{J}_{#2}^{#1}}
\newcommand{\zeroEntry}[2]{\textbf{K}_{#2}^{#1}}

%% OPERATIONS ON SPANS and VECTORS
\newcommand{\containedin}{\sqsubseteq}

%% MODEL
\newcommand{\effdims}[2]{\mathit{constr}(#1)_{#2}}

\newcommand{\trule}[1]{{\footnotesize{(\text{#1})}}}
%\include{results}

\title{Verification of Stencil Computations with Spatial
  Specifications}
%\titlebanner{DRAFT -- Do not distribute}
\authorinfo{}{}{}
%\preprintfooter{DO NOT DISTRIBUTE}

\begin{document}
\maketitle

\keywords{program verification, specification, stencils}

\bibliographystyle{abbrvnat}

\section{Introduction}

\emph{Stencils} are a ubiquitous programming pattern, common in
scientific and numerical computing applications. Informally, a stencil
computation computes an array whose value at each index $i$ is
calculated from a \emph{neighbourhood} of values around $i$ in some
input array(s), \eg{}, the Game of Life, convolutions in image
processing, approximations to differential equations. For example, the
following computes the one-dimensional discrete Laplace transform (an
approximation to a derivative) in Fortran:
%
\begin{minted}{fortran}
do i = 1, (n-1)
      b(i) = a(i-1) - 2*a(i) + a(i+1)
end do
\end{minted}
%
Values \texttt{b(i)} are calculated from a neighbourhood of elements
around \texttt{i} in the input array \texttt{a}.  In this example, the
access pattern is simple and easily understood. More complex
stencil computations are more prone to errors from simple lexical
mistakes. For example, the following is a three-line snippet from a
Navier-Stokes fluid simulator in which two arrays are read with
different data access patterns, across two dimensions.
%%
\begin{minted}[firstnumber=20,xleftmargin=2em]{fortran}
du2dx = ((u(i,j)+u(i+1,j))*(u(i,j)+u(i+1,j))+   &
  gamma*abs(u(i,j)+u(i+1,j))*(u(i,j)-u(i+1,j))- &
  (u(i-1,j)+u(i,j))*(u(i-1,j)+u(i,j))-          &
  gamma*abs(u(i-1,j)+u(i,j))*(u(i-1,j)-u(i,j))) &
  /(4.0*delx)

duvdy = ((v(i,j)+v(i+1,j))*(u(i,j)+u(i,j+1))+   &
  gamma*abs(v(i,j)+v(i+1,j))*(u(i,j)-u(i,j+1))- &
  (v(i,j-1)+v(i+1,j-1))*(u(i,j-1)+u(i,j))-      &
  gamma*abs(v(i,j-1)+v(i+1,j-1))*(u(i,j-1)-     & 
  u(i,j))) / (4.0*dely)

laplu = (u(i+1,j)-2.0*u(i,j)+u(i-1,j))/delx/delx+ &
  (u(i,j+1)-2.0*u(i,j)+u(i,j-1))/dely/dely

f(i,j) = u(i,j)+del_t*(laplu/Re-du2dx-duvdy)
\end{minted}
%%
The access pattern is much harder to understand than the
one-dimensional Laplace.  The miasma of indexing expressions of the
form \texttt{var(i$\pm$a, j$\pm$b)} is not only hard to read, but is
prone to simple textual input mistakes, \eg{}, swapping \texttt{-} and
\texttt{+}, missing an indexing term, or transforming the wrong
variable \eg{} \texttt{(i+1,j)} instead of \texttt{(i,j+1)}.

In practice, we find that the usual development procedure for complex
stencil computations involves some ad hoc testing to ensure that no
transcription mistakes have been made. This may involve visual
inspection of the results, based on a rendered image. Typically such
testing is then discarded once the code is seen to be correct.

This is not the only information that is typically discarded. The
shape of the indexing pattern is often a result of choices made in the
numerical-analysis discretisation procedure used to convert a set of
continuous equations into a discrete approximation. Rarely are these
decisions captured in the source code, yet the shape of access is
usually uniform and is given a perspicuous and concise description in
numerical analysis literature \eg{}, ``\emph{centered in space, to a
  depth of 1}'' referring to indexing terms \texttt{a(i)},
\texttt{a(i-1)} and \texttt{a(i+1)}.

To support the development of correct stencil computations, we propose
a simple, abstract specification language for the data access pattern
of stencils. The shape of the stencil computation in the
Laplace example is specifed in our language as:
%
\begin{minted}[linenos=false]{fortran}
!=  stencil centered(depth=1, dim=1) :: a
\end{minted}
%
This describes that \texttt{a} is accessed with a symmetrical pattern
(``centered'') to a depth of one in each direction in its first
dimension.  The stencil computation shape in the Navier-Stokes example
is specified as:
%
\begin{minted}[linenos=false,xleftmargin=4em,breakindent=3em]{fortran}
!= stencil centered(depth=1,dim=1) * pointwise(dim=2) + centered(depth=1,dim=2) * pointwise(dim=1) :: u

!= stencil forward(depth=1,dim=1) * backward(depth=1,dim=2) :: v
\end{minted}
%
The specification requires that, over the whole fragment, \texttt{u}
is accessed with a centered pattern to depth of 1 in both dimensions
(this is known as the \emph{five-point stencil}) and \texttt{v} is
accessed in a neighbourhood bounded forwards to depth of $1$ in the
first dimension and backward to a depth of $1$ in the second
dimension.

We provide a verification tool for such specification which can check
the correctness of code against the specification, and can also infer
specifications, synthesising these as comments in the
source code. The main features and benefits of our approach are as follows:
%
\begin{itemize}
\item The main use case is that a programmers writes a specification
  first (perhaps informed by their numerical analysis), then writes
  the corresponding source code, and lastly has the tool check its
  conformance to the specifications. This specify-and-check approach
  removes the usually ad hoc testing effort, and provides the
  opportunity for easy re-verification in the event of any refactoring
  of software maintenance activities.
%
\item The specification provides a concise description which can be
  preserved in the source code to provide documentation to future
  developers, contrasting with ad hoc tests which are usually
  discarded or specialised to the development environment. Separate from the
  verification procedure, the infer-and-synthesise mode of the tool
  provides a way to automatically generate additional useful
  documentation for future users.
%
\item Specifications are integrated into the code as comments for easy
integration with existing tools, as well as
  documentation systems (\eg{}, we support Doxygen and FORD syntax).
%
\item Our specification format is deliberately abstract, with a small
  number of combinators that \emph{do not involve any indexing
    expressions}, \eg{} does not involve expressions like
  \texttt{a(i+1,j-1)}. This contrasts with other stencil specification
  approaches. For example, the work of Kamil et al.~\cite{kamil2016verified}
  provides full-functionality specifications of stencil computations from which
  equivalent DSL code can be generated.  If a user wishes to specify, say, the
  Naiver-Stokes stencil above, they must write a specification which is very
  similar, involving textually dense array-indexing expressions. Therefore any
  low-level mistakes that could be made programming complex indexing code could
  also be made when writing a specification. Our specifications are much more
  abstract, and also more lightweight with the aim of aiding adoption by
  scientists.
\end{itemize}

It should be noted that our verification tool does not deal in the
class of bugs that can be detected automatically (\emph{push-button
  verification}). Instead, stencil computation bugs must largely be
identified relative to a specification of the intended behaviour.

In this paper, we make the following contributions:
%
\begin{itemize}
\item we introduce our specification language for stencils
  that captures many common forms of data access pattern
  (\S~\ref{sec:lang});

\item we detail checking and inference algorithms for our
  specifications (\S~\ref{sec:analysis}), derived from a
  denotational model for the specificaiton language
  (\S~\ref{sec:semantics});

\item we provide an implementation of our approach as an extension to
  CamFort, an open-source program analysis tool for Fortran;

\item we report on a quantitative study of stencil computations on a
  corpus of numerical Fortran programs (ranging from small to large)
  (\S~\ref{sec:evaluation}), totalling one million lines of code. Our tool
  identifies and infers specifications for 35,000 stencil computations in the
  corpus. Approximately 10\% of the stencils we found are non-trivial,
  corresponding to code which is a possible source of errors. This validates
  our hypothesis that the majority of stencil computations have a regular
  shape, and validates the design of our language in its capability to capture
  many core patterns.

\item We give a detailed verification case study of two
  particular stencil computation commonly used in scientifc computing,
  simulating programming errors. Our approach is able to detect all
  possible indexing errors for these computations.
\end{itemize}
%

\newcommand{\domainVal}{\mathbb{Z}_\infty}
\section{Stencil specifications}

\paragraph{Notation and convention}
%\label{sec:notation}

\renewcommand*{\arraystretch}{0.8}
For the target language, $e$ ranges over expressions (may be impure) and $v$
over its (imperative) variables. %By
%``variable'', we mean in the imperative sense (named binders to memory cells).

\begin{definition}[Base induction variable]
  An integer variable is a \emph{base induction variable} (or simply
\emph{induction variable} for brevity) if it is the
  control variable of a ``for'' loop (or equivalent, \eg{},
  \texttt{do} in Fortran for our implementation) incremented by $1$
  per iteration. The variable is interpreted as a based induction
variable only within the scope of the loop body. Induction varaibles 
are ranged over by $i, j, k$ throughout.
%TODO: consider mentioning derived, non-based induction variables
% as we did before.
\end{definition}

\begin{definition}[Array subscripts and indices]
  An \emph{array subscript}, denoted $a(\bar{e})$, is an expression
  which reads from an array $a$ at an \emph{index} specified by a
  comma-separated sequence of integer expressions denoted $\bar{e}$ or
  in expanded form as $(e_1, \ldots, e_n)$. An \emph{index} $\bar{e}$
  is called \emph{relative} if each $e \in \bar{e}$ is defined in
  terms of an induction variable.

  Relative indices contrast with absolute indices where each $e \in
  \bar{e}$ is a constant integer expression relative to the containing
  loop, \ie{}, $e$ is not defined in terms of an induction variable.
\end{definition}

\begin{definition}[Neighbourhood index]
\label{def:neighbour}
  For an array subscript $a(\bar{e})$ an index $\bar{e}$ is called a
  \emph{neighbourhood index} if every $e \in \bar{e}$ is of the form
  $e \equiv i$ or $e \equiv i + c$ or $e \equiv i - c$ where $c$ is an
  integer constant. That is, a neighbourhood index is a relative index
  where each component is a constant translation of a base induction
  variable. (The relation $\equiv$ here identifies terms up-to
  commutativity of $+$ and the inverse relationship of $+$ and $-$
  \eg{}, $(-b) + i \equiv i - b$). 
\end{definition}

\begin{definition}[Stencil computations]
  Let $a$ be an array of dimensionality $n$ and $\overline{b}$ a
  collection of arrays of arbitrary (possible differing)
  dimensionalities.  
  A \emph{stencil computation} comprises an iteration by a set $I$ of at
  most $n$ induction variables 
  over a subset of the index space of $a$. Elements of $a$ are determined by an
  assignment $a(\bar{e}) = e_r$ where each $e \in
  \bar{e}$ is either a neighbourhood or constant index.
  For all arrays $b \in \bar{b}$ and array subscripts $b(\var{e'})$ in
  $e_r$ and that flow to $e_r$, then each $e' \in \bar{e'}$ is also
  either a neighbourhood or constant index.

  We refer to the assignment $a(\bar{e}) = e_r$ and all the associated
  statements with dataflow to $e_r$ as the \emph{stencil kernel}.
\label{def:stencil}
\end{definition}

Specification declarations associate to a stencil kernel 
a specification for the array access on one or more array
variables $\bar{v}$ within that kernel.

% specifying the shape of indexing expressions for
%arrays $\bar{v}$ that are simultaenously permitted and expected within
%the code to which the specification is given.

\begin{definition}[Consistency, informal]
  A stencil specification defines a \emph{region} associated to an
  array variable $a$ against which a stencil kernel should be
  \emph{consistent}. Informally, the region defined by a specification
  is an $n$-dimensional rectangle crossing the origin.
  Consistency is then a two way requirement.
  On the one hand, all array subscripts contributing to the kernel
  should be consistent with the region; on the other, all parts of the
  region should have an index which fits the space. 
\end{definition}
\todo{Improve the above- haven't quite introduce enough yet to say
more}

\begin{figure}[t]
\vspace{-0.5em}
\begin{align*}
\def\arraystretch{1.2}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{\mathbb{N}_{>0}}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec} \;
                        \texttt{::} \; v \\
\nonterm{regionDec} ::= &  \texttt{region} \; \texttt{::} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\[0.4em]
%\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}
%\\[1em]
\nonterm{spec} ::= & [\nonterm{mult},] \; [\nonterm{approx},] \; \nonterm{region} \\
\nonterm{mult} ::= & \term{readOnce} \\
\nonterm{approx} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \nonterm{rvar} \; \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \stenRefl{\dimTy}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \;\stenFwd{\mathbb{N}_{>0}}{\dimTy}{\;[, \texttt{nonpointwise}]}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \stenBwd{\mathbb{N}_{>0}}{\dimTy}{\;[, \texttt{nonpointwise}]}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \stenCen{\mathbb{N}_{>0}}{\dimTy}{\;[, \texttt{nonpointwise}]}} \\
\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{region} \, \term{+}
  \, \nonterm{region} \; \mid \; \nonterm{region} \; \term{*} \; \nonterm{region}} \\[0.5em]
%\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{rvar}}  
%\\[0.5em]
%\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \}) [, \texttt{mutual}]
%  \\[0.5em]
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+\\[-0.5em]
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\vspace{-0.8em}
\end{figure}


\subsection{Specification syntax}
\label{sec:syntax}

Figure~\ref{fig:syntax} gives the syntax of stencil specifications,
which we introduce in stages below.  The top-level is given by the
\nonterm{specification} production which splits into either a
\nonterm{regionDec} (region declaration) or a \nonterm{specDec}
(specification declaration). 

Regions comprise \emph{region constants} which are 
combined via region operators \term{+} and \term{*}.

\paragraph{Region constants}

Region constants specify a pattern of continguous array accesses in a
single dimension.  Region constants are either \term{pointwise},
\term{forward}, \term{backward}, or \term{centered}.  Each region
constant has a dimension identifier $d$ given by a natural number
greater than 0. Each constant except \term{pointwise} is given a depth
parameter $n$, a natural number greater than 0; \term{pointwise}
regions implicitly have a depth of $0$. 

A \term{forward} region of depth $n$ specifies continguous
neighbourhood indices in dimension $d$ ranging from $i$ to $i + n$
inclusively for some induction variable $i$.  Similarly, a
\term{backward} region of depth $n$ specifies contiguous neighbour
indices in dimension $d$ from $i$ to $i - n$, and \term{centered}
of depth $n$ from $i - n$ to $i + n$. A \term{pointwise}
stencil specifies a neighbour index $i$. For example the
following shows four specifications with four consistent stencil
kernels reading from arrays \term{a}, \term{b}, \term{c} and \term{d} respectively:
%%
\begin{minted}{fortran}
!= stencil forward(depth=2, dim=1) :: a
e(i, 0) = a(i, 0) + a(i+1, 0) + a(i+2, 0)
!= stencil backward(depth=2, dim=1) :: b
e(i, j) = b(i, j) + b(i-1, j) + b(i-2, j)
!= stencil centered(depth=1, dim=2) :: c
e(i, j) = (c(j-1) + c(j) + c(j+1))/3.0
!= stencil pointwise(dim=3) :: d
e(i, j) = d(0, 0, i)
\end{minted}
%%
Note that every dimension need not be specified for; in the above, the
specifications on lines $1$ and $5$ and $7$ are the principal specifications
for code on lines $2$ and $6$ and $8$, but the specification on line
$3$ is not principal for line $4$;
we return to the notion of principality later.

The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointwise} which marks that
the region does not include indices which are purely base induction
variables, \ie{}, offset by $0$.  For example, the following is a
\term{nonpointwise} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointwise) :: a
b(i) = a(i-1) + a(i-2)
\end{minted}
%
The \term{pointwise} regions cannot have a \term{nonpointwise} attribute.

\paragraph{Combining regions}

The region operators \term{+} and \term{*} provide ways to combine
regions in a disjunctive and conjuctive fashion respectively.

The conjuction of two regions $r \term{*} s$ means that any indices
in the specified code must be consistent with both $r$ and $s$ at
the same time. Dually, there must be an index which is consitent
with every component of region $r$ and 

\section{A model}

We define a simple set-theoretic denotational model of the semantics
of our stencil specification language. This has a number of purposes:
(1) it serves to explain exactly the meaning of our specifications
(2) it is 
used as the basis of the inference, checking, and synthesis algorithms
(\S~\ref{sec:analysis}); (3) justifies the equational theory and
approximations of the previous section; and (4) can be used to guide
correct implementations. The model domain is over sets of vectors
which we call \emph{index schemes}, which we introduce first before
the model in \S~\ref{subsec:model}.

\begin{definition}
  An \emph{index scheme} is a vector of size $n$ (an $n$-vector) with
  values drawn from $\domainVal = \mathbb{Z} \cup \{\infty\}$.  Values
  in $\mathbb{Z}$ represent the offsets of neighbourhood indices
  (\ie{}, the constant integer $c$ in an indexing expression of the
  form $i \pm c$, Def.~\ref{def:neighbour},
  p.~\pageref{def:neighbour}) and $\infty$ represents any constant
  inddex. Throughout $u, v, w$ range over
  index schemes and $u_i$ denotes the $i^{th}$ element of $u$. We
  write $(\domainVal)^n$ for the set of $n$-dimensional schemes.
\end{definition} 

Indexing schemes give an abstract
representation of array subscripts in the source language.
Our model represents the meaning of stencil specifications
as indexing schemes, which explain the range of possible
indexing behaviours which are consistent with the specification.
The relationship between indexing schemes and source language
terms is given precisely by the following function \textsf{schematic} which
maps syntactic index expressions to indexing schemes. This
is used in inference and checking.

\newcommand{\schemeOne}{\textsf{s}_I}
%\newcommand{\schemeOne}{\textsf{schema$^1_I$}}
\newcommand{\schemeN}{\textsf{schematic}_I}
%\newcommand{\schemeN}{\textsf{schema$^n_I$}}
\begin{definition}%[Schematic]
\label{def:schematic}
Let $\schemeOne$ be a partial function, parameterised by a set of
induction variables $I$, mapping expression syntax to
$\domainVal$ values:
%%
\begin{align*}
\schemeOne(e)
 & =  \begin{cases}
c & e \equiv i + c \;\; \wedge \;\; i \in I \\
-c & e \equiv i - c \;\; \wedge \;\; i \in I \\
\infty & \textit{$I \not\subseteq \textit{FV}(e)$} \\
\bot   & \textit{otherwise}
\end{cases}
\end{align*}
where $\textit{FV}(e)$ is the set of free variables in $e$. In the
first two cases, expressions that are a constant offset of an 
induction variable (\ie{}, neighbourhood indices) are mapped to the
offset $c$ or $-c$ $\in \domainVal$. In the third case, if the
expression is not a neighbourhood index, but neither is it a relative
index (\ie{}, it is not defined in terms of an induction variable) then it
is mapped to $\infty \in \domainVal{}$. Otherwise, $\schemeOne(e)$
is undefined (returns $\bot$). 

The partial function $\schemeN$, also parameterised by a set of
induction variables $I$, uses the above operation $\schemeOne$ to
 maps from the syntax of indices to index schemes, \ie{} values of 
$\domainVal^n$. It is defined on the syntax of index
expressions $\bar{e} = (e_1, ..., e_n)$ as:
\begin{align*}
\schemeN(e_1, ..., e_n) & =
[\schemeOne(e_1) ... \schemeOne(e_n) ]
\quad \textit{iff} \;\; \forall x . \schemeOne(e_x) \neq \bot
\end{align*}
%
Thus, for an indexing expression, if each component is a neighbourhood
index, then $\schemeN$ maps it to an indexing scheme.
\end{definition}

\begin{definition}[Generalisation]
Given two schemes $v, w$ of dimensionality $n$,
then $w$ is said to \emph{generalise} $v$
(or conversely $v$ \emph{specialises} $w$),
written $v \preceq_n w$, iff the following holds:
%%
\[
v \preceq_n w \;\; \Leftrightarrow  \;\;
  \forall i\!\in\!\{ 1, \ldots, n \} . \, (w_i = \infty \, \vee \, v_i = w_i)
\]
%%
That is, two schemes are related by the (reflexive and transitive) binary relation
$\preceq_n$ over $(\mathbb{Z}_{\infty})^n$ if in each dimension
the two schemes are equal or $w_i = \infty$
in place of some $\mathbb{Z}$ in $v_i$ for $v \preceq_n w$.
Thus, the element $\infty$ generalises any index in the same dimension.
%
\end{definition}

\begin{example}
Consider the following three indexing schemes
corresponding to array indexing terms
$(i, j+1)$, $(1, j+1)$ and $(3, j)$:
%
\begin{align*}
\begin{array}{ll}
\schemeN{(i, j+1)} & =\vtwoh{0}{1} \\
\schemeN{(1, j+1)} & = \vtwoh{\infty}{1} \\
\schemeN{(3, j)} & = \vtwoh{\infty}{0}
\end{array}
\end{align*}
There is one notion of generalisation between these
schemes, namely that $\vtwoh{0}{1} \preceq_2 \vtwoh{\infty}{1}$.
At the level of syntax, this translates to saying
$(i, j+1)$ can be instantiated (specialised) to $(3, j+1)$. 

As an example of undefined \textsf{schematic},
$\textsf{schematic}(i*2, j) = \bot$ as its first index is a
non-neighbour relative index, which is outside the scope of our
specification language.
\end{example}

Our terminology of \emph{indexing schemes} and
\emph{generalisation} is by analogy
with the \emph{type schemes} and \emph{type generalisation} of
polymorphic types in ML~\cite{milner1978theory}. Our notion is
much more rigid however, as our schemes do not bind names.

\begin{definition}[Quotienting schemes]
A scheme $u$ can be quotiented by a set of dimension identifies
by the operator $/_{n,I}$ where $I$ is a set of dimension
identifiers drawn from $\mathbb{N}_{\leq n}$ where 
\begin{equation*}
u/_{n,I} = [ ]
\end{equation*}
\end{definition}

\subsection{Denotational model}

Our model is given by the interpretation function $\interp{-}_n$
(where $n$ is the maximum dimensionality of the specification being
modelled) mapping closed\footnote{That is, we assume there are no
  occurrences of \textit{rvar} in a specification being modelled.  Any
  \emph{open} specification containing region variables can be made
  closed by straightforward syntactic substitution with a (closed)
  \textit{region}.} specifications to sets of
$n$-dimensional indexing schemes. The interpretation is overloaded on
\emph{regions} in Figure~\ref{fig:region-model} and on the top-level
of a specification \textit{spec} in Figure~\ref{fig:spatial-model}.

We first define some intermediate notations and definitions.

\begin{definition}A \emph{single-entry vector} of size $n$, denoted
$\singleEntry{r}{n}$, is a vector where the $r^{th}$ entry is $1$
and all others are $\infty$, \eg{}, $\singleEntry{1}{2} =
\vtwoh{1}{\infty}$ and $\singleEntry{2}{3} = \vthreeh{\infty}{1}{\infty}$.
Thus, a single-entry vector is an indexing scheme which generalises
all other schemes that have $1$ as their $r^{th}$ entry,
describing a neighbour offset of $1$.
\end{definition}

\begin{definition}
A \emph{zeroed single-entry vector} of size $n$, denoted
$\zeroEntry{r}{n}$, is a vector where the $r^{th}$ entry is $0$ and all others
are $\infty$, \eg{}, $\zeroEntry{1}{2} = \vtwoh{0}{\infty}$.
Similarly to the single-entry vector, zeroed single-entry vectors
generalise all other schemes
that have $0$ as their $r^{th}$, representing indices at
the ``origin'' in dimension $r$.
\end{definition}

\begin{figure}[t]
\vspace{-0.9em}
\input{region-model.tex}
%\textit{$a^m \in A$ means there are $n$ copies of $a$ in
%  the multi-set $A$}
\caption{Model of regions,
$\interp{-}_n : \textit{region} \rightarrow \mathcal{P}(\domainVal{}^n)$}
\label{fig:region-model}
\vspace{-1em}
\end{figure}

\noindent
The first four equations of Fig.~\ref{fig:region-model}
give the model of the region constants as sets of indexing
schemes. We illustrate with an example.

\begin{example}
For a $2$-dimensional stencil computation, then
\begin{align*}
& \interp{\stenCenS{2}{1}}_2 \\[-0.1em]
& \qquad = \; \{i\singleEntry{1}{2} \,|\, i \in \{\text{-}2,..., 2\}\!\setminus\!0 \}
  \cup  \{ \zeroEntry{1}{2} \,|\, \textit{true} \} \\[-0.2em]
& \qquad = \; \{-2\singleEntry{1}{2}, \, -\singleEntry{1}{2}, \,
  \singleEntry{1}{2}, \, 2\singleEntry{1}{2}\} \cup
  \{\zeroEntry{1}{2}\} \\[-0.2em]
& \qquad = \; \{\vtwoh{-2}{\infty}, \vtwoh{-1}{\infty}, \vtwoh{0}{\infty},
\vtwoh{1}{\infty}, \vtwoh{2}{\infty}\}
\end{align*}
Note the absorbing behaviour of $\infty$ with respect to
multiplication.
\end{example}
\noindent
The final two equations of Fig.~\ref{fig:region-model} give the models
of $\term{+}$ and $\term{*}$. For $\term{+}$ this is the
straightforward union of the models of subterms. The model of
$\term{*}$ takes the tensor $\otimes$ of subterm models. The tensor is
more involved; we give some informal intuition first.

% r+s means that indices must be consistent with either r or s 
% r*s means that indices must be consistent with both r and s at the
% same time



% specifications correspond to a set of schemes

% r+s means an index must be generalised by a scheme in either r or s
%       and every scheme in r must have an index which specialises it
%       and every scheme in s must have an index which specialises it

% r*s means an index must be generalised by a scheme in r and a scheme in s
%       and every pairs of schemes in r and s must have an index which 
%           specialises both 
%      

% r+s means indices must be consistent with either r or s
%           and there are indices why are generalised by r and s
% (there are indices which are consistent with every part of r or s)
% (every part of r and s independently have an index which is generalised by it)

% r*s means indices must be consistent simultaenously with both r and s
%           and there are indices which are generalised 
% 

%  forward(depth=1,dim=2) & pointwise(dim=1) 
% | forward(depth=1,dim=1) & pointwise(dim=2)

% (o, p) \preceq [[ ]] 

\paragraph{$\otimes$ of models}

The intuition behind $\otimes$ is that it takes all possible pairs of
indexing schemes, and treats each pair as lower and upper bounds of an
$n$-dimensional rectangle. From these lower and upper bounds, 
the remaining vertices of the $n$-dimensional rectangle are
generated (like a bounding box) \eg{}:
%%
\begin{align*}
\{\vtwohs{1}{2}, \vtwohs{5}{6}\,\} \otimes \{\vtwohs{3}{4}\} =
\{\vtwohs{1}{2}, \vtwohs{3}{2}, \vtwohs{1}{4}, \vtwohs{3}{4}, 
   \vtwohs{3}{6}, \vtwohs{5}{4}, \vtwohs{5}{6}\,\}
\end{align*}
%%
The tensor takes a Cartesian product of the two models,
giving all pairs of schemes which are combined using the
\emph{pairwise permutation} written $\bowtie$ (defined later).
Pairwise permutation generates all possible interleavings of two
vectors. Some care is then taken over
how this interacts with $\infty$: pairwise permutation
corresponds to non-deterministic choice, in each dimension $i$,
between two values $u_i$ and $v_i$, but if either
is $\infty$ then the resulting pairwise permutation is
filtered out if the dimension $i$ has \emph{any other scheme
in the model where $u_i \neq \infty$}, \eg{}:
\begin{align*}
\{\vtwoh{1}{\infty}\} \otimes \{\vtwoh{3}{4}\} =
\{\vtwoh{1}{4}, \vtwoh{3}{4}\}
\end{align*}
%
where $\vtwoh{1}{\infty}$ and $\vtwoh{3}{\infty}$ have been filtered.

The notion of which dimensions $i$ have \emph{any scheme in the model
where $u_i \neq \infty$} is represented by the \emph{constrained
dimensions} intermediate function:
\begin{definition}%[Constrained dimensions]
For an $n$-dimensional model $M$, its \emph{constrained dimensions}
is the set of dimension identifiers for which at least one scheme $u \in M$ has
a non-$\infty$ value in that dimension. That is:
%
\begin{align*}
\effdims{M}{n} =
\bigcup_{u \in M} \{i \mid i \in \{1,\ldots,n\} \, \wedge \, u_i \neq
  \infty\}
\end{align*}
For example, $\effdims{\{\vtwoh{0}{\infty},\vtwoh{\infty}{\infty}\}}{2}
 = \{1\}$.
\end{definition}
\begin{definition}The tensor $\otimes_n$ of $n$-dimensional
models is defined:
\begin{alignat*}{2}
& M \otimes_n N =
  \Bigg\{x \; \Bigg| \;
    \parbox{5.2cm}{$(u, v) \in M \times N $ \\[0.1em]
                 $\;\; \wedge \;\, j \in (\effdims{M}{n} \cup
                   \effdims{N}{n})$\\[0.1em]
                  $\;\; \wedge \;\, i \in \{1, \ldots, 2^n\} \, \wedge
                  \, x = (u \bowtie v)_i$ \\[0.1em]
                   $\;\; \wedge \;\, x_j \neq \infty$
                  } \Bigg\}
\end{alignat*}
The first guard takes the Cartesian product of
the models and quantifies over all pairings $(u, v)$.
The second guard binds $j$ which ranges over the constrained
dimensions for $M$ unioned with the constrained dimensions for $N$.
That is, every $j$ corresponds to a dimension in which
either $M$ or $N$ has a scheme $u$ where $u_j \neq \infty$,
and thus is constrained.
The \emph{pairwise permutation} $u \bowtie v$ 
builds a $2^n \times n$ matrix 
of all possible $n$-vectors generated by
non-deterministically picking for each $j^{th}$ entry either 
$u_j$ or $v_j$ \eg{}
%
\begin{equation*}
\vthreeh{0}{1}{2} \bowtie \vthreeh{3}{4}{5} =
\left[
\setlength{\arraycolsep}{0.42em}
\begin{array}{cccccccc}
0 & 0 & 0 & 0 & 3 & 3 & 3 & 3 \\
1 & 1 & 4 & 4 & 1 & 1 & 4 & 4 \\
2 & 5 & 2 & 5 & 2 & 5 & 2 & 5
\end{array}
\right]
\end{equation*}
%
The $2^n$ unique choices for $\bowtie$ on $n$-vectors
corresponds to taking all bit-strings of length $n$ and
selecting from $u$ for $1$ and $v$ for $0$. The pairwise permutation
matrix is thus defined in terms of the logical
matrix $b$ where $b_{i,j}$ is the $j$-th bit of the integer
$i - 1$ as:
%
\begin{align*}
(u \bowtie v)_{i,j} & = b_{i,j} u_j + \neg b_{i,j} v_j
\end{align*}
%
The permuted schemes $x = (u \bowtie v)_i$ added to the model 
$M \otimes N$ are only those which have do not have $\infty$ in 
the constrained dimensions given by each model ($x_j \neq
\infty$). This filters out all permutations which have
$\infty$ in a constrained dimension position. 
\end{definition}


\section{Analysis, checking, and inference}
\label{sec:analysis}

%\newcommand{\cons}[3]{\mathbf{C}_{#3}(#1, #2)}
\newcommand{\consName}{\textbf{cons0}}
\newcommand{\cons}[2]{#2 \;\, \consName{} \,\, #1}
\newcommand{\consAName}{\textbf{cons}}
\newcommand{\consA}[2]{#2 \;\, \consAName{} \,\, #1}

\noindent
We outline here the procecures for checking the conformance
of source code against specifications (\S~\ref{subsec:checking}) 
and for infering specifications from code (\S~\ref{subsec:inference}).
Both rely on the analysis of source code, converting array indexing
expressions into sets of index schemes. We outline this analysis
first (\S~\ref{subsec:analysis}). Note that the analysis procedure
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. 

\subsection{Analysis of array-based code}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}

\paragraph{Syntax helper functions}
The function \rhsExp{} maps source statements to a
set of expressions which occur in right-hand positions (\ie{}, not the
target of an assignment). The function \var{} maps expressions to a
set of the variables used in right-hand positions.

\paragraph{Analysis pre-requisites}
The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathsf{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable, where we use the predicate
\arrayTy{} to classify variables of array type.

\paragraph{Core analysis}
For each assignment statement \textit{assg} within a loop whose left-hand side is an array
subscript on neighbourhood indices, a finite map is computed mapping
array variables to \emph{multisets} of indexing schemes.
This is captured by the function $\textit{analyse}$:
%
\begin{align*}
\hspace{-0.5em}
\begin{array}{lr}
\textit{analyse}(a(\overline{e_1}) = e_2)
 := \qquad\qquad\qquad & \textit{where} \; \neigh(\overline{e_1}) \\[0.3em]
\multicolumn{2}{l}{\qquad \bigcup\{a' \mapsto \{
\textsf{schematic}(\bar{e})\} \mid a'(\bar{e}) \leftarrow \mathsf{flowsTo}(e_2),
  \arrayTy(a')\}}
\end{array}
\end{align*}
%
The predicate $\neigh$ classifies neighbourhood indices, based on
the induction variables of the loop (implicit here).
Thus, we focus on assignments to an array subscript where the LHS 
index $\overline{e_1}$ is a neighbourhood index.  For
all array subscripts that flow to the right-hand side of this
statement, a finite map is constructed, mapping each array variable
to a \emph{multiset} of indexing schemes for its subscripts, computed
with \textsf{schematic} (Defn.~\ref{def:schematic},
p.~\pageref{def:schematic}).

Note that \textsf{schematic} is undefined ($\bot$) if
$\bar{e}$ contains relative indices which are not neighbourhood
indices. The \textit{analysis} function feeds into the
\textit{modelise} function which filters out those arrays 
which contain undefined indexing schemes and adds multiplicity
information:
%
\begin{align*}
& \mathit{modelise} (\textit{assg}) 
= a \mapsto 
\begin{cases}
\bot & \bot \in M \\
\textsf{only}(|M|) & \forall u \in M . \#(M, u) = 1 \\
\textsf{mult}(|M|) & \forall u \in M . \#(M, u) = n
\end{cases} \\
& \quad \textit{where} \; M = \mathit{analyse}(\textit{assg}) (a)
\end{align*}
where $\#(M, u)$ denotes the multiplicity of an element $u$ of the
multiset $M$ and $|M|$ denotes the set of elements in the multiset
$M$.

Thus, the analysis maps source code to index schemes, which is then
augmented with multiplicity information by $\mathit{modelise}$,
\ie{} values in $\mathsf{Mult}(\mathcal{P}((\domainVal{})^n))$.

If the LHS $\overline{e_1}$ contains non-$0$ neighbour offsets 
then all RHS schemes are \emph{relativised} by
$\textsf{schematic}(\overline{e_1})$. For example, 
if \texttt{a(i+1) = b(i)} then relativisation of the RHS by the LHS
produces an analysis which is equivalent to the analysis of \texttt{a(i) = b(i-1)}. 
\dnote{Somewhere we need a discussion about syntactic vs semantic
analysis...}


\begin{example}
We demonstrate the analysis and modelise procedures over the
following example program which computes the mean value
of a five-point stencil:
%%
\begin{minted}{fortran}
do i = 1, (n-1)
  do j = 1, (m-1)
    x = a(i-1, j)+a(i+1, j); y = a(i, j-1)+a(i, j+1)
    b(i, j) = (a(i, j) + x + y) / 5.0
  end do
end do
\end{minted}
%
The \textit{analyse} function matches on
line 4, with the following set for $\textsf{flowsTo}(\texttt{a(i, j) + x +
  y})$:
%
\begin{align*}
\{\texttt{a(i-1, j)}, \texttt{a(i+1, j)}, \texttt{a(i, j-1)},
  \texttt{a(i, j+1)}, \texttt{a(i, j)}\}
\end{align*}
Subsequently the result of \textit{analyse} on line 4 yields the map:
\begin{align*}
\texttt{a} \mapsto \{\vtwoh{-1}{0}^1, \vtwoh{1}{0}^1,
          \vtwoh{0}{-1}^1, \vtwoh{0}{1}^1, \vtwoh{0}{0}^1\}
\end{align*}
%
where multiplicities are denoted by superscripts. The \emph{modelise}
function then yields the following since all multiplicities in the model are one:
%%
\begin{align*}
\texttt{a} \mapsto \mathsf{only}(\{\vtwoh{-1}{0}, \vtwoh{1}{0},
          \vtwoh{0}{-1}, \vtwoh{0}{1}, \vtwoh{0}{0}\})
\end{align*}
%%
\end{example}


%Given an assignment $\textit{assg}$ to an array subscript in the source language
%and an array variable $a$, then $\mathit{modelise}(\textit{assg}, a)$ performs
%an analysis to find all array subscripts of $a$ converting them to
%index schemes. For the moment, we leave this analysis abstract
%as the function $\emph{analyse}$ in the following definition of $\emph{modelise}$:
%

\subsection{Specification checking}
\label{subsec:checking}

In checking mode, the access pattern of stencil computations in the
source language is verified against any specification associated with
them in the code. The model of
\S~\ref{sec:semantics} guides this process.  Checking
proceeds by generating a model from a specification and generating
a model from the source code, comparing them for
\emph{consistency}. The notion of consistency is built out of index scheme 
\emph{generalisation} (Sect.~\ref{subsec:schemes-and-gen}). 

\begin{definition}[Checking]
Let $a$ be an array variable and let
$S \in \textit{spec}$ be a specification associated to $a$ 
via \texttt{!= stencil $S$ :: a}. A stencil kernel 
 $v(\overline{e_1}) = e_2$ in the source language
conforms to $S$ if the predicate $\textbf{check}_n(S, v(\overline{e_1}) = e_2, a)$ holds, 
defined:
\begin{align*}
& \textbf{check}_n(S, \textit{assg}, a) =
  \consA_n{\interp{S}_n}{\textit{modelise}(\textit{assg})(a)}
&
\end{align*}
Thus, checking proceeds by using \textit{modelise} 
(\S~\ref{subsec:analyis}) to extract index schemes from source code
augmented with multiplicitly for the whole set of schemes. 
This is compared with the model of the specification $\interp{S}_n$ by
the consistency predicate $\consAName$.
\end{definition}

\begin{definition}
Consistency relates models of source code to models 
of specifications (which are bounded) via two predicates:
\begin{align*}
\consName_n & \subseteq \mathcal{P}(\domainVal{}^n)
\times \textsf{Approx}(\mathcal{P}(\domainVal{}^n)) \\
\consAName_n & \subseteq \textsf{Mult}(\mathcal{P}(\domainVal{}^n))
\times \textsf{Mult}(\textsf{Approx}(\mathcal{P}(\domainVal{}^n)))
\end{align*}
%
where $\consName$ relates models without multiplicity.
Figure~\ref{fig:consistency} defines the two predicates, where for
brevity we make implicit the subscript $n$ defining the
dimensionality.  We denote sets of indexing schemes
$\mathcal{P}((\domainVal{})^n)$ that come from a specification model
by $M$ and from source code model by $N$.

Rules (\emph{up}) and (\emph{low}) are the core rules relating models of
specifications and models of code. The (up) rule 
considers the case where the specification is
an \term{atMost} upper-bound approximation.
An upper bound specification means that for every scheme in the code
model, modelling a source-level index, $\forall u \in C$ there exists
a generalising scheme in the spec model $\exists v \in S$, \ie{}, $u
\preceq v$. That is, every source-level index scheme is generalised by the specification.
The (down) rule provides the case of 
\term{atLeast} lower-bound specifications. Consistency is dual to the above: 
for every scheme in the specification model $\forall v \in S$ there
exists a scheme in the code model $\exists u \in C$ such that $u
\preceq v$. That is, every specification scheme is generalised by some source
index scheme.

The (\emph{up}) and (\emph{down}) rules are combined for an \textsf{exact}
specification (\textit{exact}) such that a specification's model
provides both a consistent lower and consistent upper bound on
for the source code. Thus, for every scheme in the code model there
is a scheme in the spec model that generalises it, and for every
scheme in the spec model there is a scheme in the source model that
specialises it.  The (\textit{both}) rule is similar, decomposing
a specification which has both a lower and upper bound into
consistency of these bounds.

Rules $(1)$ and $(*)$ extend the $\textbf{cons}$
predicate to $\textbf{cons}_m \subseteq
\textsf{Mult}(\mathcal{P}(\domainVal{}^n)) 
\times \textsf{Mult}(\textsf{Approx}(\mathcal{P}(\domainVal{}^n)))$
which inludes multiplicity information. Both rules 
state that consistent models remain consistent if they
have the same multiplicity. Relatedly, rule $(1 < *)$ ensures
that absence of a \texttt{readOnce} modifier in the specification
does not prohibit a set of unique stencil accesses in the
code from being consistent.
\end{definition}

\begin{figure}[t]
\begin{align*}
\begin{array}{c}
%%
\trule{up}\dfrac{\forall u \in M \, \exists v \in N .  \, u \preceq v}
      {\cons{\textsf{upper}(N)}{M}}
\qquad
\trule{low}\dfrac{\forall v \in N \, \exists u \in M . \, u \preceq v}
      {\cons{\textsf{lower}(N)}{M}} \\[1.5em]
%%
\trule{exact}\dfrac{\cons{\textsf{lower}(N)}{M} \qquad \cons{\textsf{upper}(N)}{M}}
  {\cons{\textsf{exact}(N)}{M}} \\[1.5em]
%%
\trule{both}\dfrac{\cons{\textsf{lower}(M_1)}{M} \qquad \cons{\textsf{upper}(M_2)}{M}}
  {\cons{\textsf{both}(M_1, M_2)}{M}}\\[1.5em]
%%
\trule{$1$}
\dfrac{\cons{N}{M}}{\consA{\textsf{once}(N)}{\textsf{once}(M)}}
\;\;
\trule{$*$}
\dfrac{\cons{N}{M}}{\consA{\textsf{mult}(N)}{\textsf{mult}(M)}}
  \\[1.5em]
\trule{$1 < *$}
\dfrac{\cons{N}{M}}{\consA{\textsf{mult}(N)}{\textsf{once}(M)}}
\end{array}
\end{align*}
\caption{Consistency between models of code and specification}
\label{fig:consistency}
\vspace{-0.9em}
\end{figure}

\begin{example}
  We give an extended example of verifying a stencil computation
  against its specification. We consider a more general, but still
  consistent, version of the \textit{five-point} stencil specification
  inferred previously in \S~\ref{subsec:inference}:
%
\begin{minted}[breakindent=8.1em]{fortran}
!= region :: fivepoint = centered(depth=1,dim=1) + centered(depth=1,dim=2)
!= stencil readOnce, fivepoint :: b
a(i,j) = b(i,j-1)+b(i,j)+b(i,j+1)+b(i-1,j)+b(i+1,j)
\end{minted}
%
We refer to the assignment on line three as $l3$ for brevity.

Verification of the code against the spec is then given by 
$check(({\textcolor{darkgreen}{\texttt{readOnce, fivepoint}}}),l3,\texttt{b})$. 
We explain the steps.
\begin{enumerate}  
%
\item Generate the model from the specification as in
  \S~\ref{sec:semantics}. 
%
\begin{align*}
 N_s= \{  \vtwo{-1}{\infty},
          \vtwo{0}{\infty},
          \vtwo{1}{\infty},
          \vtwo{\infty}{-1},
          \vtwo{\infty}{0},
        \vtwo{\infty}{1} \}  \\[0.4em]
\interp{{\textcolor{darkgreen}{\texttt{readOnce, fivepoint}}}}_2 =
  \textsf{once}(\textsf{exact} (N_s))
\end{align*}
%
\item Obtained the code model via $\textit{modelise}$, giving:
%
\begin{align*}
M_c = \{
    \vtwo{0}{-1},
    \vtwo{0}{0},
    \vtwo{0}{1},
    \vtwo{-1}{0},
    \vtwo{1}{0}
  \}
\\[0.4em]
\textit{modelise}(l3, \texttt{b}) = \textsf{once} (M_c)
\end{align*}
%
\item Consistency $cons_2(\textsf{once}(\textsf{exact}(N_s)),
  \textsf{once}(M_c))$ holds when 
  $\textit{cons}_2(\textsf{mult}(\textsf{exact}(N_s)),\textsf{mult}(M_c))$ (Fig.~\ref{fig:consistency}) 
  which holds when: 
  \begin{align*}
     & \textit{cons}_2(\textsf{mult}(\textsf{up}(N_s)),\textsf{mult}(M_c)) \\
   \wedge \; & \textit{cons}_2(\textsf{mult}(\textsf{low}(N_s),\textsf{mult}(M_c))
  \end{align*}
%
\item This condition holds by the following sets of scheme
  generalisations: for the upper bound, $\forall u \in M_c,
  \exists v \in N_s . u \preceq_2 v$: 
  \begin{align}
    \begin{array}{l}
     \vtwoh{0}{-1} \preceq_2 \vtwoh{0}{\infty} \quad
     \vtwoh{0}{0} \preceq_2 \vtwoh{0}{\infty} \quad
     \vtwoh{0}{1} \preceq_2 \vtwoh{0}{\infty} \\[0.5em]
     \vtwoh{-1}{0} \preceq_2 \vtwoh{\infty}{0} \quad
     \vtwoh{1}{0} \preceq_2 \vtwoh{\infty}{0}
     \end{array}
  \label{eq:check-example-upper}
  \end{align}
  % 
  and for the lower bound: $\forall v \in N_s, \exists u \in M_c . u
  \preceq_n v$: 
  \begin{align}
    \hspace{-1em}
    \begin{array}{l}
     \vtwoh{-1}{0} \preceq_2 \vtwoh{-1}{\infty} \quad
     \vtwoh{0}{0} \preceq_2 \vtwoh{0}{\infty} \quad
     \vtwoh{1}{0} \preceq_2 \vtwoh{1}{\infty}  \\
     \vtwoh{0}{-1}  \preceq_2 \vtwoh{\infty}{-1} \quad
     \vtwoh{0}{0}  \preceq_2 \vtwoh{\infty}{0} \quad
     \vtwoh{0}{1}  \preceq_2 \vtwoh{\infty}{1}
     \end{array}
    \label{eq:check-example-lower}
  \end{align}
  Since both the consistency predicate is satisfied, the array
  accesses flowing to line three in the stencil computation are valid
  with respect to the {\textcolor{darkgreen}{\texttt{fivepoint}}} specification.
\end{enumerate}
\vspace{-0.7em}
\end{example}
\begin{example} 
We consider now an erroneous user modification to $l3$ with an
additional term \texttt{b(i+2,j+2)} such that $l3'$ is:
%
\begin{minted}[firstnumber=3]{fortran}
a(i,j) = b(i,j-1) + b(i,j) + b(i,j+1) + b(i-1,j) + b(i+1,j) + b(i+2,j+2)
\end{minted}
%
The checking procedure proceeds in the same way as the first three
steps of the previous example, except that the result of
$\mathit{modelise}(l3',\texttt{b})$ generates an additional scheme
$\vtwoh{2}{2}$. Since the spec model has not changed and the code
model is has only the additional scheme $\vtwoh{2}{2}$, the generalisations for
the lower bound \eqref{eq:check-example-lower} 
of step 4 above still holds since its consistency condition
universally quantifies over the \emph{spec model}. However, for
the upper bound, the consistency condition universally quantifies
over scheme $u$ of the \emph{code model} for which there exists
a scheme $v \in N_s$ such that $u \preceq_2 v$. Thus, we require a $v
\in N_s$ such that $\vtwoh{2}{2} \preceq_2 v$ but no such generalising
scheme existing in the spec model. Hence the model fails to hold as an upper bound.

Note that if the specification were as follows:
%
\begin{minted}{fortran}
!= stencil atLeast, readOnce, fivepoint :: b
\end{minted}
%
then consistency holds as it no longer requires the failing upper-bound case 
$\mathit{cons}(\textsf{mult}(\textsf{up}(N_s)),\textsf{mult}(M_c))$.
 This makes sense semantically since the region ${\textcolor{darkgreen}{\texttt{fivepoint}}}$
is indeed contained in the regions touched by $\texttt{b}$ in $l3'$. 
\end{example}

\dnote{Build this into the definitions earlier I think}
One way the implementation may deviate from the model is elimination of all $\infty$
offset vector that occurs when all indices are in non-neighbourhood form \eg{}
\mintinline{fortran}{b(42,0)}. The only generalisation scheme that can unify
with this pattern is the most general one, meaning it requires outright
rejection of an otherwise fine stencil computation. See the following example,
where not discarding all $\infty$ access pattern prevents verification:
%
\begin{minted}{fortran}
!= stencil forward(dim=1,depth=1) :: a
a(i) = a(i) + a(i+1) + a(1)
\end{minted}



\subsection{Specification inference} 



\bibliography{references}

\end{document}

%%  LocalWords:  refactoring affine parameterised nonpointwise atMost
%%  LocalWords:  centered readOnce atLeast discretisation Equational
%%  LocalWords:  equational disjunction denotational dimensionality
%%  LocalWords:  interprocedural Fortran CamFort preprocessor
%%  LocalWords:  committers
