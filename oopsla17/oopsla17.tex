\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{hyperref}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{syntax}
\usepackage{indentfirst}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{minted}
\usepackage{etoolbox}
\usepackage{enumitem}
\usepackage{thmtools}
\usepackage{thm-restate}

\newcommand{\fortran}[1]{\mintinline{fortran}{#1}}

\errorcontextlines 10000
\usepackage{stencilmacros}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=w),
  xleftmargin=3\parindent,
  numbersep=1em
}

\usemintedstyle{vs}

\setlength{\grammarindent}{3em} % increase separation between LHS/RHS

\newcommand{\inbar}{\ \ \textbar\ \ }

% For evluation and empirical study
% Defines the commands (headers)
\input{resultsCmds}
\input{studyResults}
% renews the commands with actual data
% \input{results}

\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{case}{Case}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\title{Verifying Spatial Properties of Array Computations}

\author{Dominic Orchard}
\affiliation{
  \department{School of Computing}
  \institution{University of Kent}
}
\email{d.a.orchard@kent.ac.uk}


\author{Mistral Contrastin}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Mistral.Contrastin@cl.cam.ac.uk}

\author{Matthew Danish}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Matthew.Danish@cl.cam.ac.uk}


\author{Andrew Rice}
\affiliation{
  \department{Computer Laboratory}
  \institution{University of Cambridge}
}
\email{Andrew.Rice@cl.cam.ac.uk}


\begin{abstract}
  Arrays computations are the workhorse of numerical modelling and
  computational science. However, low-level manipulation of array
  indices is a source of program error.  Many practitioners are aware
  of the need to ensure program correctness, yet very few of the
  techniques from the programming research community are applied by
  scientists. We aim to change that by providing targetted lightweight
  verification techniques for scientific code.  We focus on the all
  too common mistake of array offset errors as a generalisation of
  off-by-one errors.  Firstly, we report on a code analysis study on
  twelve real-world computational science code base, identifying
  common idioms of array usage and their spatial properties. This
  provides much needed data on array programming idioms common in
  scientific code.  From this data, we designed a lightweight
  declarative specification language capturing the majority of array
  access patterns via a small set of combinators. We detail a semantic
  model, and the design and implementation of a verification tool for
  our specification language, which both checks and infers
  specifications.  We evaluate our tool on our corpus of scientific
  code and give verification case studies of bug fixes that are
  detected by our approach. We found roughly 60,000 targets for
  specification across roughly 1.2 million lines of code, showing the
  vast majority of array computations read from arrays in a pattern with
  a simple, regular, static shape.
\end{abstract}
  
%  We focus on one error-prone aspect of numerical code: the 
%  data access pattern of arrays. 

\begin{document}
\maketitle

\section{Introduction}
\label{sec:introduction}
\input{introduction}

\section{An Empirical Study of Array Computations in Scientific Fortran code}
\label{sec:study}
\input{study}

\section{A Specification Language for Shape}

\begin{figure}[t]
\begin{align*}
\def\arraystretch{1}
\setlength{\arraycolsep}{0.2em}
\newcommand{\dimTy}{$\mathbb{N}_{>0}$}
\newcommand{\depthRange}{$\mathbb{N}_{>0}$}
\begin{array}{rl}
\nonterm{specification} ::= & \nonterm{regionDec} \mid \nonterm{specDec} \\
\nonterm{specDec} ::= & \term{stencil} \; \nonterm{spec} \;
                        \texttt{::} \; v \\
\nonterm{regionDec} ::= &  \texttt{region} \; \texttt{::} \; \nonterm{rvar} \; \texttt{=} \;
                         \nonterm{region}\\[0.4em]
%\nonterm{spec} ::= & \nonterm{spatial} \mid \nonterm{temporal}
%\\[1em]
\nonterm{spec} ::= & [\nonterm{mult},] \; [\nonterm{approx},] \; \nonterm{region} \\
\nonterm{mult} ::= & \term{readOnce} \\
\nonterm{approx} ::= & \term{atMost} \; \mid \; \term{atLeast} \\[0.1em]
\nonterm{region} ::= & \nonterm{rvar} \; \mid \;
                       \stencil{p}{\dimTy}{}{} \; \\
& {\qquad\; \mid \; \stencil{f}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{b}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \stencil{c}{\dimTy}{\depthRange}{\;[, \nonpointed]}} \\
& {\qquad\; \mid \; \nonterm{region} \, \term{+}
  \, \nonterm{region} \; \mid \; \nonterm{region} \; \term{*} \; \nonterm{region}} \\[0.25em]
%\multicolumn{2}{l}{\qquad\qquad \mid \; \nonterm{rvar}}
%\\[0.5em]
%\nonterm{temporal} ::= \; & \term{dependency} \; (v \; \{ , v \}) [, \texttt{mutual}]
%  \\[0.5em]
\nonterm{rvar} ::= \; & [\text{\term{a}-\term{z}$\,$\term{A}-\term{Z}$\,$\term{0}-\term{9}}]+\\[-1em]
\end{array}
\end{align*}
\caption{Specification syntax (EBNF grammar)}
\label{fig:syntax}
\end{figure}

\subsection{Specification syntax}
\label{subsec:syntax}

\Cref{fig:syntax} gives the syntax of stencil specifications, which is
detailed below. The entry point is the \nonterm{specification} production which
splits into either a \emph{region declaration} or a \emph{specification
declaration}.
Regions comprise \emph{region constants} which are
combined via region operators \term{+} and \term{*}.

Region constants specify a finite interval in a 
single dimension relative to the origin and are either \term{pointed},
\term{forward}, \term{backward}, or \term{centered}. The region names are
inspired by numerical analysis terminology, \eg{} the standard explicit method for
approximating PDEs is known as the \emph{Forward Time, Centered Space} (FTCS)
scheme~\citep{dawson1991finite}.

Each region
constant has a dimension identifier $d$ given as a positive natural number.
Each constant except \term{pointed} has a depth
parameter $n$ given as a positive natural number; \term{pointed}
regions implicitly have a depth of $0$.

A \term{forward} region of depth $n$ specifies a contiguous
region in dimension $d$ starting at the origin. This corresponds
to specifying neighbourhood indices in dimension $d$ ranging from $i$ to $i + n$
for some induction variable $i$. Similarly, a
\term{backward} region of depth $n$ corresponds to contiguous indices
from $i$ to $i - n$ and \term{centered}
of depth $n$ from $i - n$ to $i + n$. A \term{pointed}
stencil specifies a neighbour index $i$. For example, the
following shows four specifications with four consistent stencil
kernels reading from arrays \term{a}, \term{b}, \term{c} and \term{d}:
%%
\begin{minted}{fortran}
!= stencil forward(depth=2, dim=1) :: a
e(i, 0) = a(i, 0) + a(i+1, 0) + a(i+2, 0)

!= stencil backward(depth=2, dim=1) :: b
e(i, j) = b(i, j) + b(i-1, j) + b(i-2, j)

!= stencil centered(depth=1, dim=1) :: c
e(i, j) = (c(j-1) + c(j) + c(j+1))/3.0

!= stencil pointed(dim=3) :: d
e(i, j) = d(0, 0, i)
\end{minted}
%%
Not every dimension needs to be specified, \eg{},
specifications on lines $1$, $4$, and $10$ leave some dimensions unspecified.
The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointed} which marks absence
of the origin.  For example, the following is a
\term{nonpointed} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointed) :: a
b(i) = a(i-1) + 10*a(i-2)
\end{minted}
%
Not every dimension needs to be specified, \eg{},
specifications on lines $1$, $3$, and $7$ leave some dimensions
unspecified which leaves indices in these dimensions unconstrained.

The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointed} which marks absence
of the origin.  For example, the following is a
\term{nonpointed} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointed) :: a
b(i) = a(i-1) + 10*a(i-2)
\end{minted}

\paragraph{Combining regions}

The region operators \term{+} and \term{*} respectively combine
regions by union and intersection. The intersection of two regions
$r \term{*} s$ means that any indices in the specified code must be
consistent with both $r$ and $s$ simultaneously.
 Dually, for the union of two regions
 $r \term{+} s$ means that indices in the specified code must be
 in consistent with one of $r$ or $s$, or both.
For example, the following \emph{nine-point stencil}
has a specification given by the product of two \texttt{centered}
regions in each dimension:
%%
\begin{minted}[breakindent=2.9em]{fortran}
x = a(i, j)   + a(i-1, j)   + a(i+1, j)
y = a(i, j-1) + a(i-1, j-1) + a(i+1, j-1)
z = a(i, j+1) + a(i-1, j+1) + a(i+1, j+1)
!= stencil centered(depth=1, dim=1) * centered(depth=1, dim=2) :: a
b(i, j) = (x + y + z) / 9.0
\end{minted}
%
%This pattern is common in image convolution applications.
The specification ranges over the
values that flow to the array subscript on the left-hand side,
and so ranges over the intermediate assignments to \term{x},
\term{y}, and \term{z}. Each index in the code is consistent
with both specifications simultaneously, \eg{}, \texttt{a(i-1, j+1)}
is within the centered region in dimension $1$ and the centered region
in dimension $2$.

The union of two regions $r \term{+} s$ means that any indices
in the specified code must be consistent with either of $r$ or $s$.
For example, the following gives the specification of a five-point
stencil which is the sum of two compound \texttt{pointed} and
\texttt{centered} regions in each dimension:
%
\begin{minted}{fortran}
!= stencil centered(depth=1, dim=1)*pointed(dim=2) + centered(depth=1, dim=2)*pointed(dim=1) :: a
b(i,j) = -4*a(i,j) + a(i-1,j) + a(i+1,j) + a(i,j-1) + a(i,j+1)
\end{minted}
%%
Here the left-hand side of \texttt{+} says that when the second dimension
(induction variable $j$) is fixed at the origin, the first dimension
(induction variable $i$) accesses the immediate vicinity of the origin
(to depth of one). The right hand side of \texttt{+} is similar but the dimensions are reversed.
This reflects the symmetry under rotation of the five-point stencil.

\paragraph{Region declarations and variables}

Region specifications can be assigned to region variables via
region declarations. For example, the shape of a
``\emph{Roberts cross}'' edge-detection convolution~\cite{davis1975survey}
can be stated:
%%
\begin{minted}{fortran}
!= region :: r1 = forward(depth=1, dim=1)
!= region :: r2 = forward(depth=1, dim=2)
!= region :: robertsCross = r1*r2
!= stencil robertsCross :: a
\end{minted}
This is useful for common patterns, such as the five-point
pattern, as the regions can be defined once and reused.
%%
\paragraph{Modifiers}
%%
Region specifications can be modified
by \emph{approximation} and \emph{multiplicity} information
(in \textit{spec} in \Cref{fig:syntax}).
The \texttt{readOnce} modifier enforces that no index appears more
than once (that is, its multiplicity is one). For example, all of
the previous examples could have \texttt{readOnce} added:
%
\begin{minted}{fortran}
!= stencil readOnce, backward(depth=2, dim=1) :: a
b(i+1) = a(i) + a(i-1) + a(i-2)
\end{minted}
%
This specification would be invalid if any of the
array subscripts were repeated. This modifier provides a way to
rule out any accidental repetition of array subscripts.
The notion is similar to that of linear types~\cite{wadler1990linear}, where a value must be used
exactly once. We opt for the more informative and easily understood name
\texttt{readOnce}. This modifier is optional, so it need not
be present even if the stencil is linear.

In some cases, it is useful to give a lower and/or upper bound for a
stencil. This can be done using either the \term{atMost} or
\term{atLeast} modifiers. This is particularly useful in situations
where there is a non-contiguous stencil pattern, which cannot be expressed
precisely in our syntax. For example:
%
\begin{minted}{fortran}
!= stencil atLeast, pointed(dim=1)         :: a
!= stencil atMost, forward(depth=4, dim=1) :: a
b(i) = a(i) + a(i+4)
\end{minted}

\section{Semantic model}
\label{sec:model}

\noindent
We define a lattice model of array access patterns which serves as both a
denotational model of the semantics of our specification language and an
abstract interpretation domain for source code. This model (1) serves to
explain the meaning of our specifications; (2) is used in the inference and
checking algorithms (\Cref{sec:analysis}); (3) justifies an equational theory
for specifications in the next section; (4) is used to optimise specifications
using lattice identities; and (5) can be used to guide correct implementations.

The model is defined over vectors of sets of integers which we call
\emph{index schemes}.  As an initial informal example, consider the
following simple stencil computation:
%
\begin{minted}{fortran}
do i = 1, n
  b(i) = a(i,0) + a(i+1,0)
end do
\end{minted}
%
The access pattern on array \term{a}, relative
to induction variable \term{i}, is captured
by a vector of length 2 containing integer sets $\langle{\{0, 1\},
  \mathbb{Z}\}}\rangle$. This describes that, in the first dimension,
the array is read at offsets of $0$ and $1$ from an induction
variable. In the second dimension, the index is unconstrained
as it is a constant.

Index schemes form a lattice which provides a rich set of equations
and properties, which we exploit. We first set up the 
domain of the model (\S\ref{sec:domain}), using it to define a semantics
for our specification language (\S\ref{sec:semantics}) and then as
the target for an abstract interpretation on imperative
code (\S\ref{sec:fromcode}).

\subsection{Lattice model of regions}
\label{sec:domain} 

%\begin{defn}[Extended integers]
%  We define the set \zinf{} as
%  $\mathbb{Z}$ extended with $\infty$ and $-\infty$. For any $a$ in
%  \zinf{}, we have $-\infty \leq a \leq \infty$. The resulting set is
%  a total order with top and bottom elements $-\infty$ and
%  $\infty$ respectively.
%\end{defn}

\begin{defn}[Index scheme]
  An $N$-dimensional \emph{index scheme} is a vector of length $N$ of
  integer sets, \ie{}, a member of $\mathcal{P}(\bz)^{N}$.
%  An equivalent view of these vectors is as an $N$-times finite Cartesian
%  product on subsets of $\bz$.
  We use $S, T, U$ to denote index schemes. Henceforth, we assume index schemes
  are all $N$-dimensional for some $N$.

  Index schemes can be \emph{projected} in the $i^{\textit{th}}$ dimension by
  $\pi_i : {\mathcal{P}(\bz{})}^N \to \mathcal{P}(\bz{})$. For an index scheme
  $I$, we refer to $\pi_i(S)$ as the \emph{$i^{th}$ component} of $S$. We assume
  that $i$, when used for projection, always lies between $1$ and $N$.
\end{defn}


\begin{restatable}{lem}{vectorIntersect}
\label{lem:vector-intersect}
  Intersection distributes over index schemes. That is, for index schemes $S, T
  \in \mathcal{P}(\bz)^N$
%
  \begin{equation*}
    S \cap T = \prod_{i = 1}^{N} \pi_i(S) \cap \pi_i(T)
  \end{equation*}
\end{restatable}

Union does not distribute over index schemes, however, a more restricted
property holds.

\begin{restatable}{lem}{vectorUnion}
\label{lem:vector-union}
$S$ and $T$ are index schemes such that $\pi_i(S) = \pi_i(T)$ for all $1 \leq i
\leq N$ apart from some dimension $k$, then:
%
  \begin{equation*}
    S \cup  T
    =
    \pi_1(S) \times \cdots \times
    (\pi_k(S) \cup \pi_k(T)) \times \cdots \times
    \pi_N(S)
  \end{equation*}
\end{restatable}
%
\begin{defn}[Intervals with an optional hole]
  We define an extended notion of closed interval on $\bz{}$ which may contain a
  \emph{hole} at the origin, written \interv{a}{b}{c} where $a$ and $b$ are
  drawn from \bz{} with $a \leq 0 \leq b$ and $c$ is drawn from $\mathbb{B} = \{
  \mathsf{true}, \mathsf{false} \}$. Intervals are interpreted as sets as
  follows:
%
  \begin{equation*}
    \interv{a}{b}{c} \triangleq
      \{ n \mid a \leq n \leq b \wedge (\neg c \implies n \neq 0) \}
  \end{equation*}

  We also add the distinguished interval $\interv{-\infty}{\infty}{}$, which is simply an
  alias for \bz{}, but this notation prevents handling infinite interval
  separately in the following definitions, theorems, and proofs. Here, $-\infty$
  and $\infty$ behaves like top and bottom elements to \bz{} respectively.

  We denote the set of all such intervals (sets) as $\textit{Interval}$. If the
  superscript to the interval is omitted it is treated as $\mathsf{true}$.
\end{defn}
%
\begin{restatable}{lem}{intervalIdentities}
 \label{lem:interval-identities}
  We have the following dual identities for \bz{} intervals:
%
  \begin{align*}
    \interv{a}{b}{c} \cap \interv{d}{e}{f} & =
      \interv{\max \{a,d\}}{\min \{b,e\}}{c \wedge f} \\
    \interv{a}{b}{c} \cup \interv{d}{e}{f} & =
      \interv{\min \{a,d\}}{\max \{b,e\}}{c \vee f}
  \end{align*}
\end{restatable}
%

We define two specialisations (and subset spaces) of index scheme:
\emph{subscript scheme} and \emph{interval scheme}:

\begin{defn}[Interval scheme]
  An interval scheme is a finite Cartesian product of intervals on \bz{},
  denoted by the set $\textit{Interval}^N$ for a product of $N$ intervals.
\end{defn}

\begin{defn}[Subscript scheme]
  A \emph{subscript scheme} is an index scheme scheme where:
  %
  \begin{equation*}
    \forall i.\ 1 \leq i \leq N \implies
      \pi_i (S) = \{ p \}
      \; \vee \;
      \pi_i (S) = \interv{-\infty}{\infty}{}
    \end{equation*}
%
  That is, the $i^{th}$ component of the set is either a singleton in \bz{} or
  the infinite interval.
\end{defn}
%
\dnote{May want a predicate as well}
   
\begin{defn}[Region]
  A region is an index scheme and \region{N} is the set of all regions (\ie{},
  $\region{N} \subseteq \mathcal{P}(\bz)^N)$. The set of all regions is  defined
  as the smallest set satisfying the following:
%
  \begin{enumerate}
    \item If $R$ is in $\textit{Interval}^N$, then $R$ is in \region{N}.
    \item If $R$ and $S$ are in \region{N}, then so are $R \cap S$ and
      $R \cup S$.
  \end{enumerate}
\end{defn}
%
\begin{restatable}{prop}{regionLattice}
  \label{prop:regionLattice}
  $(\region{N},\cup,\cap,\subseteq)$ is a bounded distributive lattice with top
  $\top = \bz{}^N$ and bottom $\bot = \emptyset$.
\end{restatable}
%
\begin{proof}
  Straightforward, the join and meet are mapped to $\cup$ and $\cap$, the set is
  inductively designed to be closed under these operations. Union and
  intersection are associative, commutative, and absroptive under closed sets
  and then they are also for \region{N}. This is enough to show that, it is a
  lattice.

  Further, we have $\bz{}^N \cap R = R$ and $\emptyset \cup R = R$ with
  $\bz{}^N$ and $\emptyset$ belonging to \region{N}. This makes the lattice a
  bounded one.

  Finally, the lattice is distributive since union distributes over intersection
  and vice versa when the set is closed under these operations.
\end{proof}

\begin{defn}
  $\mathsf{Mult}$ and $\mathsf{Approx}$ are parametric labelled variant types
  with injections given by their definition:
%
  \begin{align*}
    \mathsf{Mult} \;\; a \;\; &
      \triangleq \mathsf{mult} \; a \;\mid\; \mathsf{only} \; a \\
    \mathsf{Approx} \;\; a \;\; &
      \triangleq \mathsf{exact} \; a \;\mid\; \mathsf{lower} \; a \;\mid\;
        \mathsf{upper} \; a
  \end{align*}
%
  \eg{}, $\mathsf{lower}$ is an injection $\mathsf{lower} : a \to \mathsf{Approx}
  \; a$ etc.
  These will be used in the following subsection to give meaning to the
  specification modifiers for approximation and multiplicity.
\end{defn}

\subsection{Denotational semantics for specifications}
\label{sec:semantics}

\noindent
An interpretation function $\interp{-}_N$ maps closed\footnote{That
  is, we assume there are no occurrences of \textit{rvar} in a
  specification being modelled.  Any \emph{open} specification
  containing region variables can be made closed by straightforward
  syntactic substitution with a (closed) \textit{region}.}
specifications to sets of $N$-dimensional index schemes with modifier
information, \ie{} specifications are mapped to
$\textsf{Mult} (\textsf{Approx} (\region{N}))$.

The interpretation is overloaded on \emph{regions} in
\Cref{subfig:region-model}. Various intermediate notions are used.

\begin{defn}
  Let $\textit{promote}_N : \mathbb{N}^+ \times \textit{Interval} \to
  \textit{Interval}^N$ be a function generating an interval scheme such that if
  $v$ is $\vecgen{N}{i}{\interv{a}{b}{c}}$, then $\pi_i(v) = \interv{a}{b}{c}$
  and $\pi_j(v) = \bz{}$ in all other dimensions $j$.
\end{defn}

%
\begin{figure}[!t]
\begin{subfigure}[t]{0.5\textwidth}
\begin{align*}
  \interp{-}_N & : \textit{region} \rightarrow \region{N} \\
%
  \interp{\stencil{p}{$i$}{}{}}_N & =
    \vecgen{N}{i}{\interv{0}{0}{\mathsf{true}}}\\
%
  \interp{\stencil{c}{$i$}{$k$}{\textcap{p}}}_N & =
    \vecgen{N}{i}{\interv{-k}{k}{\interp{\textcap{p}}}} \\
%
  \interp{\stencil{f}{$i$}{$k$}{\textcap{p}}}_N & =
    \vecgen{N}{i}{\interv{0}{k}{\interp{\textcap{p}}}} \\
%
  \interp{\stencil{b}{$i$}{$k$}{\textcap{p}}}_N & =
  \vecgen{N}{i}{\interv{-k}{0}{\interp{\textcap{p}}}}
\\
  \interp{\texttt{\textcap{r} + \textcap{s}}}_N & =
    \interp{\textcap{r}}_N \vee \interp{\textcap{s}}_N
\\
  \interp{\texttt{\textcap{r} * \textcap{s}}}_N & =
    \interp{\textcap{r}}_N \wedge \interp{\textcap{s}}_N \\[-1em]
\end{align*}
\caption{Interpretation of regions}
\label{subfig:region-model}
\end{subfigure}
\hspace{1em}
\begin{subfigure}[t]{0.4\textwidth}
\begin{align*}
\interpApprox{-} & : \textit{approx} \rightarrow (A \rightarrow
  \textsf{Approx} \, A) \\
\interpApprox{\texttt{atLeast}} & = \mathsf{lower} \\
  \interpApprox{\texttt{atMost}} & = \mathsf{upper} \\
  \interpApprox{\epsilon} & = \mathsf{exact} \\ \\
  \interpMult{-} & : \textit{mult} \rightarrow (A \rightarrow
  \textsf{Mult} \, A) \\
  \interpMult{\texttt{readOnce}} & = \mathsf{once} \\
  \interpMult{\epsilon} & = \mathsf{mult}
\end{align*}
\caption{Interpretation of modifiers}
\label{subfig:modifier-model}
\end{subfigure}
\label{fig:semantics}
\caption{Semantic model of specifications}
\end{figure}


The first four equations of \Cref{subfig:region-model} model region 
contants. The final two equations model the \term{+} and \term{*}
operators in terms of the join (union) and meet (intersection)
of interval schemes. Thus regions are modelled as members
of $\region{N}$.

We mark in our model the presence of modifiers such as
\texttt{readOnce} and \texttt{atMost} as introduced in \Cref{}.
Approximation modifiers are interpreted as injections into the
$\mathsf{Approx}$ variant by $\interpApprox{}$ in
\Cref{subfig:modifier-model}.  The $\textsf{Approx}$ type corresponds
to the presence or absence of the spatial approximation modifier, with
\textsf{exact} when there is no such modifier and \textsf{lower} and
\textsf{upper} for \term{atLeast} and \term{atMost}. In a similar way,
multiplicity modifiers are interpreted as injections in the
$\mathsf{Mult}$ variant by $\interpMult{}$, corresponding to the to
the presence or absence of the \term{readOnce} modifier as shown in
\Cref{subfig:modifier-model}.

\begin{defn}[Semantics of specifications]
The intermediate interpretations of \Cref{fig:semantics}
are composed to give a model for the top-level specification
syntax as:
%
\begin{equation*}
  \interp{\texttt{stencil \textcap{mult}, \textcap{approx}, \textcap{region}}}_N =
    \interpMult{\textcap{mult}} \;
           {(\interpApprox{\textcap{approx}} \;
                    {\interp{\textcap{region}}_N)}}
\end{equation*}
\end{defn}
%
\begin{thm}
The semantic model $\interp{-}_N$ of $N$-dimensional specifications
is sound with respects to the equational theory of the language,
that is:
%
\begin{equation*}
\forall S, T, N . \quad
S \equiv T \; \Rightarrow \;
\interp{S}_N = \interp{T}_N
\end{equation*}
%
We define the equational theory in \Cref{sec:equational-theory}.
\end{thm}

\subsection{Denotational semantics for array subscripts}
\label{sec:fromcode}

\begin{defn}
  Recall array subscript terms of the form $a(\bar{e})$ from
  \Cref{def:array-subs}. We interpret these terms with the partial
  interpretation $\interp{-}^{\mathit{aterm}} : \textit{array-term}
  \prightarrow{} \mathcal{P}(\bz{})^N$. The interpretation is defined when
  all indices are either constant or neighbourhood indices as defined in
  \Cref{def:neighbour-ix}.
%
  \begin{align*}
    \interp{a(\bar{e})}^{\mathit{aterm}} =
      \prod_{1 \leq i \leq N} \mathit{subscript}(\bar{e}_i) & &
  %
    \textit{subscript}(e) = \begin{cases}
      \{ c \} & e \equiv i \pm c \\
      \bz & e \; \mbox{is constant}
    \end{cases}
  \end{align*}
\end{defn}

\section{Analysis, Checking, and Inference}
\label{sec:algorithms}
\input{algorithms}

\section{Evaluation}
\label{sec:evaluation}


\bibliography{references}

\appendix
% http://2017.splashcon.org/track/splash-2017-OOPSLA#Instructions-for-Authors
% "There is no page limit for bibliographic references and appendices,
% and, therefore, for the overall submission."
\input{appendix}

\end{document}
