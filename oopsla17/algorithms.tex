%
We outline here the procedures for checking conformance
of source code against specifications (\Cref{subsec:checking})
and for inferring specifications from code (\Cref{subsec:inference}).
Both rely on a program analysis that converts array subscripts
 into sets of index schemes. We outline this analysis
first (\cref{subsec:analysis}). Note that the analysis
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. At the moment, the analysis
is largely \emph{syntactic}, with only a small amount of
semantic interpretation of the code.

\subsection{Union Normal Form}\label{subsec:union-normal-form}

We need to address the problem of representation in the model for index schemes.
In each case, the objects are sets and union and intersection are the
combinators. However, they are often infinite sets due to \bz{} in Cartesian
product. This happens when constant indices of array terms are converted to
\bz{} in subscript schemes and when infinite interval is generated in interval
schemes. This calls for a finite (and ideally compact) representation for
indices.

First recall \Cref{lem:vector-intersect}, which states that intersection of
indexing schemes is still an indexing scheme. When combined with
\Cref{lem:interval-identities}, we can extend this closure to interval schemes.
Subscripts schemes do not enjoy the same propery as intersection of two
singleton sets might easily be empty, which disqualifies it from being a
subscript index. In the following sections we will not rely on intersection of
subscript indices, so that is not a problem.

Union, however, is not as flexible as intersection. \Cref{lem:vector-union} does
not form a closure for indexing schemes in general. For this reason, we
represent collection of all forms of indexing schemes as unevaluated unions.
Since the model forms a distributive lattice as established in
\Cref{prop:region-lattice}, the intersections can be pushed in using the
distributive law leaving only unions. We further exploit associativity of union
to put unions into a cons tree making the unions effectively a non-empty list.
We do not, however, attempt to canonicalise the representation. Later on
\Cref{lem:vector-union} and index scheme subset are used to reduce the size of
union normal form.

\subsection{Analysis of array accesses}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}

The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathit{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable.% where we use the predicate
%\arrayTy{} to classify variables of array type.


\subsection{Checking code against specifications}
\label{subsec:checking}
%
In the model, we can regard both array indices and specifications as sets of
points in $N$-dimensional space. The notion of consistency is then intuitively
whether these two (potentially infinite) sets of points match or not.
This leads to a simple set based consistency function defined as
%
\begin{align*}
  \mathit{consistent} & :
    \mathsf{Mult}(\mathcal{P}(\bz{}^N)) \times
    \mathsf{Mult}(\mathsf{Approx}(\region{N})) \to \mathbb{B} & \\
%
  \mathit{consistent}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    \mathsf{false} & \mathit{model} = \mathsf{once}(x) \wedge ix =
    \mathsf{mult}(y) \\
    \mathsf{false} & \mathit{model} = \mathsf{mult}(x) \wedge ix = \mathsf{once}(y) \\
    \mathit{consistent'}(\mathit{peel}(ix), \mathit{peel}(model)) & \textit{otherwise}
  \end{cases} \\
%
  \mathit{consistent'} & :
    \mathcal{P}(\bz{}^N) \times
    \mathsf{Approx}(\region{N}) \to \mathbb{B} & \\
%
  \mathit{consistent'}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    m = \mathit{ix} & \mathit{model} = \mathsf{exact}(m) \\
    m \supseteq \mathit{ix} & \mathit{model} = \mathsf{upper}(m) \\
    m \subseteq \mathit{ix} & \mathit{model} = \mathsf{lower}(m)
  \end{cases}
\end{align*}
%
The first function, $\mathit{consistent}$, checks whether the linearity of the
specification matches that of the indices, \ie{} if the specification allows
indices to be repeated or not. Then it delegates to $\mathit{consistent'}$
function to check if the points observed in the array terms match the space
defined by the specification. Lower bounds, marked by the \texttt{atLeast}
modifier, require the space defined by the specification to remain inside the
set of indices, while an upper bound, market by \texttt{atMost},
requires the opposite: enclosure. In the absence of such modifiers, we expect
the space defined by observed indices corresponds exactly with those defined by the
region in the specification, hence requiring set equality.

As explained in \Cref{subsec:union-normal-form}, the sets being compared are
potentially infinite and set comparisons cannot be done by exhaustively
comparing the points of one with the other. Instead, we compile the region into
interval constraints and subscript schemes into membership constraints and pass
these to the \textsc{Z3} SMT solver~\citep{de2008z3} to see if they are equal. The
query is expressed in quantifier free linear arithmetic, which is decidable.

Although satisfiability is super-exponential with the length of the formula in
the worst case~\cite{fischer1974super}, performance of consistency checking
using satisfiability is fast in practice as the length of the formula is linearly
related with two factors: (1) dimensionality times number of regions connected
with \texttt{+} and (2) dimensionality times the number of array terms flowing
into an assignment assignment. In \Cref{sec:study}, we establish dimensonality
99\% of all array variables that we can assign a specification is X, and 99\% of
number of array terms that flows into such an assignment is Y. In
\Cref{sec:evaluation}, we show the number of regions that are connected with
\texttt{+} is Z in 99\% of the cases.

\mnote{DOMINIC fills in X, Y, and Z}

\subsection{Infering specification automatically}
\label{subsec:inference}
%
\noindent
We provide an inference procedure for generating specifications from
code, which are inserted automatically as comments. This helps support
maintenance of legacy code, and aids understanding of our
specification language. We illustrate inference using the
five-point stencil of \Cref{exm:checking}.

The preceding source code analysis converts the concrete syntax of
array subscripts into a set of subscript schemes in
$\mathcal{P}(\bz)^N$. These subscripts are then coalesced iteratively
into sets of index schemes. We denote sets of index schemes by
$\mathcal{S}$, and initial set of subscript schemes from the analysis
as $\mathcal{S}_0$. For our example:
%
\begin{equation*}
\mathcal{S}_0 = \{\{0\} \times \{0\}, \{-1\} \times \{0\},
\{0\} \times \{-1\}, \{0\} \times \{1\}, \{1\} \times \{0\}\}
\end{equation*}
%
%For each array variable $a \in \mathsf{dom}(U)$, the algorithm
%constructs a set of $n$-dimensional rectangles covering all contiguous
%groups of schemes in $U(a)$.
%
We explain the algorithm in two parts. First, we show how
\emph{contiguous} index schemes are coalesced into a smaller set of
index schemes while remaining in union normal form. Then, we explain
how this smaller unioned indexing schemes are converted to
specifications.

\subsubsection{Covering}
A covering of (possibly overlapping) intervals is calculated as a
value of \region{N} by coalescing \emph{contiguous} index schemes
until a fixed-point is reached.

\newcommand{\contig}[2]{\mathit{contig}(#1, #2)}
\begin{defn}[Contiguity]
  \label{def:contiguity}
  Two index schemes $S$ and $T$ are \emph{contiguous} written
  $\contig{S}{T}$, iff $\pi_i(S) = \pi_i(T)$ for all $1 \leq i \leq N$
  apart from some dimension $k$ such that $\pi_k(S) = [a, b]$ and
  $\pi_k(T) = [b+1, c]$.
\end{defn}
%
A coalesced set of index schemes is computed by:%
%
\begin{align*}
  \mathit{coalesce}(\mathcal{S}) = \; & \;\;
  \{\,S \cup T \mid S \in \mathcal{S}, T \in \mathcal{S} \, \wedge \,
                                        \contig{S}{T} \}
  \;\;\; \cup \;\;\;
  \{\,S \in \mathcal{S} \mid \neg \exists T \in \mathcal{S} . \; \contig{S}{T}\}
\end{align*}
%
Thus, $\mathit{coalesce}(\mathcal{S})$
comprises the union of the set of coalesced pairs of contiguous
schemes and the set of index schemes for which there is no other
contiguous scheme.
%
\begin{lemma}[Closure]
  For a set of index schemes $\mathcal{S}$, then
  $\mathit{coalesce}(\mathcal{S})$ is well-defined and is a set of
  index schemes.
\end{lemma}
\begin{proof}
  By \Cref{lem:vector-union}, the union of two index schemes is an
  index scheme if all components are equal except at most one
  component. Contiguity (\Cref{def:contiguity}) matches
  this precondition, thus the first part of the union in
  $\mathit{coalesce}$ produces a set of index schemes. The second part
  comprises a subset of the original index schemes.
\end{proof}
%
For our example, the fixed-pointed of $\mathit{coalesce}$ is reached within two
steps:
%
\begin{align*}
  \mathit{coalesce}(\mathcal{S}_0) & =
  \{[-1,0] \times [0,0],\,[0,0] \times [-1, 0],\,[0,0] \times
    [0,1],\,[0,1] \times [0,0]\} \\
  \mathit{coalesce}^2(\mathcal{S}_0) & =
  \{[-1, 1] \times [0, 0],\,[0, 0] \times [-1, 1]\} = \mathit{coalesce}^3(\mathcal{S}_0)
\end{align*}
%
\todo{Prove that this is in $Region_N$}

\subsubsection{Index schemes to syntax}

Now we convert coalesced indexing schemes into specifications. This happens in
three stages. First, we see if there is an all infinite indexing scheme. Second,
we determine if the indexing schemes are interval schemes so that they can be
represented exactly and if not how it can be altered into interval schemes to be
represented as approximations. Third, we split up the interval schemes so that
the region constants can express them. Finally, we convert the interval schemes
into a joins of meets of region constants.

If there is all infinite indexing scheme, then we cannot represent it
syntactically. This happens when use of constant indices in one or more array
terms causes the offsets to be subsumed. The simplest case is when there is an
array term with all of its indices constant.

In our example, there are no constant indices, so we proceed.

After handling the trivial case, correct approximation is chosen. Recall
\Cref{def:interval-scheme}, an indexing scheme is an interval scheme if each of
the sets in products are holed intervals. If that is the case, we trivially
convert the sets in each dimension of indexing schemes to holed interval
representation and proceed to the next stage and output an exact specification
at the end. If not, then the output will definitely have an upper bound and
potentially a lower bound.

Upper bound is established by \emph{elongating} index schemes in multiple
dimensions such that they become interval schemes. The elongation function is
given as
%
\begin{align*}
  \mathit{elongate}([a,b]) = \begin{cases}
    \interv{0}{b}{\textsf{false}} & a > 1 \\
    \interv{a}{0}{\textsf{false}} & b < -1
  \end{cases}
\end{align*}

Since index schemes of the previous stage are all contiguous and form closed
intervals, 0 lying between the lower and upper bounds of intervals is sufficient
to form an interval scheme. If any dimension of an index scheme is elongated,
then the whole index scheme is elongated. In the initial set of index schemes,
all schemes that were already interval schemes form a lower bound, while those
schemes and the new interval schemes generated by elongation form the upper
bound. The reason a lower bound may not be generated is all indexing schemes
with might need elongation.

The index schemes in the example are all interval schemes, so we proceed to the
next stage noting the output will be exact.

There is no direct translation from an interval scheme such as $\interv{-2}{1}{}
\times \interv{-1}{1}{}$ to region constants. The reason is region constants
\texttt{forward} and \texttt{backward} require upper and lower bounds to be 0
respectively and \texttt{centered} requires the upper bound to be the negation
of the lower bound. The solution is to use \Cref{lem:vector-union} to break up
interval schemes into two producing $\interv{-2}{0}{} \times \interv{-1}{1}{}$
and $\interv{0}{1}{} \times \interv{-1}{1}{}$.

The extended example does not have such representation problem, so the interval
schemes are left as they are.

The final stage of inference is simply mapping interval schemes into region
constants. Each interval scheme is connected with \texttt{+}. Individual schemes
are decomposed using \Cref{lem:vector-intersect} such that each of the resulting
index schemes have all but one dimensions set to \interv{-\infty}{\infty}{}.
Each of these interval schemes are mapped to region constants using
\Cref{subfig:region-model} and connected with \texttt{*}.

In the example, $[-1, 1] \times [0, 0]$ is decomposed into $\interv{-1}{1}{}
\times \interv{-\infty}{\infty}{}$ and $\interv{-\infty}{\infty}{} \times
\interv{0}{0}{}$. These are then mapped to \texttt{\stencil{c}{1}{1}{}
* \stencil{p}{2}{}{}}. Decomposition of $[0, 0] \times [-1, 1]$ is similar. When
combined we obtain the following specification:
%
\begin{equation*}
  \texttt{stencil readOnce,} \;
  \stencil[s]{c}{1}{1}{} \texttt{*} \stencil[s]{p}{2}{}{} \; \texttt{+} \;
  \stencil[s]{p}{1}{}{}  \texttt{*} \stencil[s]{c}{2}{1}{}
\end{equation*}
