\noindent
Various deductive verification tools can express array indexing in their
specifications, \eg{}, ACSL of \citet{baudin2008acsl} for C
(\eg{}~\citet[Example 3.4.1]{burghardt2010acsl}). A specification can be given
for a stencil computation but must use fine-grained indexing as in code and
therefore is similarly prone to indexing errors. Our approach is much more
abstract---it does not aim to reify indexing in the specification, but
provides simple spatial descriptions which capture a large number of common
patterns.

\citet{kamil2016verified} propose \emph{verified lifting} to extract a
functionally-complete mathematical representation of low-level, and potentially
optimised, stencils in Fortran code. This extracted predicate representation of
a stencil is used to generate code for the \textsc{Halide} high-performance
compiler~\citep{ragan2013halide}. Thus they must capture the full meaning of a
stencil computation which requires significant program analysis. For example,
they report that some degenerate stencil kernels take up to 17 hours to analyse
and others require programmer intervention for correct invariants to be
inferred. By contrast, it takes roughly 1.5 hours on commodity
hardware (3.2Ghz Intel Core i5, 16 Gb of RAM) to infer and generate
stencil specifications for our entire corpus.

% ACR-I think we could skip this in the interests of space
%This led them to develop \textsf{STNG}, a loop invariant and postcondition
%finder through syntax-guided synthesis. Using this approach they restrict the
%search space of postconditions to predicates of a certain form, one that is
%compatible with \textsf{Halide}. They then look at concrete loop iterations and
%form an hypothesis about the invariant, which is later confirmed or put back
%into the system using a SMT solver.

Our approach differs significantly. Rather than full representation of
array computations, we focus on specifying just the spatial behaviour
in a lightweight way.  Thus, it suffices for us to perform a
comparatively simple data-flow analysis which is efficient, scales
linearly with code size, and does not require any user intervention.
Whilst we do not perform deep semantic analysis of stencils, the
analysis part of our approach can be made arbitrarily more
sophisticated independent of the rest of the work.
% Hence, we do not require SMT solving or search of loop invariants. It
%suffices to do comparatively simple data-flow analysis.
%Since CamFort mostly does
%syntactic analysis, the inference procedure terminates quickly and
%never requires programmer intervention.
%The downside of our
%approach is that if optimisation causes the stencil computation to be heavily
%obfuscated, \textsf{STNG} would capture the access behaviour better.
%
Furthermore, Kamil \emph{et al.} do not provide a user-visible syntactic
representation of their specifications, and nor do they provide verification
from specifications \eg{}, to future-proof the code against later changes. Even
if they were to provide a syntactic representation, for complex stencils such as
Navier-Stokes from \Cref{sec:introduction}, it would be as verbose as the code
itself, making it difficult for programmer to understand the overall shape of
the indexing behaviour.

% GPGPU
Our work has similarities with efforts to verify kernels written for
General-Purpose GPU programming, such as in \citet{Blom:2014:SoCP}.
%Stencils are a form of
%kernel, and GPGPU programming can be viewed as a massively parallel
%method of transforming a large matrix.
However, their focus is mainly on the synchronisation of kernels and the
avoidance of data races., while we are interested in correctness
%embedded within a more typical general-purpose programming
%language. %Other work on GPGPU computation, such as
%\citet{Zhang:2012:CGO}, has focused primarily on generating
%optimised code based on relatively simple specifications: to
%provide performance while keeping the programmer's effort within
%reason.
%
% Sketching Stencils
\citet{Solar-Lezama:2007:PLDI} give specifications of stencils using unoptimised
``reference'' stencils, coupled with partial implementations which are completed
by a code generation tool. %These kinds of specifications are just simple
%implementations, so this tool is useful for hand-written, optimised
%stencils.
The primary purpose of this tool is optimisation rather than correctness, and
the language of specification is more elaborate than ours.

% Pochoir
\citet{Tang:2011:SPAA} define a specification language for writing stencils
embedded in C++ (with Cilk~\citep{blumofe1996cilk} extensions) that are then
compiled into parallel programs based on trapezoidal decompositions with
hyperspace cuts. Pochoir specifications are used for describing the kernel,
boundary conditions, and shape of the stencil. Pochoir is aimed at programmers
reluctant to implement the high-performance cache-oblivious ``hypertrapezoidal''
algorithms.  Like much of the related work, the goal is optimisation rather than
correctness.

By contrast, the work of \citet{Abe:2013:IPDPSW} studies correctness bringing a
form of model-checking to verify certain stencil computations in the context of
parallelism in partitioned global address
space languages. %These are scenarios where an array is divided into
%subarrays on multiple processors but each has the ability to access
%the others' memory. The authors avoid the state explosion dilemma of
%model-checking by relying upon the fact that accesses to the
%``boundary elements'' will require a different method by virtue of the
%non-locality of that memory. Since this access is performed in a
%different manner, those can be identified automatically by static
%analysis. To achieve this,
Abe \emph{et al.} provide a new language for writing stencil computations. Much
of the specification effort goes towards describing the distribution of the
computation over multiple processors. The code for the stencil kernel is
generated from a relatively high-level specification.  In contrast, we integrate
directly into existing, legacy codebases and established languages, bringing
the benefits of verification more easily to scientific computing.%such as
%older versions of Fortran.% We infer stencil specifications from
%Fortran code and check annotations on stencil computations within
%Fortran code.
