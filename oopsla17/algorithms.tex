\noindent
We outline here the procedures for checking conformance
of source code against specifications (\Cref{subsec:checking})
and for inferring specifications from code (\Cref{subsec:inference}).
Both rely on a program analysis that converts array subscripts
 into sets of index schemes. We outline this analysis
first (\Cref{subsec:analysis}). Note that the analysis
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. At the moment, the analysis
is largely \emph{syntactic}, with only a small amount of
semantic interpretation of the code.

\begin{example}
\label{exm:checking}
We demonstrate analysis, checking, and inference on the 
five-point stencil example:
%%
\begin{minted}{fortran}
b(i, j) = (a(i, j) + a(i-1, j) +a (i+1, j) + a(i, j-1) + a(i, j + 1)) / 5.0
\end{minted}
\end{example}

\subsection{Analysis of array accesses}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}
\noindent
The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathit{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable.% where we use the predicate
%\arrayTy{} to classify variables of array type.

The analysis traverses the control-flow graph of a program top-down
and traverses statements inside of loops bottom-up. The right-hand
side of any assignment statement in a loop is classified based on
whether it has array subscripts flowing to it which are neighbourhood
offsets (or potential absolute in some dimensions). These are then
converted into our model domain by the interpretation
$\interp{-}^{\mathit{aterm}}$ (\Cref{defn:subscript}) and grouped
into a finite map from array variables to set of subscript schemes.
We denote sets of index/subscripts schemes by
$\mathcal{S}$.

For our example, the set of subscript schemes from the analysis is:
%
\begin{equation*}
\mathcal{S}_0 = \{\{0\} \times \{0\}, \{-1\} \times \{0\},
\{0\} \times \{-1\}, \{0\} \times \{1\}, \{1\} \times \{0\}\}
\end{equation*}
%
This set of index schemes is then augmented with multiplicity
information (\textsf{only} or \textsf{mult}) depending on whether
subscripts are unique or not in the analysed statement.
Thus, for each assignment, the analysis generates a map from array
variables to values in $\mathsf{Mult}(\mathcal{P}(\bz)^N)$.

Any assignment statement from which array subscripts flow to the
current assignment is marked as visited such that the main analysis
does not classify it as the root of an array computation.  Thus,
combined with the bottom-up traversal inside of loops, we assign
specifications only to the leaves of dataflow paths in a loop.

\subsection{Checking code against specifications}
\label{subsec:checking}

\noindent
Checking verifies the access pattern of an array computation in the
source language against any associated specifications. Checking
proceeds by generating a model from a specification and generating a
model from the source code (above), and comparing them for
consistency.  Since the model of \Cref{sec:model} interprets both
array indices and specifications as sets of points in $N$-dimensional
space. The notion of consistency is then intuitively whether these two
(potentially infinite) sets of points are equal. This leads to a
simple notion of consistency, where $\mathit{consistent}(M_C, M_S)$
tests the consistency of a modal $M_C$ of source code against
a model $M_S$ of a specification:
%
\begin{align*}
  \mathit{consistent} & :
    \mathsf{Mult}(\mathcal{P}(\bz{}^N)) \times
    \mathsf{Mult}(\mathsf{Approx}(\region{N})) \to \mathbb{B} & \\
%
  \mathit{consistent}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    \mathsf{false} & \mathit{model} = \mathsf{once}(x) \wedge ix =
    \mathsf{mult}(y) \\
    \mathsf{false} & \mathit{model} = \mathsf{mult}(x) \wedge ix = \mathsf{once}(y) \\
    \mathit{consistent'}(\mathit{peel}(ix), \mathit{peel}(model)) & \textit{otherwise}
  \end{cases} \\
%
  \mathit{consistent'} & :
    \mathcal{P}(\bz{}^N) \times
    \mathsf{Approx}(\region{N}) \to \mathbb{B} & \\
%
  \mathit{consistent'}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    m = \mathit{ix} & \mathit{model} = \mathsf{exact}(m) \\
    m \supseteq \mathit{ix} & \mathit{model} = \mathsf{upper}(m) \\
    m \subseteq \mathit{ix} & \mathit{model} = \mathsf{lower}(m)
  \end{cases}
\end{align*}
%
The first function, $\mathit{consistent}$, checks whether the linearity of the
specification matches that of the indices, \ie{} if the specification allows
indices to be repeated or not. Then it delegates to $\mathit{consistent'}$
function to check if the points observed in the array terms match the space
defined by the specification. Lower bounds, marked by the \texttt{atLeast}
modifier, require the space defined by the specification to remain inside the
set of indices, while an upper bound, market by \texttt{atMost},
requires the opposite: enclosure. In the absence of such modifiers, we expect
the space defined by observed indices corresponds exactly with those defined by the
region in the specification, hence requiring set equality.

As explained in \Cref{subsec:union-normal-form}, the sets being compared are
potentially infinite thus set comparison cannot be done by exhaustively
comparing the points of one with the other. Instead, we compile the region into
interval constraints and subscript schemes into membership constraints and pass
these to the \textsc{Z3} SMT solver~\citep{de2008z3} to see if they are equal. The
query is expressed in quantifier free linear arithmetic, which is decidable.

Although satisfiability is super-exponential with the length of the formula in
the worst case~\cite{fischer1974super}, performance of consistency checking
using satisfiability is fast in practice as the length of the formula is linearly
related with two factors: (1) dimensionality times number of regions connected
with \texttt{+} and (2) dimensionality times the number of array terms flowing
into an assignment assignment. In \Cref{subsec:additional-data}, we
established that  99.6\% of array computations have 
dimensionality of at most four, and 97\% of array computations
involve at most 4 array subscript terms. In
\Cref{sec:evaluation}, we show the number of regions that are connected with
\texttt{+} is Z in 99\% of the cases.


\subsection{Inferring specification automatically}
\label{subsec:inference}
%
\noindent
We provide an inference procedure for generating specifications from
code, which are inserted automatically as comments. This helps support
maintenance of legacy code, and aids understanding of our
specification language. We illustrate inference using the
five-point stencil of \Cref{exm:checking}.

The preceding source code analysis converts the concrete syntax of
array subscripts into a set of subscript schemes in
$\mathcal{P}(\bz)^N$. These subscripts are then coalesced iteratively
into sets of index schemes.

%
%For each array variable $a \in \mathsf{dom}(U)$, the algorithm
%constructs a set of $n$-dimensional rectangles covering all contiguous
%groups of schemes in $U(a)$.
%
We explain the algorithm in two parts. First, we show how
\emph{contiguous} index schemes are coalesced into a smaller set of
index schemes while remaining in union normal form. Then, we explain
how this smaller unioned indexing schemes are converted to
specifications.

\subsubsection{Covering}
A covering of (possibly overlapping) intervals is calculated as a
value of \region{N} by coalescing \emph{contiguous} index schemes
until a fixed-point is reached.

\newcommand{\contig}[2]{\mathit{contig}(#1, #2)}
\begin{defn}[Contiguity]
  \label{def:contiguity}
  Two index schemes $S$ and $T$ are \emph{contiguous} written
  $\contig{S}{T}$, iff $\pi_i(S) = \pi_i(T)$ for all $1 \leq i \leq N$
  apart from some dimension $k$ such that $\pi_k(S) = [a, b]$ and
  $\pi_k(T) = [b+1, c]$.
\end{defn}
%
A coalesced set of index schemes is computed by:%
%
\begin{align*}
  \mathit{coalesce}(\mathcal{S}) = \; & \;\;
  \{\,S \cup T \mid S \in \mathcal{S}, T \in \mathcal{S} \, \wedge \,
                                        \contig{S}{T} \}
  \;\;\; \cup \;\;\;
  \{\,S \in \mathcal{S} \mid \neg \exists T \in \mathcal{S} . \; \contig{S}{T}\}
\end{align*}
%
Thus, $\mathit{coalesce}(\mathcal{S})$
comprises the union of the set of coalesced pairs of contiguous
schemes and the set of index schemes for which there is no other
contiguous scheme.
%
\begin{lemma}[Closure]
  For a set of index schemes $\mathcal{S}$, then
  $\mathit{coalesce}(\mathcal{S})$ is well-defined and is a set of
  index schemes.
\end{lemma}
\begin{proof}
  By \Cref{lem:vector-union}, the union of two index schemes is an
  index scheme if all components are equal except at most one
  component. Contiguity (\Cref{def:contiguity}) matches
  this precondition, thus the first part of the union in
  $\mathit{coalesce}$ produces a set of index schemes. The second part
  comprises a subset of the original index schemes.
\end{proof}
%
For our example, the fixed-pointed of $\mathit{coalesce}$ is reached within two
steps:
%
\begin{align*}
  \mathit{coalesce}(\mathcal{S}_0) & =
  \{[-1,0] \times [0,0],\,[0,0] \times [-1, 0],\,[0,0] \times
    [0,1],\,[0,1] \times [0,0]\} \\
  \mathit{coalesce}^2(\mathcal{S}_0) & =
  \{[-1, 1] \times [0, 0],\,[0, 0] \times [-1, 1]\} = \mathit{coalesce}^3(\mathcal{S}_0)
\end{align*}
%
\todo{Prove that this is in $Region_N$}

\subsubsection{Index schemes to syntax}

Now we convert coalesced indexing schemes into specifications. This happens in
three stages. First, we see if there is an all infinite indexing scheme. Second,
we determine if the indexing schemes are interval schemes so that they can be
represented exactly and if not how it can be altered into interval schemes to be
represented as approximations. Third, we split up the interval schemes so that
the region constants can express them. Finally, we convert the interval schemes
into a joins of meets of region constants.

If there is all infinite indexing scheme, then we cannot represent it
syntactically. This happens when use of constant indices in one or more array
terms causes the offsets to be subsumed. The simplest case is when there is an
array term with all of its indices constant.

In our example, there are no constant indices, so we proceed.

After handling the trivial case, correct approximation is chosen. Recall
\Cref{def:interval-scheme}, an indexing scheme is an interval scheme if each of
the sets in products are holed intervals. If that is the case, we trivially
convert the sets in each dimension of indexing schemes to holed interval
representation and proceed to the next stage and output an exact specification
at the end. If not, then the output will definitely have an upper bound and
potentially a lower bound.

Upper bound is established by \emph{elongating} index schemes in multiple
dimensions such that they become interval schemes. The elongation function is
given as
%
\begin{align*}
  \mathit{elongate}([a,b]) = \begin{cases}
    \interv{0}{b}{\textsf{false}} & a > 1 \\
    \interv{a}{0}{\textsf{false}} & b < -1
  \end{cases}
\end{align*}

Since index schemes of the previous stage are all contiguous and form closed
intervals, 0 lying between the lower and upper bounds of intervals is sufficient
to form an interval scheme. If any dimension of an index scheme is elongated,
then the whole index scheme is elongated. In the initial set of index schemes,
all schemes that were already interval schemes form a lower bound, while those
schemes and the new interval schemes generated by elongation form the upper
bound. The reason a lower bound may not be generated is all indexing schemes
with might need elongation.

The index schemes in the example are all interval schemes, so we proceed to the
next stage noting the output will be exact.

There is no direct translation from an interval scheme such as $\interv{-2}{1}{}
\times \interv{-1}{1}{}$ to region constants. The reason is region constants
\texttt{forward} and \texttt{backward} require upper and lower bounds to be 0
respectively and \texttt{centered} requires the upper bound to be the negation
of the lower bound. The solution is to use \Cref{lem:vector-union} to break up
interval schemes into two producing $\interv{-2}{0}{} \times \interv{-1}{1}{}$
and $\interv{0}{1}{} \times \interv{-1}{1}{}$.

The extended example does not have such representation problem, so the interval
schemes are left as they are.

The final stage of inference is simply mapping interval schemes into region
constants. Each interval scheme is connected with \texttt{+}. Individual schemes
are decomposed using \Cref{lem:vector-intersect} such that each of the resulting
index schemes have all but one dimensions set to \interv{-\infty}{\infty}{}.
Each of these interval schemes are mapped to region constants using
\Cref{subfig:region-model} and connected with \texttt{*}.

In the example, $\interv{-1}{1}{} \times \interv{0}{0}{}$ is decomposed into
$\interv{-1}{1}{} \times \interv{-\infty}{\infty}{}$ and
$\interv{-\infty}{\infty}{} \times \interv{0}{0}{}$. These are then mapped to
\texttt{\stencil{c}{1}{1}{} * \stencil{p}{2}{}{}}. Decomposition of
$\interv{0}{0}{} \times \interv{-1}{1}{}$ is similar. When combined we obtain the
following specification:
%
\begin{equation*}
  \texttt{stencil readOnce,} \;
  \stencil[s]{c}{1}{1}{} \texttt{*} \stencil[s]{p}{2}{}{} \; \texttt{+} \;
  \stencil[s]{p}{1}{}{}  \texttt{*} \stencil[s]{c}{2}{1}{}
\end{equation*}
