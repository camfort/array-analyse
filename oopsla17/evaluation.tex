\newcommand{\overallStencilsSpecs}{77118}
\newcommand\regname[1]{\texttt{#1}}
\newcommand\pointed{\regname{pointed}}
\newcommand\forward{\regname{forward}}

\noindent
To study the effectiveness of our approach, we applied our tool back
onto the corpus from \Cref{sec:study}.  We used the inference
procedure of the previous section to generate array specifications
for the corpus to assess the design of the language.
%
%We first examined how
%frequently stencil computations occur. We parsed
%\num{\overalllinesParsed} lines of Fortran code and found that
%\overalltickAssignPercent\% (\num{\overalltickAssign}) of statements
%have a left-hand side as an array subscript on neighbourhood
%indices. This supports the idea that stencil-like computations are
%common in scientific code.
%
We did not expect to infer specifications for each array computation
we found because our analysis restricts the
array-subscript-statements, along the lines of~\Cref{sec:study}.
%A
%single statement can involve multiple arrays and therefore can have
%multiple specifications associated with it.
Overall we ended up with
\num{\overallnumStencilSpecs} specifications of which
\num{\overalltickLHSvar} were with a left-hand side variable rather
than a subscript (an \term{access} specification), leaving
\num{\overallStencilsSpecs} \term{stencil} specifications.
%
%For example, \num{\overalltickLHSvar}
%potential stencils were discarded because the left-hand side was not
%an array access. Overall, we were able to infer a stencil from
%\overalltickAssignSuccessPercentOfTickAssign\% of the statements
%involving an array assignment. A single statement can involve multiple
%arrays and.
This shows that we can express a large number of
array access patterns within our high-level abstractions and it validates our
initial design choices informed by our data (\Cref{subsec:choices}).

The majority of specifications generated were relatively simple but we
found significant numbers of more complex shapes. We grouped common
patterns into categories:

\textbf{All pointed} \num{\overalljustPointed} of the specifications we
generated involved only \pointed\ regions.
% 39,681 of these were pointed in all dimensions.
Common examples of this were pointwise transformations on data (such
as scaling). The remaining \num{\overallnonTrivial} we consider to
be non-trivial, \ie{} with a higher potential for programming error.

\textbf{Single-action} specifications comprise one
forward, backward, or centered region constant combined via \term{+}
or \term{*} with any number of \pointed\ regions. We identified \num{\overallsingleAction} single-action
specifications, of which \num{\overallsingleActionIrr} were single-action with a
\texttt{nonpointed} modifier.

\textbf{Multi-action} specifications comprise at least two
 forward, backward, or centered regions, combined with
any number of \pointed\ regions. We identified \num{\overallmultiAction} multi-action
specifications out of which \num{\overallmultiActionMulOnly} had regions combined only with
$\term{*}$ and \num{\overallmultiActionPlusAndMul} combined with a mix of $\term{*}$ and \term{+}.


% \begin{figure}[t]\begin{minted}[fontsize=\scriptsize,breakindent=0em,linenos=false,xleftmargin=0em,breakafter=)]{fortran}
% !=stencil readOnce,(forward(depth=1,dim=3,nonpointed))*(backward(depth=1,dim=1))*(backward(depth=1,dim=2))+(forward(depth=1,dim=3))*(backward(depth=1,dim=1))*(pointed(dim=2))+(forward(depth=1,dim=3))*(backward(depth=1,dim=1,nonpointed))*(backward(depth=1,dim=2,nonpointed))+(forward(depth=1,dim=3))*(backward(depth=1,dim=2))*(pointed(dim=1))+(backward(depth=1,dim=1))*(backward(depth=1,dim=2,nonpointed))*(pointed(dim=3))+(backward(depth=1,dim=1,nonpointed))*(backward(depth=1,dim=2))*(pointed(dim=3))::x
% \end{minted}
% \caption{Complex specification inferred from
%   \textbf{UM}\label{fig:smagorinsky}}
% \vspace{-1em}
% \end{figure}

% The single- and multi-action classes represent more complex stencils
% with a real possibility for programmer error. As an extreme example, the Unified
% Model has an implementation of the Smagorinsky subgrid-scale model for
% calculating turbulence on which our inference yields 39 specs from 340
% lines of code. This is a large reduction given
% the complexity of the algorithm.  We show one example
% in~\Cref{fig:smagorinsky} which specifies the access pattern to
% a 3-dimensional array (which we have renamed to
% \texttt{x}) arising from a kernel of 93 lines of code involving 142
% array subscripts. The specification was the most complex
% seen in our corpus, yet it still represents a significant abstraction
% of the spatial behaviour given size and complexity of the kernel it describes.

We measured the frequencies of occurrences of the operators \term{*}
and \term{+} within the inferred specifications:
\begin{center}
\vspace{0.25em}
\setlength{\tabcolsep}{0.57em}
{\small{
\hspace{-1em}\begin{tabular}{c|cccccccc}
Occurrences: & 0 & 1 & 2 & 3 & 4 & 5 & 6  \\ \hline
\term{*} & \num{\overallmulOpszero} & \num{\overallmulOpsone} & \num{\overallmulOpstwo} & \num{\overallmulOpsthree} & \num{\overallmulOpsfour} &  & \num{\overallmulOpssix} \\
\term{+} & \num{\overallplusOpszero} & \num{\overallplusOpsone} & \num{\overallplusOpstwo}
\end{tabular}}}
\vspace{0.2em}
\end{center}

\textbf{Bounded} specifications occured with \num{\overallatMost}
\texttt{atMost} bounds and \num{\overallatLeast} \texttt{atLeast}, the latter of which were
always also paired with an upper bound.

\textbf{ReadOnce} specification occurred \num{\overallreadOnce} times, which
correlates with the high proportion of unique-subscript expressions
in the initial study.

% \eg{}, roughly half the specifications did not involve $\term{*}$,
% a quarter use one $\term{*}$ and just under a quarter
% use two $\term{*}$ operators.

\subsection{Limitations}

\noindent
There were various reasons why we did not infer
specifications on every looped array computation:
\begin{itemize}
\item \textbf{Computed induction variables} where an
index (\mintinline{fortran}{x}) is computed from an
induction variable via an intermediate definition, \eg{}, 
\mintinline{fortran}{x = i + 1}, or using functions that
we could not analyse or classify;

\item \textbf{Inconsistent LHS/RHS} occur when
induction variable is used to specify more than one array dimension
on the RHS or multiple induction variables are used for the same
dimension on the RHS. These are common in matrix operations such as
LU-decomposition with assignments such as
\mintinline{fortran}{a(l) = a(l) - a(m) * b(l, m)}.
\end{itemize}

\subsection{Detecting errors in the 2-D Jacobi iteration}
\label{sec:jacobi}

\noindent
One common example of a stencil computation is the two-dimensional
Jacobi iteration that repeatedly goes through each cell in a matrix
and computes the average value of the four adjacent cells. The kernel
is given by:
\begin{minted}{fortran}
  a(i,j) = (a(i-1,j)+a(i+1,j)+a(i,j+1)+a(i,j-1))/4
\end{minted}
We infer a precise specification of its shape as:
\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil pointed(dim=1)*centered(depth=1,dim=2,nonpointed)+pointed(dim=2)*centered(depth=1,dim=1,nonpointed)
\end{minted}
%
To test our implementation,
we examined whether programmer errors would be detected by replacing
the array index offsets with $-1$, $0$, or $1$ and running our
verification algorithm. Our checking procedure correctly reported a verification
failure in each of 6,537 permutations corresponding to an error.
The iteration computes the average of four adjacent
cells so $24$ ($4$ factorial) of the possible array index perturbations
are correct, all of which are accepted by our checker.

\subsection{Verification case studies}
\label{sec:case-studies}

\subsubsection{Catching bugs}

Detecting whether an error could have been prevented by a stencil
specification is difficult because it requires knowledge of the
programmer's intent. However, this is occasionally captured in commit
messages accompanying a code change. For example in the Unified Model
we identified an example of an off-by-1 error that could have been
avoided through the use of stencil specification. The buggy code was
identified as \pointed\ in all dimensions by our inference:

\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil readOnce, pointed(dim=1)*pointed(dim=2)*pointed(dim=3)
\end{minted}
%
But the programmer made it clear in the comments after the bug fix
that the intention had been \forward\ in the third dimension, \ie{}, a
specification:
%
\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil readOnce, forward(depth=1, dim=3, nonpointed)*pointed(dim=1)*pointed(dim=2)
\end{minted}
%
We found a similar bug in 
Cliffs\footnote{\url{https://github.com/Delta-function/cliffs-src/commit/e2ca312cfc5398287c7ca8594e977658617c2540}}
where a subscript \fortran{u(i)} is corrected to \fortran{u(i-1)} which
could have been detected by an initial specification of \fortran{!=
  stencil backward(depth=1, dim=1, nonpointed)}.


\subsubsection{Aiding refactoring}

One of the initial goals of CamFort was to provide tools that enable
optimisation and refactoring without changing behaviour, and the
array specification feature was designed with that in mind. But
while we were perusing real-world source bases, we realised that there
were also many cases where CamFort could help with refactorings
precisely because they required changes in behaviour. For example, a
relatively common change observed in the logs of revision control for
our corpus is the refactoring of array dimensions. Either
re-ordering, adding or deleting dimensions. Any of these, if not
perfectly propagated throughout all uses, could result in unexpected
outcomes. However, CamFort will pick up the difference during its
stencil specification checking. Ideally, an experienced programmer might
take advantage of the region variable feature of CamFort in order to
minimise the number of specifications that need changing and gain the
full time-saving advantage. But even if not, a quick search for the
specifications can have them updated quickly and then any code that is
not updated will trigger an error when checked.

An example of a refactored region adding a single dimension to an array, adapted from the UM:
\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  ! before
  != region :: r = readOnce, pointed(dim=1)
  ! after
  != region :: r = readOnce, pointed(dim=1)*pointed(dim=2)
\end{minted}


% \subsubsection{Stress-testing CamFort}
