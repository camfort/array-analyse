%
We outline here the procedures for checking conformance
of source code against specifications (\Cref{subsec:checking})
and for inferring specifications from code (\Cref{subsec:inference}).
Both rely on a program analysis that converts array subscripts
 into sets of index schemes. We outline this analysis
first (\cref{subsec:analysis}). Note that the analysis
can be made arbitrarily more complex and wide-ranging independent
of the checking and inference procedures. At the moment, the analysis
is largely \emph{syntactic}, with only a small amount of
semantic interpretation of the code.

\subsection{Union Normal Form}\label{subsec:union-normal-form}

We need to address the problem of representation in the model both for observed
array terms converted into subscripts schemes and for specifications converted
into interval schemes. In each case, the objects are sets and union and
intersection are the combinators. However, they are often infinite sets due to
infinite interval and constant indices being converted to \bz{}. This calls for
a finite (and ideally compact) representation for indices.

First recall \Cref{lem:vector-intersect}, which states that intersection of
indexing schemes is still an indexing scheme. When combined with
\Cref{lem:interval-identities}, we can extend this closure to interval schemes.
Subscripts schemes do not enjoy the same propery as intersection of two
singleton sets might easily be empty, which disqualifies it from being a
subscript index. In the following section we will not rely on intersection of
subscript indices, so that is okay.

Union is, however, not as flexible as intersection. \Cref{lem:vector-union} does
not form a closure for indexing schemes in general. For this reason, we
represent collection of all forms of indexing schemes as unevaluated unions.
Since the model forms a distributive lattice as established in
\Cref{prop:region-lattice}, the intersections can be pushed in using the
distributive law leaving only unions. We further exploit associativity of union
to put unions into a cons tree making the unions effectively a non-empty list.
We do not, however, attempt to canonicalise the representation.


\subsection{Analysis of array accesses}
\label{subsec:analysis}

\newcommand{\neigh}{\textsf{neigh}}

The analysis builds on standard program analyses:
%
\textbf{(1)} basic blocks (CFG);
\textbf{(2)} induction variables per basic block;
\textbf{(3)} (interprocedural) data-flow analysis, providing a \emph{flows to}
  graph (as shorthand, the function
  $\mathsf{flowTo}$ is used, implicitly parameterised by this graph,
  mapping an expression to the set of all expressions
  with forwards data-flow to this expression, based on the transitive
  closure of the flows graph);
\textbf{(4)} type information per variable.% where we use the predicate
%\arrayTy{} to classify variables of array type.


\subsection{Checking code against specifications}
\label{subsec:checking}

In the model, we can regard both array indices and specifications as groups of
points in $N$-dimensional space. Notion of consistency is then intuitively
whether these two (potentially infinite) sets of points in space match or not.
This leads to a simple set based consistency function defined as
%
\begin{align*}
  \mathit{consistent} & :
    \mathsf{Mult}(\mathcal{P}(\mathcal{P}(\bz{})^N)) \times
    \mathsf{Mult}(\mathsf{Approx}(\region{N})) \to \mathbb{B} & \\
%
  \mathit{consistent}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    \mathsf{false} & \mathit{model} = \mathsf{once}(x) \wedge ix = \mathsf{mult}(y) \\
    \mathit{consistent'}(\mathit{peel}(ix), \mathit{peel}(model)) & \textit{otherwise}
  \end{cases} \\
%
  \mathit{consistent'} & :
    \mathcal{P}(\mathcal{P}(\bz{})^N) \times
    \mathsf{Approx}(\region{N}) \to \mathbb{B} & \\
%
  \mathit{consistent'}(\mathit{ix}, \mathit{model}) & = \begin{cases}
    m = \mathit{ix} & \mathit{model} = \mathsf{exact}(m) \\
    m \supseteq \mathit{ix} & \mathit{model} = \mathsf{upper}(m) \\
    m \subseteq \mathit{ix} & \mathit{model} = \mathsf{lower}(m)
  \end{cases}
\end{align*}
%
The first function, $\mathit{consistent}$, checks whether the linearity of the
specification matches that of the indices, \ie{} if the specification allows
indices to be repeated or not.Then it delegates to $\mathit{consistent'}$
function which checks if the points observed in the array expression matches
the space defined by the specification. Lower bounds, marked by \texttt{atLeast}
modifier, require the space defined by the specification to remain inside the
set of indices, while an upper bound, market by \texttt{atMost} modifier,
requires the opposite: enclosure. In the absence of such modifiers, we expect
the space defined by observed indices correspond exactly those defined by the
region in the specification, hence requiring set equality.

Reader will realise that since index schemes allows infinite intervals in the
product, set equality cannot be done by exhaustively checking the points of one
are inside the other. Instead, we compile the region into interval constraints
and subscript schemes into membership constraints and pass it to
\textsc{Z3}~\citep{de2008z3} SMT solver to see if they are equal. The query
belongs to to quantifier free linear arithmetic, which is a decidable theory.
Performance of consistency checking using SMT solver is irrelevant as the number
of interval constraints and the number of indices that can reasonably appear in
an assignment is too small restricting the size of the formula being checked.

\mnote{It would be great if we had data on number of indexing expressions that
occur (counting the ones that flow in) and also the length of specifications
(which I think we do generate). This would justify my efficiency claims}.


\subsection{Infering specification automatically}
\label{subsec:inference}
%
We provide an inference procedure for generating specifications from
code, which are inserted automatically as comments. This helps support
maintenance of legacy code, and aids understanding of our
specification language. We illustrate inference using the
five-point stencil of \Cref{exm:checking}.

The preceding source code analysis converts the concrete syntax of
array subscripts into a set of subscript schemes in
$\mathcal{P}(\bz)^N$. These subscripts are then coalesced interatively
into sets of index schemes. We denote sets of index schemes by
$\mathcal{S}$, and initial set of subscript schemes from the analysis
as $\mathcal{S}_0$. For our example:
%
\begin{equation*}
\mathcal{S}_0 = \{\{0\} \times \{0\}, \{-1\} \times \{0\},
\{0\} \times \{-1\}, \{0\} \times \{1\}, \{1\} \times \{0\}\}
\end{equation*}

%For each array variable $a \in \mathsf{dom}(U)$, the algorithm
%constructs a set of $n$-dimensional rectangles covering all contiguous
%groups of schemes in $U(a)$.

\begin{enumerate}[leftmargin=1.5em]
\item (\textbf{Covering})
A covering of (possibly overlapping) the subscript space
is calculated as a value of $Region_N$. This is computed iteratively
by the following steps until a fixed-point is reached:

\begin{enumerate}[leftmargin=0.5em]
\item (\textbf{Coalesce intervals})
%
Index schemes which are \emph{contiguous} in one dimension are
coalesced.

\newcommand{\contig}[2]{\mathsf{contig}(#1, #2)}
\begin{defn}{[Contiguous]}
Two index schemes $S$ and $T$ are \emph{contiguous}
written $\contig{S}{T}$,
iff $\pi_i(S) = \pi_i(T)$
for all $1 \leq i \leq N$ apart from some dimension $k$ such that
$\pi_k(S) = [a, b]$ and $\pi_k(T) = [b+1, c]$.
\end{defn}
%
A coalesced set of index schemes is computed by:%
\begin{align*}
\mathsf{coalesce1}(S, \mathcal{S}) & =
 \{\,S \cup T \mid
T \in \mathcal{S} \, \wedge \,
\contig{S}{T} \} \\
\mathsf{coalesce}(\mathcal{S}) & =
\bigcup_{S \in \mathcal{S}} \mathsf{coalesce}(
\mathsf{coalesce1}(S, \mathcal{S})
\cup (\mathcal{S} - \{S\})) \\
\mathsf{coalesceTop}(\mathcal{S}) & =
 \mathsf{coalesce}(\mathcal{S})
\; \cup \;
\{ S \in \mathcal{S} \mid \neg \exists T \in \mathcal{S} . \; \contig{S}{T}\}
\end{align*}
\dnote{May need to prove that this is total}
%\begin{align*}
%\mathsf{coalesce}(\mathcal{S}) = \; &
%\{\,S \cup T \mid
%\forall S \in \mathcal{S}, \;
%\forall T \in \mathcal{S}. \;
%\contig{S}{T} \} \\
%\cup \; &
%\{ \,\;\;\; S \;\;\; \mid \forall S \in \mathcal{S},
%\; \not \exists T \in \mathcal{S} . \; \contig{S}{T}\}
%\end{align*}
%
That is, the new set of index schemes $\mathsf{coalesce}(\mathcal{S})$
comprises the union of the set of coalesced pairs of contiguous
schemes and the set of index schemes for which there is no other
contiguous scheme.
\item (\textbf{Remove redundant schemes})
Any indexing schemes which are subsumed by another are filtered out:
%
\begin{align*}
\textsf{nonOverlap}(\mathcal{S}) =
\{S \mid \forall S \in \mathcal{S}, \; \not \exists T \in (\mathcal{S} -
  \{S\}), \; \forall i . \; \pi_i(S) \subseteq \pi_i(T) \}
\end{align*}
%
\dnote{I'm starting to suspect that this step is actually redundant
  now- but I will need to do some math to check}
%\item \textbf{Covering}
\end{enumerate}
The least fixed-point of $\textsf{nonOverlap} \circ \textsf{coalesce}$
is computed, providing a minimal indexing scheme covering the space.
\dnote{Proof?}

For our example:
%
\begin{align*}
\textsf{coalesce}(\mathcal{S}_0) & =
\{[-1,0] \times [0,0],\,[0,0] \times [-1, 0],\,[0,0] \times [0,1],\,[0,1]
  \times [0,0]\} \\
%\textsf{nonOverlap}(\textsf{coalesce}(\mathcal{S}_0)) & =
%                                                        \textsf{coalesce}(\mathcal{S}_0)
%  \\
\textsf{coalesce}^2(\mathcal{S}_0) & =
\{[-1, 1] \times [0, 0],\,[0, 0] \times [-1, 1]\}
\end{align*}
%
The fixed-pointed is reached within two applications of
\textsf{coalesce} for our example.
\dnote{We probably need to say something about classifying index
schemes are \textit{Region$_N$}?}
\item (\textbf{Index schemes to syntax}) \dnote{Mistral todo}
\end{enumerate}
