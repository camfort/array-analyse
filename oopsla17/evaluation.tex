
\newcommand\regname[1]{\texttt{#1}}
\newcommand\pointed{\regname{pointed}}
\newcommand\forward{\regname{forward}}

To study the effectiveness of our approach, we applied our tool to the
more than one million lines of source code contained within the corpus
that we have assembled (\Cref{sec:study}). We first examined how
frequently stencil computations occur. We parsed
\num{\overalllinesParsed} lines of Fortran code and found that
\overalltickAssignPercent\% (\num{\overalltickAssign}) of statements
have a left-hand side as an array subscript on neighbourhood
indices. This supports the idea that stencil-like computations are
common in scientific code.  We then used the inference procedure of
the previous section to generate specifications for stencils in the
corpus to assess the design of the language.

We would not expect to infer a stencil for each array statement we
found because our analysis restricts the array-subscript-statements
that we classify as a stencil. For example, \num{\overalltickLHSvar}
potential stencils were discarded because the left-hand side was not
an array access. Overall, we were able to infer a stencil from
\overalltickAssignSuccessPercentOfTickAssign\% of the statements
involving an array assignment. A single statement can involve multiple
arrays and we ended up with \num{\overallnumStencilSpecs}
specifications. This shows that we can express a large number of
stencil shapes within our high-level abstraction and validates our
initial hypothesis that many stencil computations have a regular
shape.

The majority of specifications generated were relatively simple but we
found significant numbers of more complex shapes. We grouped common
patterns into categories:

\textbf{All pointed} \num{\overalljustPointed} of the stencils we
found involved only \pointed\ regions.
% 39,681 of these were pointed in all dimensions.
Common examples of this were pointwise transformations on data (such
as scaling).

\textbf{Single-action} specifications comprise one
forward, backward, or centered region constant combined via \term{+}
or \term{*} with any number of \pointed\ regions. We identified \num{\overallsingleAction} single-action
specifications, of which \num{\overallsingleActionIrr} were single-action with a
\texttt{nonpointed} modifier.

\textbf{Multi-action} specifications comprise at least two
 forward, backward, or centered regions, combined with
any number of \pointed\ regions. We identified \num{\overallmultiAction} multi-action
specifications out of which \num{\overallmultiActionMulOnly} had regions combined only with
$\term{*}$ and \num{\overallmultiActionPlusAndMul} combined with a mix of $\term{*}$ and \term{+}.


% \begin{figure}[t]\begin{minted}[fontsize=\scriptsize,breakindent=0em,linenos=false,xleftmargin=0em,breakafter=)]{fortran}
% !=stencil readOnce,(forward(depth=1,dim=3,nonpointed))*(backward(depth=1,dim=1))*(backward(depth=1,dim=2))+(forward(depth=1,dim=3))*(backward(depth=1,dim=1))*(pointed(dim=2))+(forward(depth=1,dim=3))*(backward(depth=1,dim=1,nonpointed))*(backward(depth=1,dim=2,nonpointed))+(forward(depth=1,dim=3))*(backward(depth=1,dim=2))*(pointed(dim=1))+(backward(depth=1,dim=1))*(backward(depth=1,dim=2,nonpointed))*(pointed(dim=3))+(backward(depth=1,dim=1,nonpointed))*(backward(depth=1,dim=2))*(pointed(dim=3))::x
% \end{minted}
% \caption{Complex specification inferred from
%   \textbf{UM}\label{fig:smagorinsky}}
% \vspace{-1em}
% \end{figure}

% The single- and multi-action classes represent more complex stencils
% with a real possibility for programmer error. As an extreme example, the Unified
% Model has an implementation of the Smagorinsky subgrid-scale model for
% calculating turbulence on which our inference yields 39 specs from 340
% lines of code. This is a large reduction given
% the complexity of the algorithm.  We show one example
% in~\Cref{fig:smagorinsky} which specifies the access pattern to
% a 3-dimensional array (which we have renamed to
% \texttt{x}) arising from a kernel of 93 lines of code involving 142
% array subscripts. The specification was the most complex
% seen in our corpus, yet it still represents a significant abstraction
% of the spatial behaviour given size and complexity of the kernel it describes.

We measured the frequencies of occurrences of the operators \term{*} and \term{+} within stencil specifications inferred from our corpus:
\begin{center}
\vspace{0.25em}
\setlength{\tabcolsep}{0.57em}
{\small{
\hspace{-1em}\begin{tabular}{c|cccccccc}
Occurrences: & 0 & 1 & 2 & 3 & 4 & 5 & 6  \\ \hline
\term{*} & \num{\overallmulOpszero} & \num{\overallmulOpsone} & \num{\overallmulOpstwo} & \num{\overallmulOpsthree} & \num{\overallmulOpsfour} &  & \num{\overallmulOpssix} \\
\term{+} & \num{\overallplusOpszero} & \num{\overallplusOpsone} & \num{\overallplusOpstwo}
\end{tabular}}}
\vspace{0.2em}
\end{center}

\textbf{Bounded} specifications occured with \num{\overallatMost}
\texttt{atMost} bounds and \num{\overallatLeast} \texttt{atLeast}, the latter of which were
always also paired with an upper bound.


% \eg{}, roughly half the specifications did not involve $\term{*}$,
% a quarter use one $\term{*}$ and just under a quarter
% use two $\term{*}$ operators.

\subsection{Limitations}

There were various reasons why we did not infer
specifications on every looped array computation:
\begin{itemize}
\item \textbf{Non-subset induction variables} occur when the
induction variables on the RHS are not a subset of those in the LHS. These
cases are not stencils by our definition. The degenerate case of this
is to have only constant indices on the LHS. We see lots of examples
of this in loops as accumulators \eg{} computing the sum over an array;

\item \textbf{Derived induction variables} where an
index (\mintinline{fortran}{x}) is derived from an
induction variable (\mintinline{fortran}{i}) as in
\mintinline{fortran}{x = len - i};

\item \textbf{Inconsistent induction dimensions} occur when
an induction variable is used to specify more than one array dimension
on the RHS or multiple induction variables are used for the same
dimension on the RHS. These are common in matrix operations such as
LU-decomposition with assignments such as
\mintinline{fortran}{a(l) = a(l) - a(m) * b(l, m)}.
\end{itemize}

\subsection{Detecting errors in the 2-D Jacobi iteration}
\label{sec:jacobi}
One common example of a stencil computation is the two-dimensional
Jacobi iteration that repeatedly goes through each cell in a matrix
and computes the average value of the four adjacent cells. The kernel
is given by:
\begin{minted}{fortran}
  a(i,j) = (a(i-1,j)+a(i+1,j)+a(i,j+1)+a(i,j-1))/4
\end{minted}
We infer a precise specification of its shape as:
\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil pointed(dim=1)*centered(depth=1,dim=2,nonpointed)+pointed(dim=2)*centered(depth=1,dim=1,nonpointed)
\end{minted}
%
To test our implementation,
we examined whether programmer errors would be detected by replacing
the array index offsets with $-1$, $0$, or $1$ and running our
verification algorithm. Our checking procedure correctly reported a verification
failure in each of 6,537 permutations corresponding to an error.
The iteration computes the average of four adjacent
cells so $24$ ($4$ factorial) of the possible array index perturbations
are correct, all of which are accepted by our checker.

\subsection{Verification case studies}
\label{sec:case-studies}

\subsubsection{Catching bugs}

One problem we face while examining the millions of line of source
code is that we do not have the original programmer's intention at
hand. But sometimes we have the next best thing, the log entry in the
revision control system. Scanning through the UM we identified an
example of an off-by-1 error that could have been avoided through the
use of stencil specification. The buggy code was identified as
\pointed\ in all dimensions:

\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil readOnce, pointed(dim=1)*pointed(dim=2)*pointed(dim=3)
\end{minted}

But the programmer made it clear in the comments after the bug fix
that the intention had been \forward\ in the third dimension:

\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  != stencil readOnce, forward(depth=1, dim=3, nonpointed)*pointed(dim=1)*pointed(dim=2)
\end{minted}


\subsubsection{Aiding refactoring}

One of the initial goals of CamFort was to provide tools that enable
optimisation and refactoring without changing behaviour, and the
array specification feature was designed with that in mind. But
while we were perusing real-world source bases, we realised that there
were also many cases where CamFort could help with refactoring
precisely because they required changes in behaviour. For example, a
relatively common change observed in the logs of revision control for
our corpus is the refactoring of array dimensions. Either
re-ordering, adding or deleting dimensions. Any of these, if not
perfectly propagated throughout all uses, could result in unexpected
outcomes. However, CamFort will pick up the difference during its
stencil specification checking. Ideally, an experienced programmer may
take advantage of the region variable feature of CamFort in order to
minimise the number of specifications that need changing and gain the
full time-saving advantage. But even if not, a quick search for the
specifications can have them updated quickly and then any code that is
not updated will trigger an error when checked.

An example of a refactored region adding a single dimension to an array, adapted from the UM:
\begin{minted}[breakafter=+:,breakindent=-0.6em,breaksymbolsep=0.4em,linenos=false,xleftmargin=-0.5em]{fortran}
  ! before
  != region :: r = readOnce, pointed(dim=1)
  ! after
  != region :: r = readOnce, pointed(dim=1)*pointed(dim=2)
\end{minted}


% \subsubsection{Stress-testing CamFort}
