\documentclass[9pt,preprint]{sigplanconf}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{graphics}
\usepackage{fancyvrb}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{minted}
\usepackage{breqn}
\usepackage{enumitem}
%\usepackage{subcaption}
\usepackage{siunitx} % For pretty-printing numeric values and SI units
                     % of measure. e.g., the tabular column type S is
                     % used to print nice-looking tables of numbers.
\sisetup{ % defaults
  group-separator={,},
  group-minimum-digits={3},
  output-decimal-marker={.},
  table-format = 6
}

\usepackage{tikz}
\usepackage{xypic}
\usepackage{natbib}

\usetikzlibrary{calc}

%% http://tex.stackexchange.com/questions/55068/is-there-a-tikz-equivalent-to-the-pstricks-ncbar-command
\tikzset{
    ncbar angle/.initial=90,
    ncbar/.style={
        to path=(\tikztostart)
        -- ($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)
        -- ($(\tikztotarget)!($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztostart)$)
        -- (\tikztotarget)
    },
    ncbar/.default=0.5cm,
}

\tikzset{round left paren/.style={ncbar=0.4cm,out=110,in=-110}}
\tikzset{round right paren/.style={ncbar=0.4cm,out=70,in=-70}}


\fvset{
  linenos=true,
  fontsize=\footnotesize,
  breaklines=true,
  breakafter=),
  xleftmargin=\parindent
}

\usemintedstyle{vs}

\definecolor{darkblue}{rgb}{0.0,0.0,0.5}
\definecolor{darkgreen}{rgb}{0.0,0.4,0.0}
\definecolor{darkdarkgreen}{rgb}{0.0,0.35,0.0}

\usepackage{hyperref}
\hypersetup{
    unicode=false,          % non-Latin characters in Acrobat's bookmarks
    pdftoolbar=true,        % show Acrobat toolbar?
    pdfmenubar=true,        % show Acrobat menu?
    pdffitwindow=false,      % page fit to window when opened
    pdftitle={},    % title
    pdfauthor={}
    pdfsubject={},   % subject of the document
    pdfnewwindow=true,      % links in new window
    pdfkeywords={keywords}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=darkblue,          % color of internal links
    citecolor=darkblue,        % color of links to bibliography
    filecolor=green,      % color of file links
    urlcolor=blue,          % color of external links
}


\CustomVerbatimEnvironment{SpecVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98,numbersep=0.9em}
\CustomVerbatimEnvironment{ExmVerbatim}{Verbatim}{fontsize=\footnotesize,xleftmargin=0.5cm,
xrightmargin=0.2cm,baselinestretch=0.98,numbers=left,numbersep=0.9em,commandchars=\\\{\}}
\CustomVerbatimEnvironment{IVerbatim}{Verbatim}{fontsize=\relsize{-1},xleftmargin=0.5cm,
xrightmargin=0.2cm,commandchars=\\\{\},baselinestretch=0.98,numbersep=0.9em}


\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}
\definecolor{darkpurple}{rgb}{0.6,0.0,0.6}
\definecolor{orange}{rgb}{0.8,0.4,0.0}
\definecolor{darkorange}{rgb}{0.5,0.2,0.0}
\definecolor{marco}{rgb}{0.0,0.3,0.5}
\definecolor{gray}{rgb}{0.2,0.2,0.2}

\newcommand\mdef{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

\newcommand{\bn}{\mathbb{N}}

\newcommand{\todo}[1]{\textcolor{blue}{Dom: #1}}
\newcommand{\dnote}[1]{\textcolor{darkpurple}{Dom: #1}}
\newcommand{\mnote}[1]{\textcolor{darkgreen}{Mistral: #1}}
\newcommand{\anote}[1]{\textcolor{red}{Andy: #1}}

\newcounter{block}

\newtheorem{lemma}[block]{Lemma}
\newtheorem{proposition}[block]{Proposition}

\theoremstyle{definition}

\newtheorem{theorem}[block]{Theorem}
\newtheorem{remark}[block]{Remark}
\newtheorem{example}[block]{Example}
\newtheorem{definition}[block]{Definition}

% Writing macros
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}

\newcommand{\dimId}{\texttt{dim}}

% Semantics related
\newcommand{\interp}[1]{\llbracket{#1}\rrbracket}

% Syntax macros
\newcommand{\nonterm}[1]{\textit{#1}}
\newcommand{\term}[1]{\texttt{#1}}

\newcommand{\stenRefl}[1]{\term{pointwise} \, (\term{dim=}#1)}
\newcommand{\stenFwd}[3]{\term{forward} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\stenBwd}[3]{\term{backward} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\stenCen}[3]{\term{centered} \, (\term{depth=}#1,
  \term{dim=}#2{#3})}
\newcommand{\irrefl}{\texttt{nonpointwise}}

\newcommand{\stenReflS}[1]{\term{point} \, (\term{dim=}#1)}
\newcommand{\stenFwdS}[2]{\term{fwd} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\stenBwdS}[2]{\term{bwd} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\stenCenS}[2]{\term{cen} \, (\term{depth=}#1,
  \term{dim=}#2)}
\newcommand{\irreflS}{\texttt{nonpoint}}

\newcommand{\stenFwdSR}[3]{\term{fwd} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenBwdSR}[3]{\term{bwd} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenCenSR}[3]{\term{cen} (\term{depth=}#1,
  \term{dim=}#2, #3)}
\newcommand{\stenReflSR}[1]{\term{point} (\term{dim=}#1)}

% SYNTAX OPERATIONS AND PREDICATES
%\newcommand{\neigh}{\textsf{neigh}}
\newcommand{\arrayTy}{\textsf{array}}
\newcommand{\rhsExp}{\textsf{rhsExp}}
\newcommand{\var}{\textsf{var}}

%% VECTOR NOTATIONS
\newcommand{\vect}[1]{\textbf{#1}}

\newcommand{\vtwohs}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{cc}#1 \, & \, #2\end{array}\right]\!}

\newcommand{\vtwoh}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{cc}#1 \; & \; #2\end{array}\right]}

\newcommand{\vthreeh}[3]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{ccc}#1 \; & \; #2 \; & \; #3\end{array}\right]}
\newcommand{\vtwo}[2]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}#1\\#2\end{array}\right]}
\newcommand{\vthree}[3]{\setlength{\arraycolsep}{0em}
\left[\begin{array}{l}$#1$\\$#2$\\$#3$\end{array}\right]}
\newcommand{\stwo}[4]
%{\vtwo{#1}{#2}\!\vtwo{#3}{#4}}
{\setlength{\arraycolsep}{0.1em}
\left[\begin{array}{rr}$#1$ & $#3$\\$#2$ & $#4$\end{array}\right]}

\newcommand{\singleEntry}[2]{\textbf{J}_{#2}^{#1}}
\newcommand{\zeroEntry}[2]{\textbf{K}_{#2}^{#1}}

%% OPERATIONS ON SPANS and VECTORS
\newcommand{\containedin}{\sqsubseteq}

%% MODEL
\newcommand{\effdims}[2]{\mathit{constr}(#1)_{#2}}

\newcommand{\trule}[1]{{\footnotesize{#1}}}
%\include{results}

\title{Verification of Stencil Computations with Spatial
  Specifications}
%\titlebanner{DRAFT -- Do not distribute}
\authorinfo{}{}{}
%\preprintfooter{DO NOT DISTRIBUTE}

\begin{document}
\maketitle

\keywords{program verification, specification, stencils}

\bibliographystyle{abbrvnat}

\section{Introduction}

\emph{Stencils} are a ubiquitous programming pattern, common in
scientific and numerical computing applications. Informally, a stencil
computation computes an array whose value at each index $i$ is
calculated from a \emph{neighbourhood} of values around $i$ in some
input array(s), \eg{}, the Game of Life, convolutions in image
processing, approximations to differential equations. For example, the
following computes the one-dimensional discrete Laplace transform (an
approximation to a derivative) in Fortran:
%
\begin{minted}{fortran}
do i = 1, (n-1)
      b(i) = a(i-1) - 2*a(i) + a(i+1)
end do
\end{minted}
%
Values \texttt{b(i)} are calculated from a neighbourhood of elements
around \texttt{i} in the input array \texttt{a}.  In this example, the
access pattern is simple and easily understood. More complex
stencil computations are more prone to errors from simple lexical
mistakes. For example, the following is a three-line snippet from a
Navier-Stokes fluid simulator in which two arrays are read with
different data access patterns, across two dimensions.
%%
\begin{minted}[firstnumber=20,xleftmargin=2em]{fortran}
du2dx = ((u(i,j)+u(i+1,j))*(u(i,j)+u(i+1,j))+   &
  gamma*abs(u(i,j)+u(i+1,j))*(u(i,j)-u(i+1,j))- &
  (u(i-1,j)+u(i,j))*(u(i-1,j)+u(i,j))-          &
  gamma*abs(u(i-1,j)+u(i,j))*(u(i-1,j)-u(i,j))) &
  /(4.0*delx)

duvdy = ((v(i,j)+v(i+1,j))*(u(i,j)+u(i,j+1))+   &
  gamma*abs(v(i,j)+v(i+1,j))*(u(i,j)-u(i,j+1))- &
  (v(i,j-1)+v(i+1,j-1))*(u(i,j-1)+u(i,j))-      &
  gamma*abs(v(i,j-1)+v(i+1,j-1))*(u(i,j-1)-     & 
  u(i,j))) / (4.0*dely)

laplu = (u(i+1,j)-2.0*u(i,j)+u(i-1,j))/delx/delx+ &
  (u(i,j+1)-2.0*u(i,j)+u(i,j-1))/dely/dely

f(i,j) = u(i,j)+del_t*(laplu/Re-du2dx-duvdy)
\end{minted}
%%
The access pattern is much harder to understand than the
one-dimensional Laplace.  The miasma of indexing expressions of the
form \texttt{var(i$\pm$a, j$\pm$b)} is not only hard to read, but is
prone to simple textual input mistakes, \eg{}, swapping \texttt{-} and
\texttt{+}, missing an indexing term, or transforming the wrong
variable \eg{} \texttt{(i+1,j)} instead of \texttt{(i,j+1)}.

In practice, we find that the usual development procedure for complex
stencil computations involves some ad hoc testing to ensure that no
transcription mistakes have been made. This may involve visual
inspection of the results, based on a rendered image. Typically such
testing is then discarded once the code is seen to be correct.

This is not the only information that is typically discarded. The
shape of the indexing pattern is often a result of choices made in the
numerical-analysis discretisation procedure used to convert a set of
continuous equations into a discrete approximation. Rarely are these
decisions captured in the source code, yet the shape of access is
usually uniform and is given a perspicuous and concise description in
numerical analysis literature \eg{}, ``\emph{centered in space, to a
  depth of 1}'' referring to indexing terms \texttt{a(i)},
\texttt{a(i-1)} and \texttt{a(i+1)}.

To support the development of correct stencil computations, we propose
a simple, abstract specification language for the data access pattern
of stencils. The shape of the stencil computation in the
Laplace example is specifed in our language as:
%
\begin{minted}[linenos=false]{fortran}
!=  stencil centered(depth=1, dim=1) :: a
\end{minted}
%
This describes that \texttt{a} is accessed with a symmetrical pattern
(``centered'') to a depth of one in each direction in its first
dimension.  The stencil computation shape in the Navier-Stokes example
is specified as:
%
\begin{minted}[linenos=false,xleftmargin=4em,breakindent=3em]{fortran}
!= stencil centered(depth=1,dim=1) * pointwise(dim=2) + centered(depth=1,dim=2) * pointwise(dim=1) :: u

!= stencil forward(depth=1,dim=1) * backward(depth=1,dim=2) :: v
\end{minted}
%
The specification requires that, over the whole fragment, \texttt{u}
is accessed with a centered pattern to depth of 1 in both dimensions
(this is known as the \emph{five-point stencil}) and \texttt{v} is
accessed in a neighbourhood bounded forwards to depth of $1$ in the
first dimension and backward to a depth of $1$ in the second
dimension.

We provide a verification tool for such specification which can check
the correctness of code against the specification, and can also infer
specifications, synthesising these as comments in the
source code. The main features and benefits of our approach are as follows:
%
\begin{itemize}
\item The main use case is that a programmers writes a specification
  first (perhaps informed by their numerical analysis), then writes
  the corresponding source code, and lastly has the tool check its
  conformance to the specifications. This specify-and-check approach
  removes the usually ad hoc testing effort, and provides the
  opportunity for easy re-verification in the event of any refactoring
  of software maintenance activities.
%
\item The specification provides a concise description which can be
  preserved in the source code to provide documentation to future
  developers, contrasting with ad hoc tests which are usually
  discarded or specialised to the development environment. Separate from the
  verification procedure, the infer-and-synthesise mode of the tool
  provides a way to automatically generate additional useful
  documentation for future users.
%
\item Specifications are integrated into the code as comments for easy
integration with existing tools, as well as
  documentation systems (\eg{}, we support Doxygen and FORD syntax).
%
\item Our specification format is deliberately abstract, with a small
  number of combinators that \emph{do not involve any indexing
    expressions}, \eg{} does not involve expressions like
  \texttt{a(i+1,j-1)}. This contrasts with other stencil specification
  approaches. For example, the work of Kamil et al.~\cite{kamil2016verified}
  provides full-functionality specifications of stencil computations from which
  equivalent DSL code can be generated.  If a user wishes to specify, say, the
  Naiver-Stokes stencil above, they must write a specification which is very
  similar, involving textually dense array-indexing expressions. Therefore any
  low-level mistakes that could be made programming complex indexing code could
  also be made when writing a specification. Our specifications are much more
  abstract, and also more lightweight with the aim of aiding adoption by
  scientists.
\end{itemize}

It should be noted that our verification tool does not deal in the
class of bugs that can be detected automatically (\emph{push-button
  verification}). Instead, stencil computation bugs must largely be
identified relative to a specification of the intended behaviour.

In this paper, we make the following contributions:
%
\begin{itemize}
\item we introduce our specification language for stencils
  that captures many common forms of data access pattern
  (\S~\ref{sec:lang});

\item we detail checking and inference algorithms for our
  specifications (\S~\ref{sec:analysis}), derived from a
  denotational model for the specificaiton language
  (\S~\ref{sec:semantics});

\item we provide an implementation of our approach as an extension to
  CamFort, an open-source program analysis tool for Fortran;

\item we report on a quantitative study of stencil computations on a
  corpus of numerical Fortran programs (ranging from small to large)
  (\S~\ref{sec:evaluation}), totalling one million lines of code. Our tool
  identifies and infers specifications for 35,000 stencil computations in the
  corpus. Approximately 10\% of the stencils we found are non-trivial,
  corresponding to code which is a possible source of errors. This validates
  our hypothesis that the majority of stencil computations have a regular
  shape, and validates the design of our language in its capability to capture
  many core patterns.

\item We give a detailed verification case study of two
  particular stencil computation commonly used in scientifc computing,
  simulating programming errors. Our approach is able to detect all
  possible indexing errors for these computations.
\end{itemize}
%

\newcommand{\domainVal}{\mathbb{Z}_\infty}
\section{Stencil specifications}

\paragraph{Notation and convention}
%\label{sec:notation}

\renewcommand*{\arraystretch}{0.8}
For the target language, $e$ ranges over expressions (may be impure) and $v$
over its (imperative) variables. %By
%``variable'', we mean in the imperative sense (named binders to memory cells).

\begin{definition}[Base induction variable]
  An integer variable is a \emph{base induction variable} if is the
  control variable of a ``for'' loop (or equivalent, \eg{},
  \texttt{do} in Fortran for our implementation) incremented by $1$
  per iteration. The variable is interpreted as a based induction
variable only within the scope of the loop body. For brevity we
say \emph{induction variable}, which are ranged over by $i, j, k$
throughout.
%TODO: consider mentioning derived, non-based induction variables
% as we did before.
\end{definition}

\begin{definition}[Array subscripts and indices]
  An \emph{array subscript}, denoted $a(\bar{e})$, is an expression
  which reads from an array $a$ at an \emph{index} specified by a
  comma-separated sequence of integer expressions denoted $\bar{e}$ or 
  in expanded form as $(e_1, \ldots, e_n)$. An
  \emph{index} $\bar{e}$ is called \emph{relative} if it is defined in
  terms of induction variables.
\end{definition}

\begin{definition}[Neighbourhood index]
\label{def:neighbour}
  For an array subscript $a(\bar{e})$ an index $\bar{e}$ is called a
  \emph{neighbourhood index} if every $e \in \bar{e}$ is of the form
  $e \equiv i$ or $e \equiv i + c$ or $e \equiv i - c$ where $c$ is an
  integer constant. That is, a neighbourhood index is a relative index
  where each component is a constant translation of a base induction
  variable. (The relation $\equiv$ here identifies terms up-to
  commutativity of $+$ and the inverse relationship of $+$ and $-$
  \eg{}, $(-b) + i \equiv i - b$).  %We classify neighbourhood indices
%  by the predicate $\neigh_I$ where $I$ is a set of induction
%  variables. We omit $I$ when clear from the context.
\end{definition}

\dnote{Define: Stencil kernel, or maybe stencil assignment,
 and stencil much earlier than previously?}

Specification declarations associate (via
the operator $\texttt{::}$) a specification to one or more array
variables $\bar{v}$.% specifying the shape of indexing expressions for
%arrays $\bar{v}$ that are simultaenously permitted and expected within
%the code to which the specification is given.

\begin{definition}[Consistency, informal]
  A stencil specification defines a \emph{region} which, informally,
  is an n-dimensional rectangle which is possibly infinite in some
  dimensions. A stencil kernel in code is \emph{consistent} with a
  specification on array variable $a$ if every array index on $a$
  is a neighbourhood index within the $n$-dimensional rectangle
  specified by the 
\end{definition}

\subsection{Specification syntax}
\label{sec:syntax}

Figure~\ref{fig:syntax} gives the syntax of stencil specifications,
which we introduce in stages below.  The top-level is given by the
\nonterm{specification} production which splits into either a
\nonterm{regionDec} (region declaration) or a \nonterm{specDec}
(specification declaration). 

Regions comprise \emph{region constants} which are 
combined via operators \term{+} and \term{*}.

\paragraph{Region constants}

Region constants specify a pattern of continguous array accesses in a
single dimension.  Region constants are either \term{pointwise},
\term{forward}, \term{backward}, or \term{centered}.  Each region
constant has a dimension identifier $d$ given by a natural number
greater than 0. Each constant except \term{pointwise} is given a depth
parameter $n$, a natural number greater than 0; \term{pointwise}
regions implicitly have a depth of $0$. 

A \term{forward} region of depth $n$ specifies continguous
neighbourhood indices in dimension $d$ ranging from $i$ to $i + n$
inclusively for some induction variable $i$.  Similarly, a
\term{backward} region of depth $n$ specifies contiguous neighbour
indices in dimension $d$ from $i$ to $i - n$, and \term{centered}
of depth $n$ from $i - n$ to $i + n$. A \term{pointwise}
stencil specifies a neighbour index $i$. For example the
following shows three specifications with three consistent stencil
kernels reading from arrays \term{a}, \term{b}, and \term{c} respectively:
%%
\begin{minted}{fortran}
!= stencil forward(depth=2, dim=1) :: a
d(i, 0) = a(i, 0) + a(i+1, 0) + a(i+2, 0)
!= stencil backward(depth=2, dim=1) :: b
d(i, j) = b(i, j) + b(i-1, j) + b(i-2, j)
!= stencil centered(depth=1, dim=2) :: c
d(i, j) = (c(j-1) + c(j) + c(j+1))/3.0
\end{minted}
%%
Note that every dimension need not be specified for; in the above, the
specifications on lines $1$ and $5$ are the principal specifications
for code on lines $2$ and $6$, but the specification on line
$3$ is not principal for line $4$;
we return to the notion of principality later.

The \term{forward}, \term{backward}, and \term{centered} regions may
all have an additional attribute \term{nonpointwise} which marks that
the region does not include indices which are purely base induction
variables, \ie{}, offset by $0$.  For example, the following is a
\term{nonpointwise} \term{backward} stencil
%
\begin{minted}{fortran}
!= stencil backward(depth=2, dim=1, nonpointwise) :: a
b(i) = a(i-1) + a(i-2)
\end{minted}
%
The \term{nonpointwise} attribute cannot be used on \term{pointwise}
regions.



\section{A model}

We define a simple set-theoretic denotational model of the semantics
of our stencil specification language. This has a number of purposes:
(1) it serves to explain exactly the meaning of our specifications
(2) it is 
used as the basis of the inference, checking, and synthesis algorithms
(\S~\ref{sec:analysis}); (3) justifies the equational theory and
approximations of the previous section; and (4) can be used to guide
correct implementations. The model domain is over sets of vectors
which we call \emph{index schemes}, which we introduce first before
the model in \S~\ref{subsec:model}.

\begin{definition}
  An \emph{index scheme} is a vector of size $n$ (an $n$-vector) with
  values drawn from $\domainVal = \mathbb{Z} \cup \{\infty\}$.  Values
  in $\mathbb{Z}$ represent constant offsets of neighbourhood indices
  (expressions of the form $i \pm c$ where $i$ is an induction
  variable and $c$ is a constant integer, Def.~\ref{def:neighbour},
  p.~\pageref{def:neighbour}). $\infty$ represents any indexing
  behaviour--- it is a wildcard.  Throughout $u, v, w$ range over
  index schemes and $u_i$ denotes the $i^{th}$ element of $u$. We
  write $(\domainVal)^n$ for the set of $n$-dimensional schemes.
\end{definition} 

Indexing schemes give an abstract
representation of array subscripts in the source language.
Our model represents the meaning of stencil specifications
as indexing schemes, which explain the range of possible
indexing behaviours which are consistent with the specification.
The relationship between indexing schemes and source language
terms is given precisely by the following function \textsf{schematic} which
maps syntactic index expressions to indexing schemes. This
is used in inference and checking.

\newcommand{\schemeOne}{\textsf{s}_I}
%\newcommand{\schemeOne}{\textsf{schema$^1_I$}}
\newcommand{\schemeN}{\textsf{schematic}_I}
%\newcommand{\schemeN}{\textsf{schema$^n_I$}}
\begin{definition}%[Schematic]
\label{def:schematic}
Let $\schemeOne$ be a partial function, parameterised by a set of
induction variables $I$, mapping expression syntax to
$\domainVal$ values:
%%
\begin{align*}
\schemeOne(e)
 & =  \begin{cases}
c & e \equiv i + c \;\; \wedge \;\; i \in I \\
-c & e \equiv i - c \;\; \wedge \;\; i \in I \\
\infty & \textit{$I \not\subseteq \textit{FV}(e)$} \\
\bot   & \textit{otherwise}
\end{cases}
\end{align*}
where $\textit{FV}(e)$ is the set of free variables in $e$. In the
first two cases, expressions that are a constant offset of an 
induction variable (\ie{}, neighbourhood indices) are mapped to the
offset $c$ or $-c$ $\in \domainVal$. In the third case, if the
expression is not a neighbourhood index, but neither is it a relative
index (\ie{}, it is not defined in terms of an induction variable) then it
is mapped to $\infty \in \domainVal{}$. Otherwise, $\schemeOne(e)$
is undefined (returns $\bot$). 

The partial function $\schemeN$, also parameterised by a set of
induction variables $I$, uses the above operation $\schemeOne$ to
 maps from the syntax of indices to index schemes, \ie{} values of 
$\domainVal^n$. It is defined on the syntax of index
expressions $\bar{e} = (e_1, ..., e_n)$ as:
\begin{align*}
\schemeN(e_1, ..., e_n) & =
[\schemeOne(e_1) ... \schemeOne(e_n) ]
\quad \textit{iff} \;\; \forall x . \schemeOne(e_x) \neq \bot
\end{align*}
%
Thus, for an indexing expression, if each component is a neighbourhood
index, then $\schemeN$ maps it to an indexing scheme.
\end{definition}

\begin{definition}[Generalisation]
Given two schemes $v, w$ of dimensionality $n$,
then $w$ is said to \emph{generalise} $v$
(or conversely $v$ \emph{specialises} $w$),
written $v \preceq_n w$, iff the following holds:
%%
\[
v \preceq_n w \;\; \Leftrightarrow  \;\;
  \forall i\!\in\!\{ 1, \ldots, n \} . \, (w_i = \infty \, \vee \, v_i = w_i)
\]
%%
That is, two schemes are related by the (reflexive and transitive) binary relation
$\preceq_n$ over $(\mathbb{Z}_{\infty})^n$ if in each dimension
the two schemes are equal or $w_i = \infty$
in place of some $\mathbb{Z}$ in $v_i$ for $v \preceq_n w$.
Thus, the element $\infty$ generalises any index in the same dimension.
%
\end{definition}

\begin{example}
Consider the following three indexing schemes
corresponding to array indexing terms
$(i, j+1)$, $(1, j+1)$ and $(3, j)$:
%
\begin{align*}
\begin{array}{ll}
\schemeN{(i, j+1)} & =\vtwoh{0}{1} \\
\schemeN{(1, j+1)} & = \vtwoh{\infty}{1} \\
\schemeN{(3, j)} & = \vtwoh{\infty}{0}
\end{array}
\end{align*}
There is one notion of generalisation between these
schemes, namely that $\vtwoh{0}{1} \preceq_2 \vtwoh{\infty}{1}$.
At the level of syntax, this translates to saying
$(i, j+1)$ can be instantiated (specialised) to $(3, j+1)$. 

As an example of undefined \textsf{schematic},
$\textsf{schematic}(i*2, j) = \bot$ as its first index is a
non-neighbour relative index, which is outside the scope of our
specification language.
\end{example}

Our terminology of \emph{indexing schemes} and
\emph{generalisation} is by analogy
with the \emph{type schemes} and \emph{type generalisation} of
polymorphic types in ML~\cite{milner1978theory}. Our notion is
much more rigid however, as our schemes do not bind names.

\todo{Consider what to do regarding stencil model
- can give previous model, or can try to base on the work cited
on Wikipeadia that we discussed.}

\subsection{Denotational model}

Our model is given by the interpretation function $\interp{-}_n$
(where $n$ is the maximum dimensionality of the specification being
modelled) mapping closed\footnote{That is, we assume there are no
  occurrences of \textit{rvar} in a specification being modelled.  Any
  \emph{open} specification containing region variables can be made
  closed by straightforward syntactic substitution with a (closed)
  \textit{region}.} specifications to sets of
$n$-dimensional indexing schemes. The interpretation is overloaded on
\emph{regions} in Figure~\ref{fig:region-model} and on the top-level
of a specification \textit{spec} in Figure~\ref{fig:spatial-model}.

We first define some intermediate notations and definitions.

\begin{definition}A \emph{single-entry vector} of size $n$, denoted
$\singleEntry{r}{n}$, is a vector where the $r^{th}$ entry is $1$
and all others are $\infty$, \eg{}, $\singleEntry{1}{2} =
\vtwoh{1}{\infty}$ and $\singleEntry{2}{3} = \vthreeh{\infty}{1}{\infty}$.
Thus, a single-entry vector is an indexing scheme which generalises
all other schemes that have $1$ as their $r^{th}$ entry,
describing a neighbour offset of $1$.
\end{definition}

\begin{definition}
A \emph{zeroed single-entry vector} of size $n$, denoted
$\zeroEntry{r}{n}$, is a vector where the $r^{th}$ entry is $0$ and all others
are $\infty$, \eg{}, $\zeroEntry{1}{2} = \vtwoh{0}{\infty}$.
Similarly to the single-entry vector, zeroed single-entry vectors
generalise all other schemes
that have $0$ as their $r^{th}$, representing indices at
the ``origin'' in dimension $r$.
\end{definition}

\begin{figure}[t]
\vspace{-0.9em}
\input{region-model.tex}
%\textit{$a^m \in A$ means there are $n$ copies of $a$ in
%  the multi-set $A$}
\caption{Model of regions,
$\interp{-}_n : \textit{region} \rightarrow \mathcal{P}(\domainVal{}^n)$}
\label{fig:region-model}
\vspace{-1em}
\end{figure}

\noindent
The first four equations of Fig.~\ref{fig:region-model}
give the model of the region constants as sets of indexing
schemes. We illustrate with an example.

\begin{example}
For a $2$-dimensional stencil computation, then
\begin{align*}
& \interp{\stenCenS{2}{1}}_2 \\[-0.1em]
& \qquad = \; \{i\singleEntry{1}{2} \,|\, i \in \{\text{-}2,..., 2\}\!\setminus\!0 \}
  \cup  \{ \zeroEntry{1}{2} \,|\, \textit{true} \} \\[-0.2em]
& \qquad = \; \{-2\singleEntry{1}{2}, \, -\singleEntry{1}{2}, \,
  \singleEntry{1}{2}, \, 2\singleEntry{1}{2}\} \cup
  \{\zeroEntry{1}{2}\} \\[-0.2em]
& \qquad = \; \{\vtwoh{-2}{\infty}, \vtwoh{-1}{\infty}, \vtwoh{0}{\infty},
\vtwoh{1}{\infty}, \vtwoh{2}{\infty}\}
\end{align*}
Note the absorbing behaviour of $\infty$ with respect to
multiplication.
\end{example}
\noindent
The final two equations of Fig.~\ref{fig:region-model} give the models
of $\term{+}$ and $\term{*}$. For $\term{+}$ this is the
straightforward union of the models of subterms. The model of
$\term{*}$ takes the tensor $\otimes$ of subterm models. The tensor is
more involved; we give some informal intuition first.

% r+s means that indices must be consistent with either r or s 
% r*s means that indices must be consistent with both r and s at the
% same time



% specifications correspond to a set of schemes

% r+s means an index must be generalised by a scheme in either r or s
%       and every scheme in r must have an index which specialises it
%       and every scheme in s must have an index which specialises it

% r*s means an index must be generalised by a scheme in r and a scheme in s
%       and every pairs of schemes in r and s must have an index which 
%           specialises both 
%      

% r+s means indices must be consistent with either r or s
%           and there are indices why are generalised by r and s
% (there are indices which are consistent with every part of r or s)
% (every part of r and s independently have an index which is generalised by it)

% r*s means indices must be consistent simultaenously with both r and s
%           and there are indices which are generalised 
% 

%  forward(depth=1,dim=2) & pointwise(dim=1) 
% | forward(depth=1,dim=1) & pointwise(dim=2)

% (o, p) \preceq [[ ]] 

\paragraph{$\otimes$ of models}

The intuition behind $\otimes$ is that it takes
all possible pairs of indexing schemes,
and treats each pair as lower and upper bounds of an 
$n$-dimensional rectangle. From these lower and upper bounds


 treating them as the
lower and upper bounds of an $n$-dimensional rectangle from which the
remaining vertices of the rectangle are generated (like a bounding
box) \eg{}:
%%
\begin{align*}
\{\vtwohs{1}{2}, \vtwohs{5}{6}\,\} \otimes \{\vtwohs{3}{4}\} =
\{\vtwohs{1}{2}, \vtwohs{3}{2}, \vtwohs{1}{4}, \vtwohs{3}{4}, 
   \vtwohs{3}{6}, \vtwohs{5}{4}, \vtwohs{5}{6}\,\}
\end{align*}
%%
The tensor takes a Cartesian product of the two models,
giving all pairs of schemes which are combined using the
\emph{pairwise permutation} written $\bowtie$ (defined later).

\section{Checking and inference}

\subsection{Specification checking}

\subsection{Specification inference} 



\bibliography{references}

\end{document}

%%  LocalWords:  refactoring affine parameterised nonpointwise atMost
%%  LocalWords:  centered readOnce atLeast discretisation Equational
%%  LocalWords:  equational disjunction denotational dimensionality
%%  LocalWords:  interprocedural Fortran CamFort preprocessor
%%  LocalWords:  committers
